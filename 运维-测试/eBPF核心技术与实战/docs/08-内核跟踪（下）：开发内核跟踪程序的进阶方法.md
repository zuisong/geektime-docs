ä½ å¥½ï¼Œæˆ‘æ˜¯å€ªæœ‹é£ã€‚

ä¸Šä¸€è®²ï¼Œæˆ‘å¸¦ä½ æ¢³ç†äº†æŸ¥è¯¢ eBPF è·Ÿè¸ªç‚¹çš„å¸¸ç”¨æ–¹æ³•ï¼Œå¹¶ä»¥çŸ­æ—¶è¿›ç¨‹çš„è·Ÿè¸ªä¸ºä¾‹ï¼Œé€šè¿‡ bpftrace å®ç°äº†å†…æ ¸è·Ÿè¸ªç‚¹çš„è·Ÿè¸ªç¨‹åºã€‚

bpftrace ç®€å•æ˜“ç”¨ï¼Œéå¸¸é€‚åˆå…¥é—¨ï¼Œå¯ä»¥å¸¦åˆå­¦è€…è½»æ¾ä½“éªŒ eBPF çš„å„ç§è·Ÿè¸ªç‰¹æ€§ã€‚ä½†åœ¨ä¸Šä¸€è®²çš„æ¡ˆä¾‹ä¸­ï¼Œä½ ä¹Ÿå‘ç° bpftrace å¹¶ä¸é€‚ç”¨äºæ‰€æœ‰çš„ eBPF åº”ç”¨ï¼Œå®ƒæœ¬èº«çš„é™åˆ¶å¯¼è‡´æˆ‘ä»¬æ— æ³•åœ¨éœ€è¦å¤æ‚ eBPF ç¨‹åºçš„åœºæ™¯ä¸­ä½¿ç”¨å®ƒã€‚åœ¨å¤æ‚çš„åº”ç”¨ä¸­ï¼Œæˆ‘è¿˜æ˜¯æ¨èä½ ä½¿ç”¨ BCC æˆ–è€… libbpf è¿›è¡Œå¼€å‘ã€‚

é‚£ä¹ˆï¼Œä»Šå¤©æˆ‘å°±å¸¦ä½ çœ‹çœ‹ï¼Œå¦‚ä½•ä½¿ç”¨ BCC å’Œ libbpf è¿™ä¸¤ä¸ªè¿›é˜¶æ–¹æ³•æ¥å¼€å‘å†…æ ¸è·Ÿè¸ªç¨‹åºã€‚

## **BCC æ–¹æ³•**

æˆ‘ä»¬å…ˆæ¥çœ‹çœ‹å¦‚ä½•ä½¿ç”¨ BCC æ¥å¼€å‘ä¸Šä¸€è®²ä¸­çŸ­æ—¶è¿›ç¨‹çš„è·Ÿè¸ªç¨‹åºã€‚è¿™é‡Œå…ˆè¯´æ˜ä¸‹ï¼Œç”±äºÂ execveatÂ çš„å¤„ç†é€»è¾‘åŒÂ execveÂ åŸºæœ¬ç›¸åŒï¼Œé™äºç¯‡å¹…çš„é•¿åº¦ï¼Œæ¥ä¸‹æ¥çš„ BCC å’Œ libbpf ç¨‹åºéƒ½ä»¥Â execveÂ ä¸ºä¾‹ã€‚

è¿™é‡Œæˆ‘ä»¬å…ˆå›é¡¾ä¸‹ [03è®²](https://time.geekbang.org/column/article/481090) çš„å†…å®¹ï¼Œä½¿ç”¨ BCC å¼€å‘çš„ eBPF ç¨‹åºåŒ…å«ä¸¤éƒ¨åˆ†ï¼š

- ç¬¬ä¸€éƒ¨åˆ†æ˜¯ç”¨ C è¯­è¨€å¼€å‘çš„ eBPF ç¨‹åºã€‚åœ¨ eBPF ç¨‹åºä¸­ï¼Œä½ å¯ä»¥åˆ©ç”¨ BCC æä¾›çš„[åº“å‡½æ•°å’Œå®å®šä¹‰](https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md)ç®€åŒ–ä½ çš„å¤„ç†é€»è¾‘ã€‚
- ç¬¬äºŒéƒ¨åˆ†æ˜¯ç”¨ Python è¯­è¨€å¼€å‘çš„å‰ç«¯ç•Œé¢ï¼Œå…¶ä¸­åŒ…å« eBPF ç¨‹åºåŠ è½½ã€æŒ‚è½½åˆ°å†…æ ¸å‡½æ•°å’Œè·Ÿè¸ªç‚¹ï¼Œä»¥åŠé€šè¿‡ BPF æ˜ å°„è·å–å’Œæ‰“å°æ‰§è¡Œç»“æœç­‰éƒ¨åˆ†ã€‚åœ¨å‰ç«¯ç¨‹åºä¸­ï¼Œä½ åŒæ ·å¯ä»¥åˆ©ç”¨ BCC åº“æ¥è®¿é—® BPF æ˜ å°„ã€‚

### **æ•°æ®ç»“æ„å®šä¹‰**

æˆ‘ä»¬å…ˆçœ‹ç¬¬ä¸€éƒ¨åˆ†ã€‚ä¸ºäº†åœ¨ç³»ç»Ÿè°ƒç”¨å…¥å£è·Ÿè¸ªç‚¹å’Œå‡ºå£è·Ÿè¸ªç‚¹é—´å…±äº«è¿›ç¨‹ä¿¡æ¯ç­‰æ•°æ®ï¼Œæˆ‘ä»¬å¯ä»¥å®šä¹‰ä¸€ä¸ªå“ˆå¸Œæ˜ å°„ï¼ˆæ¯”å¦‚å‘½åä¸ºÂ `tasks`ï¼‰ï¼›åŒæ ·åœ°ï¼Œå› ä¸ºæˆ‘ä»¬æƒ³è¦åœ¨ç”¨æˆ·ç©ºé—´å®æ—¶è·å–è·Ÿè¸ªä¿¡æ¯ï¼Œè¿™å°±éœ€è¦ä¸€ä¸ªæ€§èƒ½äº‹ä»¶æ˜ å°„ã€‚å¯¹äºè¿™ä¸¤ç§æ˜ å°„çš„åˆ›å»ºæ­¥éª¤ï¼ŒBCC å·²ç»æä¾›äº†éå¸¸æ–¹ä¾¿çš„å®å®šä¹‰ï¼Œä½ å¯ä»¥ç›´æ¥ä½¿ç”¨ã€‚

æ¯”å¦‚ï¼Œä½ å¯ä»¥ç”¨ä¸‹é¢çš„æ–¹å¼æ¥åˆ›å»ºè¿™ä¸¤ä¸ªæ˜ å°„ï¼š

```c++
struct data_t {
    u32 pid;
    char comm[TASK_COMM_LEN];
    int retval;
    unsigned int args_size;
    char argv[FULL_MAX_ARGS_ARR];
};
BPF_PERF_OUTPUT(events);
BPF_HASH(tasks, u32, struct data_t);
```

ä»£ç ä¸­æŒ‡ä»¤çš„å…·ä½“ä½œç”¨å¦‚ä¸‹ï¼š

- `struct data_t`Â å®šä¹‰äº†ä¸€ä¸ªåŒ…å«è¿›ç¨‹åŸºæœ¬ä¿¡æ¯çš„æ•°æ®ç»“æ„ï¼Œå®ƒå°†ç”¨åœ¨å“ˆå¸Œæ˜ å°„çš„å€¼ä¸­ï¼ˆå…¶ä¸­çš„å‚æ•°å¤§å°Â `args_size`Â ä¼šåœ¨è¯»å–å‚æ•°å†…å®¹çš„æ—¶å€™ç”¨åˆ°ï¼‰ï¼›
- `BPF_PERF_OUTPUT(events)`Â å®šä¹‰äº†ä¸€ä¸ªæ€§èƒ½äº‹ä»¶æ˜ å°„ï¼›
- `BPF_HASH(tasks, u32, struct data_t)`Â å®šä¹‰äº†ä¸€ä¸ªå“ˆå¸Œæ˜ å°„ï¼Œå…¶é”®ä¸º 32 ä½çš„è¿›ç¨‹ PIDï¼Œè€Œå€¼åˆ™æ˜¯è¿›ç¨‹åŸºæœ¬ä¿¡æ¯Â `data_t`ã€‚

ä¸¤ä¸ªæ˜ å°„å®šä¹‰å¥½ä¹‹åï¼Œæ¥ä¸‹æ¥å°±æ˜¯**å®šä¹‰è·Ÿè¸ªç‚¹çš„å¤„ç†å‡½æ•°**ã€‚åœ¨ BCC ä¸­ï¼Œä½ å¯ä»¥é€šè¿‡Â `TRACEPOINT_PROBE(category, event)`Â æ¥å®šä¹‰ä¸€ä¸ªè·Ÿè¸ªç‚¹å¤„ç†å‡½æ•°ã€‚BCC ä¼šå°†æ‰€æœ‰çš„å‚æ•°æ”¾å…¥Â `args`Â è¿™ä¸ªå˜é‡ä¸­ï¼Œè¿™æ ·ä½¿ç”¨Â `args-><å‚æ•°å>`Â å°±å¯ä»¥è®¿é—®è·Ÿè¸ªç‚¹çš„å‚æ•°å€¼ã€‚

å¯¹æˆ‘ä»¬è¦è·Ÿè¸ªçš„çŸ­æ—¶è¿›ç¨‹é—®é¢˜æ¥è¯´ï¼Œä¹Ÿå°±æ˜¯ä¸‹é¢è¿™ä¸¤ä¸ªè·Ÿè¸ªç‚¹ï¼š

```c++
// å®šä¹‰sys_enter_execveè·Ÿè¸ªç‚¹å¤„ç†å‡½æ•°.
TRACEPOINT_PROBE(syscalls, sys_enter_execve)
{
    //å¾…æ·»åŠ å¤„ç†é€»è¾‘
}

// å®šä¹‰sys_exit_execveè·Ÿè¸ªç‚¹å¤„ç†å‡½æ•°.
TRACEPOINT_PROBE(syscalls, sys_exit_execve)
{
    //å¾…æ·»åŠ å¤„ç†é€»è¾‘
}
```

### **å…¥å£è·Ÿè¸ªç‚¹å¤„ç†**

å¯¹äºå…¥å£è·Ÿè¸ªç‚¹Â `sys_enter_execve`Â çš„å¤„ç†ï¼Œè¿˜æ˜¯æŒ‰ç…§ä¸Šä¸€è®²ä¸­ bpftrace çš„é€»è¾‘ï¼Œå…ˆè·å–è¿›ç¨‹çš„ PIDã€è¿›ç¨‹åç§°å’Œå‚æ•°åˆ—è¡¨ä¹‹åï¼Œå†å­˜å…¥åˆšåˆšå®šä¹‰çš„å“ˆå¸Œæ˜ å°„ä¸­ã€‚

å…¶ä¸­ï¼Œè¿›ç¨‹ PID å’Œè¿›ç¨‹åç§°éƒ½æ¯”è¾ƒå®¹æ˜“è·å–ã€‚å¦‚ä¸‹é¢çš„ä»£ç æ‰€ç¤ºï¼Œä½ å¯ä»¥è°ƒç”¨Â `bpf_get_current_pid_tgid()`Â æŸ¥è¯¢è¿›ç¨‹ PIDï¼Œè°ƒç”¨Â `bpf_get_current_comm()`Â è¯»å–è¿›ç¨‹åç§°ï¼š

```c++
    // è·å–è¿›ç¨‹PIDå’Œè¿›ç¨‹åç§°
    struct data_t data = { };
    u32 pid = bpf_get_current_pid_tgid();  // å–ä½32ä½ä¸ºè¿›ç¨‹PID
    data.pid = pid;
    bpf_get_current_comm(&data.comm, sizeof(data.comm));
```

è€Œå‘½ä»¤è¡Œå‚æ•°çš„è·å–å°±æ²¡é‚£ä¹ˆå®¹æ˜“äº†ã€‚å› ä¸º BCC æŠŠæ‰€æœ‰å‚æ•°éƒ½æ”¾åˆ°äº†Â `args`Â ä¸­ï¼Œä½ å¯ä»¥ä½¿ç”¨Â `args->argv`Â æ¥è®¿é—®å‚æ•°åˆ—è¡¨ï¼š

```c++
const char **argv = (const char **)(args->argv);
```

æ³¨æ„ï¼Œ`argv`Â æ˜¯ä¸€ä¸ªç”¨æˆ·ç©ºé—´çš„å­—ç¬¦ä¸²æ•°ç»„ï¼ˆæŒ‡é’ˆæ•°ç»„ï¼‰ï¼Œè¿™å°±éœ€è¦è°ƒç”¨Â `bpf_probe_read`Â ç³»åˆ—çš„è¾…åŠ©å‡½æ•°ï¼Œå»è¿™äº›æŒ‡é’ˆä¸­è¯»å–æ•°æ®ã€‚å¹¶ä¸”ï¼Œå­—ç¬¦ä¸²çš„æ•°é‡ï¼ˆå³å‚æ•°çš„ä¸ªæ•°ï¼‰å’Œæ¯ä¸ªå­—ç¬¦ä¸²çš„é•¿åº¦ï¼ˆå³æ¯ä¸ªå‚æ•°çš„é•¿åº¦ï¼‰éƒ½æ˜¯æœªçŸ¥çš„ï¼Œç”±äº eBPF æ ˆå¤§å°åªæœ‰ 512 å­—èŠ‚ï¼Œå¦‚æœæƒ³è¦æŠŠå®ƒä»¬è¯»å…¥ä¸€ä¸ªä¸´æ—¶çš„å­—ç¬¦æ•°ç»„ä¸­ï¼Œå¿…é¡»è¦ä¿è¯æ¯æ¬¡è¯»å–çš„å†…å®¹ä¸è¶…è¿‡æ ˆçš„å¤§å°ã€‚è¿™ç±»é—®é¢˜æœ‰å¾ˆå¤šç§ä¸åŒçš„å¤„ç†æ–¹æ³•ï¼Œå…¶ä¸­ä¸€ä¸ªæ¯”è¾ƒç®€å•çš„æ–¹å¼å°±æ˜¯**æŠŠå¤šä½™çš„å‚æ•°æˆªæ–­ï¼Œä½¿ç”¨**`...`**ä»£æ›¿è¿‡é•¿çš„å‚æ•°ã€‚**ä¸€èˆ¬æ¥è¯´ï¼ŒçŸ¥é“äº†è¿›ç¨‹çš„åç§°å’Œå‰å‡ ä¸ªå‚æ•°ï¼Œå¯¹è°ƒè¯•å’Œæ’é”™æ¥è¯´å°±è¶³å¤Ÿäº†ã€‚

ä½ å¯ä»¥å®šä¹‰æœ€å¤§è¯»å–çš„å‚æ•°ä¸ªæ•°å’Œå‚æ•°é•¿åº¦ï¼Œç„¶ååœ¨å“ˆå¸Œæ˜ å°„çš„å€¼ä¸­å®šä¹‰ä¸€ä¸ªå­—ç¬¦æ•°ç»„ï¼Œä»£ç å¦‚ä¸‹æ‰€ç¤ºï¼š

```c++
// å®šä¹‰å‚æ•°é•¿åº¦å’Œå‚æ•°ä¸ªæ•°å¸¸é‡
#define ARGSIZE 64
#define TOTAL_MAX_ARGS 5
#define FULL_MAX_ARGS_ARR (TOTAL_MAX_ARGS * ARGSIZE)

struct data_t {
    ...
    char argv[FULL_MAX_ARGS_ARR];
};
```

æœ‰äº†å­—ç¬¦æ•°ç»„ï¼Œæ¥ä¸‹æ¥å†å®šä¹‰ä¸€ä¸ªè¾…åŠ©å‡½æ•°ï¼Œä»å‚æ•°æ•°ç»„ä¸­è¯»å–å­—ç¬¦ä¸²å‚æ•°ï¼ˆé™å®šæœ€é•¿Â `ARGSIZE`ï¼‰ï¼š

```c++
// ä»ç”¨æˆ·ç©ºé—´è¯»å–å­—ç¬¦ä¸²
static int __bpf_read_arg_str(struct data_t *data, const char *ptr)
{
    if (data->args_size > LAST_ARG) {
        return -1;
    }

    int ret = bpf_probe_read_user_str(&data->argv[data->args_size], ARGSIZE, (void *)ptr);
    if (ret > ARGSIZE || ret < 0) {
        return -1;
    }

    // increase the args size. the first tailing '\0' is not counted and hence it
    // would be overwritten by the next call.
    data->args_size += (ret - 1);

    return 0;
}
```

åœ¨è¿™ä¸ªå‡½æ•°ä¸­ï¼Œæœ‰å‡ ç‚¹éœ€è¦ä½ æ³¨æ„ï¼š

- `bpf_probe_read_user_str()`Â è¿”å›çš„æ˜¯åŒ…å«å­—ç¬¦ä¸²ç»“æŸç¬¦Â `\0`Â çš„é•¿åº¦ã€‚ä¸ºäº†æ‹¼æ¥æ‰€æœ‰çš„å­—ç¬¦ä¸²ï¼Œåœ¨è®¡ç®—å·²è¯»å–å‚æ•°é•¿åº¦çš„æ—¶å€™ï¼Œéœ€è¦æŠŠÂ `\0`Â æ’é™¤åœ¨å¤–ã€‚
- `&data->argv[data->args_size]`Â ç”¨æ¥è·å–è¦å­˜æ”¾å‚æ•°çš„ä½ç½®æŒ‡é’ˆï¼Œè¿™æ˜¯ä¸ºäº†æŠŠå¤šä¸ªå‚æ•°æ‹¼æ¥åˆ°ä¸€èµ·ã€‚
- åœ¨è°ƒç”¨Â `bpf_probe_read_user_str()`Â å‰åï¼Œéœ€è¦å¯¹æŒ‡é’ˆä½ç½®å’Œè¿”å›å€¼è¿›è¡Œæ ¡éªŒï¼Œè¿™å¯ä»¥å¸®åŠ© eBPF éªŒè¯å™¨è·å–æŒ‡é’ˆè¯»å†™çš„è¾¹ç•Œï¼ˆå¦‚æœä½ æ„Ÿå…´è¶£ï¼Œå¯ä»¥å‚è€ƒ[è¿™ç¯‡æ–‡ç« ](https://sysdig.com/blog/the-art-of-writing-ebpf-programs-a-primer)ï¼Œäº†è§£æ›´å¤šçš„å†…å­˜è®¿é—®éªŒè¯ç»†èŠ‚ï¼‰ã€‚

æœ‰äº†è¿™ä¸ªè¾…åŠ©å‡½æ•°ä¹‹åï¼Œå› ä¸º eBPF åœ¨è€ç‰ˆæœ¬å†…æ ¸ä¸­å¹¶ä¸æ”¯æŒå¾ªç¯ï¼ˆæœ‰ç•Œå¾ªç¯åœ¨ **5.3** ä¹‹åæ‰æ”¯æŒï¼‰ï¼Œè¦è®¿é—®å­—ç¬¦ä¸²æ•°ç»„ï¼Œè¿˜éœ€è¦ä¸€ä¸ªå°æŠ€å·§ï¼šä½¿ç”¨Â `#pragma unroll`Â å‘Šè¯‰ç¼–è¯‘å™¨ï¼ŒæŠŠæºç ä¸­çš„å¾ªç¯è‡ªåŠ¨å±•å¼€ã€‚è¿™å°±é¿å…äº†æœ€ç»ˆçš„å­—èŠ‚ç ä¸­åŒ…å«å¾ªç¯ã€‚

å®Œæ•´çš„å¤„ç†å‡½æ•°å¦‚ä¸‹æ‰€ç¤ºï¼ˆå…·ä½“çš„æ¯ä¸€æ­¥æˆ‘éƒ½åŠ äº†è¯¦ç»†çš„æ³¨é‡Šï¼Œä½ å¯ä»¥å‚è€ƒæ³¨é‡Šæ¥åŠ æ·±ç†è§£ï¼‰ï¼š

```c++
// å¼•å…¥å†…æ ¸å¤´æ–‡ä»¶
#include <uapi/linux/ptrace.h>
#include <linux/sched.h>
#include <linux/fs.h>

// å®šä¹‰sys_enter_execveè·Ÿè¸ªç‚¹å¤„ç†å‡½æ•°.
TRACEPOINT_PROBE(syscalls, sys_enter_execve)
{
    // å˜é‡å®šä¹‰
    unsigned int ret = 0;
    const char **argv = (const char **)(args->argv);

    // è·å–è¿›ç¨‹PIDå’Œè¿›ç¨‹åç§°
    struct data_t data = { };
    u32 pid = bpf_get_current_pid_tgid();
    data.pid = pid;
    bpf_get_current_comm(&data.comm, sizeof(data.comm));

    // è·å–ç¬¬ä¸€ä¸ªå‚æ•°ï¼ˆå³å¯æ‰§è¡Œæ–‡ä»¶çš„åå­—ï¼‰
    if (__bpf_read_arg_str(&data, (const char *)argv[0]) < 0) {
        goto out;
    }

    // è·å–å…¶ä»–å‚æ•°ï¼ˆé™å®šæœ€å¤š5ä¸ªï¼‰
    #pragma unrollfor (int i = 1; i < TOTAL_MAX_ARGS; i++) {
        if (__bpf_read_arg_str(&data, (const char *)argv[i]) < 0) {
            goto out;
        }
    }

 out:
    // å­˜å‚¨åˆ°å“ˆå¸Œæ˜ å°„ä¸­
    tasks.update(&pid, &data);
    return 0;
}
```

æ³¨æ„ï¼Œ**ä¸ºäº†è·å–å†…æ ¸æ•°æ®ç»“æ„çš„å®šä¹‰ï¼Œåœ¨æ–‡ä»¶çš„å¼€å¤´éœ€è¦å¼•å…¥ç›¸å…³çš„å†…æ ¸å¤´æ–‡ä»¶**ã€‚æ­¤å¤–ï¼Œè¯»å–å‚æ•°å®Œæˆä¹‹åï¼Œä¸è¦å¿˜è®°è°ƒç”¨Â `tasks.update()`Â æŠŠè¿›ç¨‹çš„åŸºæœ¬ä¿¡æ¯å­˜å‚¨åˆ°å“ˆå¸Œæ˜ å°„ä¸­ã€‚å› ä¸ºè¿”å›å€¼éœ€è¦ç­‰åˆ°å‡ºå£è·Ÿè¸ªç‚¹æ—¶æ‰å¯ä»¥è·å–ï¼Œè¿™å„¿åªéœ€è¦æ›´æ–°å“ˆå¸Œæ˜ å°„å°±å¯ä»¥äº†ï¼Œä¸éœ€è¦æŠŠè¿›ç¨‹ä¿¡æ¯æäº¤åˆ°æ€§èƒ½äº‹ä»¶æ˜ å°„ä¸­å»ã€‚

### **å‡ºå£è·Ÿè¸ªç‚¹å¤„ç†**

å…¥å£è·Ÿè¸ªç‚¹Â `sys_enter_execve`Â å¤„ç†å¥½ä¹‹åï¼Œæˆ‘ä»¬å†æ¥çœ‹çœ‹å‡ºå£è·Ÿè¸ªç‚¹Â `sys_exit_execve`Â è¯¥å¦‚ä½•å¤„ç†ã€‚

ç”±äºè¿›ç¨‹çš„åŸºæœ¬ä¿¡æ¯å·²ç»ä¿å­˜åœ¨äº†å“ˆå¸Œæ˜ å°„ä¸­ï¼Œæ‰€ä»¥å‡ºå£äº‹ä»¶çš„å¤„ç†å¯ä»¥åˆ†ä¸ºæŸ¥è¯¢è¿›ç¨‹åŸºæœ¬ä¿¡æ¯ã€å¡«å……è¿”å›å€¼ã€æœ€åå†æäº¤åˆ°æ€§èƒ½äº‹ä»¶æ˜ å°„è¿™ä¸‰ä¸ªæ­¥éª¤ã€‚å…·ä½“ä»£ç å¦‚ä¸‹æ‰€ç¤ºï¼š

```c++
// å®šä¹‰sys_exit_execveè·Ÿè¸ªç‚¹å¤„ç†å‡½æ•°.
TRACEPOINT_PROBE(syscalls, sys_exit_execve)
{
    // ä»å“ˆå¸Œæ˜ å°„ä¸­æŸ¥è¯¢è¿›ç¨‹åŸºæœ¬ä¿¡æ¯
    u32 pid = bpf_get_current_pid_tgid();
    struct data_t *data = tasks.lookup(&pid);

    // å¡«å……è¿”å›å€¼å¹¶æäº¤åˆ°æ€§èƒ½äº‹ä»¶æ˜ å°„ä¸­
    if (data != NULL) {
        data->retval = args->ret;
        events.perf_submit(args, data, sizeof(struct data_t));

        // æœ€åæ¸…ç†è¿›ç¨‹ä¿¡æ¯
        tasks.delete(&pid);
    }

    return 0;
}
```

åˆ°è¿™é‡Œï¼Œå®Œæ•´çš„ eBPF ç¨‹åºå°±å¼€å‘å¥½äº†ï¼Œä½ å¯ä»¥æŠŠä¸Šè¿°çš„ä»£ç ä¿å­˜åˆ°ä¸€ä¸ªæœ¬åœ°æ–‡ä»¶ä¸­ï¼Œå¹¶å‘½åä¸ºÂ `execsnoop.c`ï¼ˆä½ ä¹Ÿå¯ä»¥åœ¨Â [GitHub](https://github.com/feiskyer/ebpf-apps/blob/main/bcc-apps/python/execsnoop.c)Â ä¸Šæ‰¾åˆ°å…¨éƒ¨æºç ï¼‰ã€‚

### **Pythonå‰ç«¯å¤„ç†**

eBPF ç¨‹åºå¼€å‘å®Œæˆåï¼Œæœ€åä¸€æ­¥å°±æ˜¯ä¸ºå®ƒå¢åŠ ä¸€ä¸ª Python å‰ç«¯ã€‚

åŒ [03 è®²](https://time.geekbang.org/column/article/481090) çš„ Hello World ç±»ä¼¼ï¼Œ**Python å‰ç«¯é€»è¾‘éœ€è¦ eBPF ç¨‹åºåŠ è½½ã€æŒ‚è½½åˆ°å†…æ ¸å‡½æ•°å’Œè·Ÿè¸ªç‚¹ï¼Œä»¥åŠé€šè¿‡ BPF æ˜ å°„è·å–å’Œæ‰“å°æ‰§è¡Œç»“æœç­‰å‡ ä¸ªæ­¥éª¤**ã€‚å…¶ä¸­ï¼Œå› ä¸ºæˆ‘ä»¬å·²ç»ä½¿ç”¨äº†Â `TRACEPOINT_PROBE`Â å®å®šä¹‰ï¼Œæ¥å®šä¹‰ eBPF è·Ÿè¸ªç‚¹å¤„ç†å‡½æ•°ï¼ŒBCC åœ¨åŠ è½½å­—èŠ‚ç çš„æ—¶å€™ï¼Œä¼šå¸®ä½ è‡ªåŠ¨æŠŠå®ƒæŒ‚è½½åˆ°æ­£ç¡®çš„è·Ÿè¸ªç‚¹ä¸Šï¼Œæ‰€ä»¥æŒ‚è½½çš„æ­¥éª¤å°±å¯ä»¥å¿½ç•¥ã€‚å®Œæ•´çš„ Python ç¨‹åºå¦‚ä¸‹æ‰€ç¤ºï¼š

```python
# å¼•å…¥åº“å‡½æ•°
from bcc import BPF
from bcc.utils import printb

# 1) åŠ è½½eBPFä»£ç 
b = BPF(src_file="execsnoop.c")

# 2) è¾“å‡ºå¤´
print("%-6s %-16s %-3s %s" % ("PID", "COMM", "RET", "ARGS"))

# 3) å®šä¹‰æ€§èƒ½äº‹ä»¶æ‰“å°å‡½æ•°
def print_event(cpu, data, size):
    # BCCè‡ªåŠ¨æ ¹æ®"struct data_t"ç”Ÿæˆæ•°æ®ç»“æ„
    event = b["events"].event(data)
    printb(b"%-6d %-16s %-3d %-16s" % (event.pid, event.comm, event.retval, event.argv))

# 4) ç»‘å®šæ€§èƒ½äº‹ä»¶æ˜ å°„å’Œè¾“å‡ºå‡½æ•°ï¼Œå¹¶ä»æ˜ å°„ä¸­å¾ªç¯è¯»å–æ•°æ®
b["events"].open_perf_buffer(print_event)
while 1:
    try:
        b.perf_buffer_poll()
    except KeyboardInterrupt:
        exit()
```

æŠŠä¸Šè¿°çš„ä»£ç ä¿å­˜åˆ°Â `execsnoop.py`Â ä¸­ï¼Œç„¶åé€šè¿‡ Python è¿è¡Œï¼Œå¹¶åœ¨å¦ä¸€ä¸ªç»ˆç«¯ä¸­æ‰§è¡ŒÂ `ls`Â å‘½ä»¤ï¼Œä½ å°±å¯ä»¥å¾—åˆ°å¦‚ä¸‹çš„è¾“å‡ºï¼š

```bash
$ sudo python3 execsnoop.py
PID    COMM             RET ARGS
249134 zsh              0   ls--color=tty
```

æ­å–œï¼Œåˆ°è¿™é‡Œä½ å·²ç»å¼€å‘äº†ä¸€ä¸ªæ–°çš„ eBPF ç¨‹åºï¼Œå¹¶ä¸”å®ƒå¯ä»¥å¸®ä½ æ’æŸ¥çŸ­æ—¶è¿›ç¨‹ç›¸å…³çš„æ€§èƒ½é—®é¢˜ã€‚

ä¸è¿‡ï¼Œåœ¨ä½ æƒ³è¦åˆ†å‘è¿™ä¸ªç¨‹åºåˆ°ç”Ÿäº§ç¯å¢ƒæ—¶ï¼Œåˆä¼šç¢°åˆ°ä¸€ä¸ªæ–°çš„éš¾é¢˜ï¼šBCC ä¾èµ–äº LLVM å’Œå†…æ ¸å¤´æ–‡ä»¶æ‰å¯ä»¥åŠ¨æ€ç¼–è¯‘å’ŒåŠ è½½ eBPF ç¨‹åºï¼Œè€Œå‡ºäºå®‰å…¨ç­–ç•¥çš„éœ€è¦ï¼Œåœ¨ç”Ÿäº§ç¯å¢ƒä¸­é€šå¸¸åˆä¸å…è®¸å®‰è£…è¿™äº›å¼€å‘å·¥å…·ã€‚

è¿™ä¸ªéš¾é¢˜åº”è¯¥æ€ä¹ˆå…‹æœå‘¢ï¼Ÿä¸€ç§å¾ˆå®¹æ˜“æƒ³åˆ°çš„æ–¹æ³•æ˜¯æŠŠ BCC å’Œå¼€å‘å·¥å…·éƒ½å®‰è£…åˆ°å®¹å™¨ä¸­ï¼Œå®¹å™¨æœ¬èº«ä¸æä¾›å¯¹å¤–æœåŠ¡ï¼Œè¿™æ ·å¯ä»¥é™ä½å®‰å…¨é£é™©ã€‚å¦å¤–ä¸€ç§æ–¹æ³•å°±æ˜¯å‚è€ƒå†…æ ¸ä¸­çš„Â [eBPF ç¤ºä¾‹](https://elixir.bootlin.com/linux/v5.13/source/samples/bpf)ï¼Œå¼€å‘ä¸€ä¸ªåŒ¹é…å½“å‰å†…æ ¸ç‰ˆæœ¬çš„ eBPF ç¨‹åºï¼Œå¹¶ç¼–è¯‘ä¸ºå­—èŠ‚ç ï¼Œå†åˆ†å‘åˆ°ç”Ÿäº§ç¯å¢ƒä¸­ã€‚

é™¤æ­¤ä¹‹å¤–ï¼Œå¦‚æœä½ çš„å†…æ ¸å·²ç»æ”¯æŒäº† BPF ç±»å‹æ ¼å¼ (BTF)ï¼Œæˆ‘æ¨èä½ ä½¿ç”¨ä»å†…æ ¸æºç ä¸­æŠ½ç¦»å‡ºæ¥çš„ libbpf è¿›è¡Œå¼€å‘ï¼Œè¿™æ ·å¯ä»¥å€ŸåŠ© BTF å’Œ CO-RE è·å¾—æ›´å¥½çš„ç§»æ¤æ€§ã€‚å®é™…ä¸Šï¼ŒBCC çš„å¾ˆå¤šå·¥å…·éƒ½åœ¨å‘ BTF è¿ç§»ä¸­ï¼Œç›¸ä¿¡æœªæ¥ libbpf ä¼šæˆä¸ºæœ€å—æ¬¢è¿çš„ eBPF ç¨‹åºå¼€å‘åŸºç¡€åº“ï¼Œç”šè‡³ Windows eBPF ä¹Ÿä¼šæ”¯æŒ libbpfã€‚

## **libbpf æ–¹æ³•**

é‚£ä¹ˆï¼Œå¦‚ä½•ç”¨ libbpf æ¥å¼€å‘ä¸€ä¸ª eBPF ç¨‹åºå‘¢ï¼Ÿè·Ÿåˆšæ‰çš„ BCC ç¨‹åºç±»ä¼¼ï¼Œä½¿ç”¨ libbpf å¼€å‘ eBPF ç¨‹åºä¹Ÿæ˜¯åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼šç¬¬ä¸€ï¼Œå†…æ ¸æ€çš„ eBPF ç¨‹åºï¼›ç¬¬äºŒï¼Œç”¨æˆ·æ€çš„åŠ è½½ã€æŒ‚è½½ã€æ˜ å°„è¯»å–ä»¥åŠè¾“å‡ºç¨‹åºç­‰ã€‚

**åœ¨ eBPF ç¨‹åºä¸­ï¼Œç”±äºå†…æ ¸å·²ç»æ”¯æŒäº† BTFï¼Œä½ ä¸å†éœ€è¦å¼•å…¥ä¼—å¤šçš„å†…æ ¸å¤´æ–‡ä»¶æ¥è·å–å†…æ ¸æ•°æ®ç»“æ„çš„å®šä¹‰ã€‚**å–è€Œä»£ä¹‹çš„æ˜¯ä¸€ä¸ªé€šè¿‡ bpftool ç”Ÿæˆçš„Â  **`vmlinux.h`** Â å¤´æ–‡ä»¶ï¼Œå…¶ä¸­åŒ…å«äº†å†…æ ¸æ•°æ®ç»“æ„çš„å®šä¹‰ã€‚

è¿™æ ·ï¼Œä½¿ç”¨ libbpf å¼€å‘ eBPF ç¨‹åºå°±å¯ä»¥é€šè¿‡ä»¥ä¸‹å››ä¸ªæ­¥éª¤å®Œæˆï¼š

1. ä½¿ç”¨ bpftool ç”Ÿæˆå†…æ ¸æ•°æ®ç»“æ„å®šä¹‰å¤´æ–‡ä»¶ã€‚BTF å¼€å¯åï¼Œä½ å¯ä»¥åœ¨ç³»ç»Ÿä¸­æ‰¾åˆ°Â `/sys/kernel/btf/vmlinux`Â è¿™ä¸ªæ–‡ä»¶ï¼Œbpftool æ­£æ˜¯ä»å®ƒç”Ÿæˆäº†å†…æ ¸æ•°æ®ç»“æ„å¤´æ–‡ä»¶ã€‚
2. å¼€å‘ eBPF ç¨‹åºéƒ¨åˆ†ã€‚ä¸ºäº†æ–¹ä¾¿åç»­é€šè¿‡ç»Ÿä¸€çš„ Makefile ç¼–è¯‘ï¼ŒeBPF ç¨‹åºçš„æºç æ–‡ä»¶ä¸€èˆ¬å‘½åä¸ºÂ `<ç¨‹åºå>.bpf.c`ã€‚
3. ç¼–è¯‘ eBPF ç¨‹åºä¸ºå­—èŠ‚ç ï¼Œç„¶åå†è°ƒç”¨Â `bpftool gen skeleton`Â ä¸º eBPF å­—èŠ‚ç ç”Ÿæˆè„šæ‰‹æ¶å¤´æ–‡ä»¶ï¼ˆSkeleton Headerï¼‰ã€‚è¿™ä¸ªå¤´æ–‡ä»¶åŒ…å«äº† eBPF å­—èŠ‚ç ä»¥åŠç›¸å…³çš„åŠ è½½ã€æŒ‚è½½å’Œå¸è½½å‡½æ•°ï¼Œå¯åœ¨ç”¨æˆ·æ€ç¨‹åºä¸­ç›´æ¥è°ƒç”¨ã€‚
4. æœ€åå°±æ˜¯ç”¨æˆ·æ€ç¨‹åºå¼•å…¥ä¸Šä¸€æ­¥ç”Ÿæˆçš„å¤´æ–‡ä»¶ï¼Œå¼€å‘ç”¨æˆ·æ€ç¨‹åºï¼ŒåŒ…æ‹¬ eBPF ç¨‹åºåŠ è½½ã€æŒ‚è½½åˆ°å†…æ ¸å‡½æ•°å’Œè·Ÿè¸ªç‚¹ï¼Œä»¥åŠé€šè¿‡ BPF æ˜ å°„è·å–å’Œæ‰“å°æ‰§è¡Œç»“æœç­‰ã€‚

é€šå¸¸ï¼Œè¿™å‡ ä¸ªæ­¥éª¤é‡Œé¢çš„ç¼–è¯‘ã€åº“é“¾æ¥ã€æ‰§è¡ŒÂ `bpftool`Â å‘½ä»¤ç­‰ï¼Œéƒ½å¯ä»¥æ”¾åˆ° Makefile ä¸­ï¼Œè¿™æ ·å°±å¯ä»¥é€šè¿‡ä¸€ä¸ªÂ `make`Â å‘½ä»¤å»æ‰§è¡Œæ‰€æœ‰çš„æ­¥éª¤ã€‚æ¯”å¦‚ï¼Œä¸‹é¢æ˜¯ä¸€ä¸ªç®€åŒ–ç‰ˆæœ¬çš„ Makefileï¼š

```makefile
APPS = execsnoop

.PHONY: all
all: $(APPS)

$(APPS):
    clang -g -O2 -target bpf -D__TARGET_ARCH_x86_64 -I/usr/include/x86_64-linux-gnu -I. -c $@.bpf.c -o $@.bpf.o
    bpftool gen skeleton $@.bpf.o > $@.skel.h
    clang -g -O2 -Wall -I . -c $@.c -o $@.o
    clang -Wall -O2 -g $@.o -static -lbpf -lelf -lz -o $@

vmlinux:
    $(bpftool) btf dump file /sys/kernel/btf/vmlinux format c > vmlinux.h
```

æœ‰äº†è¿™ä¸ª Makefile ä¹‹åï¼Œä½ æ‰§è¡ŒÂ `make vmlinux`Â å‘½ä»¤å°±å¯ä»¥ç”ŸæˆÂ `vmlinux.h`Â æ–‡ä»¶ï¼Œå†æ‰§è¡ŒÂ `make`Â å°±å¯ä»¥ç¼–è¯‘Â `APPS`Â é‡Œé¢é…ç½®çš„æ‰€æœ‰ eBPF ç¨‹åºï¼ˆå¤šä¸ªç¨‹åºä¹‹é—´ä»¥ç©ºæ ¼åˆ†éš”ï¼‰ã€‚

æ¥ä¸‹æ¥ï¼Œæˆ‘å°±å¸¦ä½ ä¸€èµ·é€šè¿‡ä¸Šè¿°å››ä¸ªæ­¥éª¤å¼€å‘è·Ÿè¸ªçŸ­æ—¶è¿›ç¨‹çš„ eBPF ç¨‹åºã€‚

### **å†…æ ¸å¤´æ–‡ä»¶ç”Ÿæˆ**

é¦–å…ˆï¼Œå¯¹äºç¬¬ä¸€æ­¥ï¼Œæˆ‘ä»¬åªéœ€è¦æ‰§è¡Œä¸‹é¢çš„å‘½ä»¤ï¼Œå³å¯ç”Ÿæˆå†…æ ¸æ•°æ®ç»“æ„çš„å¤´æ–‡ä»¶ï¼š

```bash
sudo bpftool btf dump file /sys/kernel/btf/vmlinux format c > vmlinux.h
```

å¦‚æœå‘½ä»¤æ‰§è¡Œå¤±è´¥äº†ï¼Œå¹¶ä¸”é”™è¯¯è¯´ BTF ä¸å­˜åœ¨ï¼Œé‚£è¯´æ˜å½“å‰ç³»ç»Ÿå†…æ ¸æ²¡æœ‰å¼€å¯ BTF ç‰¹æ€§ã€‚è¿™æ—¶å€™ï¼Œä½ éœ€è¦å¼€å¯Â `CONFIG_DEBUG_INFO_BTF=y`Â å’ŒÂ `CONFIG_DEBUG_INFO=y`Â è¿™ä¸¤ä¸ªç¼–è¯‘é€‰é¡¹ï¼Œç„¶åé‡æ–°ç¼–è¯‘å’Œå®‰è£…å†…æ ¸ã€‚

### **eBPF ç¨‹åºå®šä¹‰**

ç¬¬äºŒæ­¥å°±æ˜¯å¼€å‘ eBPF ç¨‹åºï¼ŒåŒ…æ‹¬å®šä¹‰å“ˆå¸Œæ˜ å°„ã€æ€§èƒ½äº‹ä»¶æ˜ å°„ä»¥åŠè·Ÿè¸ªç‚¹çš„å¤„ç†å‡½æ•°ç­‰ï¼Œè€Œå¯¹è¿™äº›æ•°æ®ç»“æ„å’Œè·Ÿè¸ªå‡½æ•°çš„å®šä¹‰éƒ½å¯ä»¥é€šè¿‡Â `SEC()`Â å®å®šä¹‰æ¥å®Œæˆã€‚åœ¨ç¼–è¯‘æ—¶ï¼Œ**é€šè¿‡ `SEC()` å®å®šä¹‰çš„æ•°æ®ç»“æ„å’Œå‡½æ•°ä¼šæ”¾åˆ°ç‰¹å®šçš„ ELF æ®µä¸­ï¼Œè¿™æ ·åç»­åœ¨åŠ è½½ BPF å­—èŠ‚ç æ—¶ï¼Œå°±å¯ä»¥ä»è¿™äº›æ®µä¸­è·å–æ‰€éœ€çš„å…ƒæ•°æ®ã€‚**

æ¯”å¦‚ï¼Œä½ å¯ä»¥ä½¿ç”¨ä¸‹é¢çš„ä»£ç æ¥å®šä¹‰æ˜ å°„å’Œè·Ÿè¸ªç‚¹å¤„ç†å‡½æ•°ï¼š

```c++
// åŒ…å«å¤´æ–‡ä»¶
#include "vmlinux.h"
#include <bpf/bpf_helpers.h>

// å®šä¹‰è¿›ç¨‹åŸºæœ¬ä¿¡æ¯æ•°æ®ç»“æ„
struct event {
    char comm[TASK_COMM_LEN];
    pid_t pid;
    int retval;
    int args_count;
    unsigned int args_size;
    char args[FULL_MAX_ARGS_ARR];
};

// å®šä¹‰å“ˆå¸Œæ˜ å°„
struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 10240);
    __type(key, pid_t);
    __type(value, struct event);
} execs SEC(".maps");

// å®šä¹‰æ€§èƒ½äº‹ä»¶æ˜ å°„
struct {
    __uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);
    __uint(key_size, sizeof(u32));
    __uint(value_size, sizeof(u32));
} events SEC(".maps");

// sys_enter_execveè·Ÿè¸ªç‚¹
SEC("tracepoint/syscalls/sys_enter_execve")
int tracepoint__syscalls__sys_enter_execve(struct trace_event_raw_sys_enter *ctx)
{
  // å¾…å®ç°å¤„ç†é€»è¾‘
}

// sys_exit_execveè·Ÿè¸ªç‚¹
SEC("tracepoint/syscalls/sys_exit_execve")
int tracepoint__syscalls__sys_exit_execve(struct trace_event_raw_sys_exit *ctx)
{
  // å¾…å®ç°å¤„ç†é€»è¾‘
}

// å®šä¹‰è®¸å¯è¯ï¼ˆå‰è¿°çš„BCCé»˜è®¤ä½¿ç”¨GPLï¼‰
char LICENSE[] SEC("license") = "Dual BSD/GPL";
```

è®©æˆ‘ä»¬æ¥çœ‹çœ‹è¿™æ®µä»£ç çš„å…·ä½“å«ä¹‰ï¼š

- å¤´æ–‡ä»¶Â `vmlinux.h`Â åŒ…å«äº†å†…æ ¸æ•°æ®ç»“æ„ï¼Œè€ŒÂ `bpf/bpf_helpers.h`Â åŒ…å«äº† [05 è®²](https://time.geekbang.org/column/article/482459) æåˆ°çš„ BPF è¾…åŠ©å‡½æ•°ï¼›
- `struct event`Â å®šä¹‰äº†è¿›ç¨‹åŸºæœ¬ä¿¡æ¯æ•°æ®ç»“æ„ï¼Œå®ƒä¼šç”¨åœ¨åé¢çš„å“ˆå¸Œæ˜ å°„ä¸­ï¼›
- `SEC(".maps")`Â å®šä¹‰äº†å“ˆå¸Œæ˜ å°„å’Œæ€§èƒ½äº‹ä»¶æ˜ å°„ï¼›
- `SEC("tracepoint/<è·Ÿè¸ªç‚¹åç§°>")`Â å®šä¹‰äº†è·Ÿè¸ªç‚¹å¤„ç†å‡½æ•°ï¼Œç³»ç»Ÿè°ƒç”¨è·Ÿè¸ªç‚¹çš„æ ¼å¼æ˜¯Â `tracepoint/syscalls/<ç³»ç»Ÿè°ƒç”¨åç§°>"`ã€‚ä»¥åä½ éœ€è¦å®šä¹‰å†…æ ¸æ’æ¡©å’Œç”¨æˆ·æ’æ¡©çš„æ—¶å€™ï¼Œä¹Ÿæ˜¯ä»¥ç±»ä¼¼çš„æ ¼å¼å®šä¹‰ï¼Œæ¯”å¦‚Â `kprobe/do_unlinkat`Â æˆ–Â `uprobe/func`ï¼›
- æœ€åçš„Â `SEC("license")`Â å®šä¹‰äº† eBPF ç¨‹åºçš„è®¸å¯è¯ã€‚åœ¨ä¸Šè¿°çš„ BCC eBPF ç¨‹åºä¸­ï¼Œæˆ‘ä»¬å¹¶æ²¡æœ‰å®šä¹‰è®¸å¯è¯ï¼Œè¿™æ˜¯å› ä¸º BCC è‡ªåŠ¨å¸®ä½ ä½¿ç”¨äº† GPL è®¸å¯ã€‚

æœ‰äº†åŸºæœ¬çš„ç¨‹åºç»“æ„ï¼Œæ¥ä¸‹æ¥å°±æ˜¯**å®ç°ç³»ç»Ÿè°ƒç”¨å…¥å£å’Œå‡ºå£è·Ÿè¸ªç‚¹çš„å¤„ç†å‡½æ•°**ã€‚å®ƒä»¬çš„åŸºæœ¬è¿‡ç¨‹è·Ÿä¸Šè¿°çš„ BCC ç¨‹åºæ˜¯ç±»ä¼¼çš„ã€‚

### **å…¥å£è·Ÿè¸ªç‚¹å¤„ç†**

å¯¹äºå…¥å£è·Ÿè¸ªç‚¹Â `sys_enter_execve`Â çš„å¤„ç†ï¼Œè¿˜æ˜¯æŒ‰ç…§ä¸Šè¿° BCC ç¨‹åºçš„é€»è¾‘ï¼Œå…ˆè·å–è¿›ç¨‹çš„ PIDã€è¿›ç¨‹åç§°å’Œå‚æ•°åˆ—è¡¨ä¹‹åï¼Œå†å­˜å…¥åˆšåˆšå®šä¹‰çš„å“ˆå¸Œæ˜ å°„ä¸­ã€‚å®Œæ•´ä»£ç å¦‚ä¸‹æ‰€ç¤ºï¼Œå…·ä½“æ¯ä¸€æ­¥çš„å†…å®¹æˆ‘éƒ½åŠ äº†è¯¦ç»†çš„æ³¨é‡Šï¼š

```c++
SEC("tracepoint/syscalls/sys_enter_execve")
int tracepoint__syscalls__sys_enter_execve(struct trace_event_raw_sys_enter
                       *ctx)
{
    struct event *event;
    const char **args = (const char **)(ctx->args[1]);
    const char *argp;

    // æŸ¥è¯¢PID
    u64 id = bpf_get_current_pid_tgid();
    pid_t pid = (pid_t) id;

    // ä¿å­˜ä¸€ä¸ªç©ºçš„eventåˆ°å“ˆå¸Œæ˜ å°„ä¸­
    if (bpf_map_update_elem(&execs, &pid, &empty_event, BPF_NOEXIST)) {
        return 0;
    }
    event = bpf_map_lookup_elem(&execs, &pid);
    if (!event) {
        return 0;
    }

    // åˆå§‹åŒ–eventå˜é‡
    event->pid = pid;
    event->args_count = 0;
    event->args_size = 0;

    // æŸ¥è¯¢ç¬¬ä¸€ä¸ªå‚æ•°
    unsigned int ret = bpf_probe_read_user_str(event->args, ARGSIZE,
                           (const char *)ctx->args[0]);
    if (ret <= ARGSIZE) {
        event->args_size += ret;
    }

    // æŸ¥è¯¢å…¶ä»–å‚æ•°
    event->args_count++;
    #pragma unrollfor (int i = 1; i < TOTAL_MAX_ARGS; i++) {
        bpf_probe_read_user(&argp, sizeof(argp), &args[i]);
        if (!argp)
            return 0;

        if (event->args_size > LAST_ARG)
            return 0;

        ret =
            bpf_probe_read_user_str(&event->args[event->args_size],
                        ARGSIZE, argp);
        if (ret > ARGSIZE)
            return 0;

        event->args_count++;
        event->args_size += ret;
    }

    // å†å°è¯•ä¸€æ¬¡ï¼Œç¡®è®¤æ˜¯å¦è¿˜æœ‰æœªè¯»å–çš„å‚æ•°
    bpf_probe_read_user(&argp, sizeof(argp), &args[TOTAL_MAX_ARGS]);
    if (!argp)
        return 0;

    // å¦‚æœè¿˜æœ‰æœªè¯»å–å‚æ•°ï¼Œåˆ™å¢åŠ å‚æ•°æ•°é‡ï¼ˆç”¨äºè¾“å‡º"..."ï¼‰
    event->args_count++;

    return 0;
}
```

å…¶ä¸­ï¼Œä½ éœ€è¦æ³¨æ„è¿™ä¸‰ç‚¹ï¼š

- ç¬¬ä¸€ï¼Œç¨‹åºä½¿ç”¨äº†Â `bpf_probe_read_user()`Â æ¥æŸ¥è¯¢å‚æ•°ã€‚ç”±äºå®ƒæŠŠÂ `\0`Â ä¹Ÿç®—åˆ°äº†å·²è¯»å–å‚æ•°çš„é•¿åº¦é‡Œé¢ï¼Œæ‰€ä»¥æœ€ç»ˆÂ `event->args`Â ä¸­ä¿å­˜çš„å„ä¸ªå‚æ•°æ˜¯ä»¥Â `\0`Â åˆ†éš”çš„ã€‚åœ¨ç”¨æˆ·æ€ç¨‹åºè¾“å‡ºå‚æ•°ä¹‹å‰ï¼Œéœ€è¦ç”¨ç©ºæ ¼æ›¿æ¢Â `\0`ã€‚
- ç¬¬äºŒï¼Œç¨‹åºåœ¨ä¸€å¼€å§‹çš„æ—¶å€™å‘å“ˆå¸Œæ˜ å°„å­˜å…¥äº†ä¸€ä¸ªç©ºäº‹ä»¶ï¼Œåœ¨åç»­å‡ºå£è·Ÿè¸ªç‚¹å¤„ç†çš„æ—¶å€™éœ€è¦ç¡®ä¿ç©ºäº‹ä»¶ä¹Ÿèƒ½æ­£ç¡®æ¸…ç†ã€‚
- ç¬¬ä¸‰ï¼Œç¨‹åºåœ¨æœ€ååˆå°è¯•å¤šè¯»å–äº†ä¸€æ¬¡å‚æ•°åˆ—è¡¨ã€‚å¦‚æœè¿˜æœ‰æœªè¯»å–å‚æ•°ï¼Œå‚æ•°æ•°é‡å¢åŠ äº† 1ã€‚ç”¨æˆ·æ€ç¨‹åºå¯ä»¥æ ¹æ®å‚æ•°æ•°é‡æ¥å†³å®šæ˜¯ä¸æ˜¯éœ€è¦åœ¨å‚æ•°ç»“å°¾è¾“å‡ºä¸€ä¸ªÂ `...`ã€‚

### **å‡ºå£è·Ÿè¸ªç‚¹å¤„ç†**

å…¥å£è·Ÿè¸ªç‚¹å¤„ç†å¥½ä¹‹åï¼Œå†æ¥çœ‹çœ‹å‡ºå£è·Ÿè¸ªç‚¹çš„å¤„ç†æ–¹æ³•ã€‚å®ƒçš„æ­¥éª¤è·Ÿ BCC ç¨‹åºä¹Ÿæ˜¯ç±»ä¼¼çš„ï¼Œä¹Ÿæ˜¯æŸ¥è¯¢è¿›ç¨‹åŸºæœ¬ä¿¡æ¯ã€å¡«å……è¿”å›å€¼ã€æäº¤åˆ°æ€§èƒ½äº‹ä»¶æ˜ å°„è¿™ä¸‰ä¸ªæ­¥éª¤ã€‚

é™¤æ­¤ä¹‹å¤–ï¼Œç”±äºåˆšæ‰å…¥å£è·Ÿè¸ªç‚¹çš„å¤„ç†ä¸­æ²¡æœ‰è¯»å–è¿›ç¨‹åç§°ï¼Œæ‰€ä»¥åœ¨æäº¤æ€§èƒ½äº‹ä»¶ä¹‹å‰è¿˜éœ€è¦å…ˆæŸ¥è¯¢ä¸€ä¸‹è¿›ç¨‹åç§°ã€‚å®Œæ•´çš„ç¨‹åºå¦‚ä¸‹æ‰€ç¤ºï¼Œå…·ä½“æ¯ä¸€æ­¥çš„å†…å®¹æˆ‘ä¹ŸåŠ äº†è¯¦ç»†çš„æ³¨é‡Šï¼š

```c++
SEC("tracepoint/syscalls/sys_exit_execve")
int tracepoint__syscalls__sys_exit_execve(struct trace_event_raw_sys_exit *ctx)
{
    u64 id;
    pid_t pid;
    int ret;
    struct event *event;

    // ä»å“ˆå¸Œæ˜ å°„ä¸­æŸ¥è¯¢è¿›ç¨‹åŸºæœ¬ä¿¡æ¯
    id = bpf_get_current_pid_tgid();
    pid = (pid_t) id;
    event = bpf_map_lookup_elem(&execs, &pid);
    if (!event)
        return 0;

    // æ›´æ–°è¿”å›å€¼å’Œè¿›ç¨‹åç§°
    ret = ctx->ret;
    event->retval = ret;
    bpf_get_current_comm(&event->comm, sizeof(event->comm));

    // æäº¤æ€§èƒ½äº‹ä»¶
    size_t len = EVENT_SIZE(event);
    if (len <= sizeof(*event))
        bpf_perf_event_output(ctx, &events, BPF_F_CURRENT_CPU, event,
                      len);

    // æ¸…ç†å“ˆå¸Œæ˜ å°„
    bpf_map_delete_elem(&execs, &pid);
    return 0;
}
```

ä»è¿™äº›ä»£ç ä¸­ä½ å¯ä»¥çœ‹åˆ°ï¼Œå®ƒçš„å¤„ç†é€»è¾‘è·Ÿä¸Šè¿°çš„ BCC ç¨‹åºåŸºæœ¬ä¸Šæ˜¯ç›¸åŒçš„ã€‚ä¸è¿‡ï¼Œè¯¦ç»†å¯¹æ¯”ä¸€ä¸‹ï¼Œä½ ä¼šå‘ç°å®ƒä»¬ä¹‹é—´è¿˜æ˜¯æœ‰ä¸åŒçš„ï¼Œä¸åŒç‚¹ä¸»è¦åœ¨ä¸¤ä¸ªæ–¹é¢ï¼š

- ç¬¬ä¸€ï¼Œå‡½æ•°åçš„å®šä¹‰æ ¼å¼ä¸åŒã€‚BCC ç¨‹åºä½¿ç”¨çš„æ˜¯Â `TRACEPOINT_PROBE`Â å®ï¼Œè€Œ libbpf ç¨‹åºç”¨çš„åˆ™æ˜¯Â `SEC`Â å®ã€‚
- ç¬¬äºŒï¼Œæ˜ å°„çš„è®¿é—®æ–¹æ³•ä¸åŒã€‚BCC å°è£…äº†å¾ˆå¤šæ›´æ˜“ç”¨çš„æ˜ å°„è®¿é—®å‡½æ•°ï¼ˆå¦‚Â `tasks.lookup()`ï¼‰ï¼Œè€Œ libbpf ç¨‹åºåˆ™éœ€è¦è°ƒç”¨ [05 è®²](https://time.geekbang.org/column/article/482459) æåˆ°è¿‡çš„ BPF è¾…åŠ©å‡½æ•°ï¼ˆæ¯”å¦‚æŸ¥è¯¢è¦ä½¿ç”¨Â `bpf_map_lookup_elem()`ï¼‰ã€‚

åˆ°è¿™é‡Œï¼Œæ–°å»ºä¸€ä¸ªç›®å½•ï¼Œå¹¶æŠŠä¸Šè¿°ä»£ç å­˜å…¥Â `execsnoop.bpf.c`Â æ–‡ä»¶ä¸­ï¼ŒeBPF éƒ¨åˆ†çš„ä»£ç ä¹Ÿå°±å¼€å‘å¥½äº†ã€‚

### **ç¼–è¯‘å¹¶ç”Ÿæˆè„šæ‰‹æ¶å¤´æ–‡ä»¶**

æœ‰äº† eBPF ç¨‹åºï¼Œæ‰§è¡Œä¸‹é¢çš„å‘½ä»¤ï¼Œä½ å°±å¯ä»¥ä½¿ç”¨ clang å’Œ bpftool å°†å…¶ç¼–è¯‘æˆ BPF å­—èŠ‚ç ï¼Œç„¶åå†ç”Ÿæˆå…¶è„šæ‰‹æ¶å¤´æ–‡ä»¶Â `execsnoop.skel.h`Â ï¼ˆæ³¨æ„ï¼Œè„šæ‰‹æ¶å¤´æ–‡ä»¶çš„åå­—ä¸€èˆ¬å®šä¹‰ä¸ºÂ `<ç¨‹åºå>.skel.h`ï¼‰ï¼š

```bash
clang -g -O2 -target bpf -D__TARGET_ARCH_x86_64 -I/usr/include/x86_64-linux-gnu -I. -c execsnoop.bpf.c -o execsnoop.bpf.o
bpftool gen skeleton execsnoop.bpf.o > execsnoop.skel.h
```

å…¶ä¸­ï¼Œclang çš„å‚æ•°Â `-target bpf`Â è¡¨ç¤ºè¦ç”Ÿæˆ BPF å­—èŠ‚ç ï¼Œ`-D__TARGET_ARCH_x86_64`Â è¡¨ç¤ºç›®æ ‡çš„ä½“ç³»ç»“æ„æ˜¯ x86\_64ï¼Œè€ŒÂ `-I`Â åˆ™æ˜¯å¼•å…¥å¤´æ–‡ä»¶è·¯å¾„ã€‚

å‘½ä»¤æ‰§è¡Œåï¼Œè„šæ‰‹æ¶å¤´æ–‡ä»¶ä¼šæ”¾åˆ°Â `execsnoop.skel.h`Â ä¸­ï¼Œè¿™ä¸ªå¤´æ–‡ä»¶åŒ…å«äº† BPF å­—èŠ‚ç å’Œç›¸å…³çš„ç®¡ç†å‡½æ•°ã€‚å› è€Œï¼Œå½“ç”¨æˆ·æ€ç¨‹åºå¼•å…¥è¿™ä¸ªå¤´æ–‡ä»¶å¹¶ç¼–è¯‘ä¹‹åï¼Œåªéœ€è¦åˆ†å‘æœ€ç»ˆç”¨æˆ·æ€ç¨‹åºç”Ÿæˆçš„äºŒè¿›åˆ¶æ–‡ä»¶åˆ°ç”Ÿäº§ç¯å¢ƒå³å¯ï¼ˆå¦‚æœç”¨æˆ·æ€ç¨‹åºä½¿ç”¨äº†å…¶ä»–çš„åŠ¨æ€åº“ï¼Œè¿˜éœ€è¦åˆ†å‘åŠ¨æ€åº“ï¼‰ã€‚

### **å¼€å‘ç”¨æˆ·æ€ç¨‹åº**

æœ‰äº†è„šæ‰‹æ¶å¤´æ–‡ä»¶ä¹‹åï¼Œè¿˜å‰©ä¸‹æœ€åä¸€æ­¥ï¼Œä¹Ÿå°±æ˜¯ç”¨æˆ·æ€ç¨‹åºçš„å¼€å‘ã€‚

åŒ BCC çš„ Python å‰ç«¯ç¨‹åºç±»ä¼¼ï¼Œlibbpf ç”¨æˆ·æ€ç¨‹åºä¹Ÿéœ€è¦ eBPF ç¨‹åºåŠ è½½ã€æŒ‚è½½åˆ°è·Ÿè¸ªç‚¹ï¼Œä»¥åŠé€šè¿‡ BPF æ˜ å°„è·å–å’Œæ‰“å°æ‰§è¡Œç»“æœç­‰å‡ ä¸ªæ­¥éª¤ã€‚è™½ç„¶ C è¯­è¨€å¬èµ·æ¥å¯èƒ½æ¯” Python è¯­è¨€éº»çƒ¦ä¸€äº›ï¼Œä½†å®é™…ä¸Šï¼Œè¿™å‡ ä¸ªæ­¥éª¤éƒ½å¯ä»¥é€šè¿‡è„šæ‰‹æ¶å¤´æ–‡ä»¶ä¸­è‡ªåŠ¨ç”Ÿæˆçš„å‡½æ•°æ¥å®Œæˆã€‚

ä¸‹é¢æ˜¯å¿½ç•¥äº†é”™è¯¯å¤„ç†é€»è¾‘ä¹‹åï¼Œç”¨æˆ·æ€ç¨‹åºçš„ä¸€ä¸ªåŸºæœ¬æ¡†æ¶ï¼š

```c++
// å¼•å…¥è„šæ‰‹æ¶å¤´æ–‡ä»¶
#include "execsnoop.skel.h"

// Cè¯­è¨€ä¸»å‡½æ•°
int main(int argc, char **argv)
{
    // å®šä¹‰BPFç¨‹åºå’Œæ€§èƒ½äº‹ä»¶ç¼“å†²åŒº
    struct execsnoop_bpf *skel;
    struct perf_buffer_opts pb_opts;
    struct perf_buffer *pb = NULL;
    int err;

    // 1. è®¾ç½®è°ƒè¯•è¾“å‡ºå‡½æ•°
    libbpf_set_print(libbpf_print_fn);

    // 2. å¢å¤§ RLIMIT_MEMLOCKï¼ˆé»˜è®¤å€¼é€šå¸¸å¤ªå°ï¼Œä¸è¶³ä»¥å­˜å…¥BPFæ˜ å°„çš„å†…å®¹ï¼‰
    bump_memlock_rlimit();

    // 3. åˆå§‹åŒ–BPFç¨‹åº
    skel = execsnoop_bpf__open();

    // 4. åŠ è½½BPFå­—èŠ‚ç 
    err = execsnoop_bpf__load(skel);

    // 5. æŒ‚è½½BPFå­—èŠ‚ç åˆ°è·Ÿè¸ªç‚¹
    err = execsnoop_bpf__attach(skel);

    // 6. é…ç½®æ€§èƒ½äº‹ä»¶å›è°ƒå‡½æ•°
    pb_opts.sample_cb = handle_event;
    pb = perf_buffer__new(bpf_map__fd(skel->maps.events), 64, &pb_opts);

    // 7. ä»ç¼“å†²åŒºä¸­å¾ªç¯è¯»å–æ•°æ®
    while ((err = perf_buffer__poll(pb, 100)) >= 0) ;
}
```

å…¶ä¸­ï¼Œ`execsnoop_`Â å¼€å¤´çš„æ•°æ®ç»“æ„å’Œå‡½æ•°éƒ½åŒ…å«åœ¨è„šæ‰‹æ¶å¤´æ–‡ä»¶Â `execsnoop.skel.h`Â ä¸­ã€‚è€Œå…·ä½“åˆ°æ¯ä¸€æ­¥çš„å«ä¹‰å¦‚ä¸‹ï¼š

- ç¬¬ 1 æ­¥çš„è°ƒè¯•è¾“å‡ºå‡½æ•°ä¸­ï¼Œå¯ä»¥è°ƒç”¨Â `printf()`Â æŠŠè°ƒè¯•ä¿¡æ¯è¾“å‡ºåˆ°ç»ˆç«¯ä¸­ã€‚
- ç¬¬ 2 æ­¥å¢å¤§é”å®šå†…å­˜é™åˆ¶Â `RLIMIT_MEMLOCK`Â æ˜¯å¿…è¦çš„ï¼Œå› ä¸ºç³»ç»Ÿé»˜è®¤çš„é”å®šå†…å­˜é€šå¸¸è¿‡å°ï¼Œæ— æ³•æ»¡è¶³ BPF æ˜ å°„çš„éœ€è¦ã€‚
- ç¬¬ 3~5 æ­¥ï¼Œç›´æ¥è°ƒç”¨è„šæ‰‹æ¶å¤´æ–‡ä»¶ä¸­çš„å‡½æ•°ï¼ŒåŠ è½½ BPF å­—èŠ‚ç å¹¶æŒ‚è½½åˆ°è·Ÿè¸ªç‚¹ã€‚
- ç¬¬ 6~7 æ­¥ä¸ºæ€§èƒ½äº‹ä»¶è®¾ç½®å›è°ƒå‡½æ•°ï¼Œå¹¶ä»ç¼“å†²åŒºä¸­å¾ªç¯è¯»å–æ•°æ®ã€‚æ³¨æ„ï¼Œæ€§èƒ½äº‹ä»¶æ˜ å°„Â `skel->maps.events`Â ä¹Ÿæ˜¯ bpftool è‡ªåŠ¨å¸®ä½ ç”Ÿæˆå¥½çš„ã€‚

æ¥ä¸‹æ¥ï¼Œåœ¨æ€§èƒ½äº‹ä»¶å›è°ƒå‡½æ•°ä¸­ï¼ŒæŠŠæ•°æ®æ ¼å¼è½¬æ¢ä¸ºÂ `struct event`Â æ ¼å¼ä¹‹åï¼Œç”±äºå‚æ•°åˆ—è¡¨æ˜¯ä½¿ç”¨Â `\0`Â æ¥åˆ†å‰²çš„ï¼Œå¹¶ä¸èƒ½ç›´æ¥å‘ç»ˆç«¯æ‰“å°æ‰€æœ‰å‚æ•°ã€‚æ‰€ä»¥ï¼Œè¿˜éœ€è¦æŠŠÂ `\0`Â å…ˆæ›¿æ¢ä¸ºç©ºæ ¼ï¼Œç„¶åå†æ‰“å°ã€‚å®Œæ•´çš„å›è°ƒå‡½æ•°å¦‚ä¸‹æ‰€ç¤ºï¼š

```c++
// æ€§èƒ½äº‹ä»¶å›è°ƒå‡½æ•°(å‘ç»ˆç«¯ä¸­æ‰“å°è¿›ç¨‹åã€PIDã€è¿”å›å€¼ä»¥åŠå‚æ•°)
void handle_event(void *ctx, int cpu, void *data, __u32 data_sz)
{
    const struct event *e = data;
    printf("%-16s %-6d %3d ", e->comm, e->pid, e->retval);
    print_args(e);
    putchar('\n');
}

// æ‰“å°å‚æ•°ï¼ˆæ›¿æ¢'\0'ä¸ºç©ºæ ¼ï¼‰
static void print_args(const struct event *e)
{
    int args_counter = 0;

    for (int i = 0; i < e->args_size && args_counter < e->args_count; i++) {
        char c = e->args[i];
        if (c == '\0') {
            // æŠŠ'\0'æ›¿æ¢ä¸ºç©ºæ ¼
            args_counter++;
            putchar(' ');
        } else {
            putchar(c);
        }
    }
    if (e->args_count > TOTAL_MAX_ARGS) {
        // è¿‡é•¿çš„å‚æ•°è¾“å‡º"..."æ›¿ä»£
        fputs(" ...", stdout);
    }
}
```

æŠŠä¸Šé¢çš„ä»£ç ä¿å­˜åˆ°Â `execsnoop.c`Â æ–‡ä»¶ä¸­ï¼ˆä½ ä¹Ÿå¯ä»¥åœ¨Â [GitHub](https://github.com/feiskyer/ebpf-apps/blob/main/bpf-apps/execsnoop.c)Â ä¸Šæ‰¾åˆ°å®Œæ•´çš„ä»£ç ï¼‰ï¼Œç„¶åæ‰§è¡Œä¸‹é¢çš„å‘½ä»¤ï¼Œå°†å…¶ç¼–è¯‘ä¸ºå¯æ‰§è¡Œæ–‡ä»¶ï¼š

```bash
clang -g -O2 -Wall -I . -c execsnoop.c -o execsnoop.o
clang -Wall -O2 -g execsnoop.o -static -lbpf -lelf -lz -o execsnoop
```

æœ€åï¼Œæ‰§è¡ŒÂ `execsnoop`ï¼Œä½ å°±å¯ä»¥å¾—åˆ°å¦‚ä¸‹çš„ç»“æœï¼š

```bash
$ sudo ./execsnoop
COMM             PID    RET ARGS
sh               276871   0 /bin/sh -c which ps
which            276872   0 /usr/bin/which ps
```

ä½ è¿˜å¯ä»¥ç›´æ¥æŠŠè¿™ä¸ªæ–‡ä»¶å¤åˆ¶åˆ°å¼€å¯äº† BTF çš„å…¶ä»–æœºå™¨ä¸­ï¼Œæ— éœ€å®‰è£…é¢å¤–çš„ LLVM å¼€å‘å·¥å…·å’Œå†…æ ¸å¤´æ–‡ä»¶ï¼Œä¹Ÿå¯ä»¥ç›´æ¥æ‰§è¡Œã€‚

å¦‚æœå‘½ä»¤å¤±è´¥ï¼Œå¹¶ä¸”ä½ çœ‹åˆ°å¦‚ä¸‹çš„é”™è¯¯ï¼Œè¿™è¯´æ˜å½“å‰æœºå™¨æ²¡æœ‰å¼€å¯ BTFï¼Œéœ€è¦é‡æ–°ç¼–è¯‘å†…æ ¸å¼€å¯ BTF æ‰å¯ä»¥è¿è¡Œï¼š

```plain
Failed to load and verify BPF skeleton
```

æ­å–œï¼ŒåŠ ä¸Šä¸Šä¸€è®²çš„å†…å®¹ï¼Œåˆ°è¿™é‡Œä½ å°±é€šè¿‡ bpftraceã€BCC å’Œ libbpf è¿™ä¸‰ç§æ–¹æ³•ï¼Œå®ç°äº†çŸ­æ—¶è¿›ç¨‹çš„è·Ÿè¸ªã€‚è™½ç„¶è¿™ä¸‰ç§æ–¹æ³•çš„æ­¥éª¤å’Œå®ç°ä»£ç å„ä¸ç›¸åŒï¼Œä½†å®é™…ä¸Šå®ƒä»¬çš„å®ç°é€»è¾‘éƒ½æ˜¯ç±»ä¼¼çš„ï¼Œæ— éå°±æ˜¯**æ‰¾å‡ºè·Ÿè¸ªç‚¹ï¼Œç„¶ååœ¨ eBPF éƒ¨åˆ†è·å–æƒ³è¦çš„æ•°æ®å¹¶ä¿å­˜åˆ° BPF æ˜ å°„ä¸­ï¼Œæœ€ååœ¨ç”¨æˆ·ç©ºé—´ç¨‹åºä¸­è¯»å– BPF æ˜ å°„çš„å†…å®¹å¹¶è¾“å‡ºå‡ºæ¥**ã€‚

## **å°ç»“**

ä»Šå¤©ï¼Œæˆ‘ä»¥çŸ­æ—¶è¿›ç¨‹çš„è·Ÿè¸ªä¸ºä¾‹ï¼Œé€šè¿‡ BCC å’Œ libbpf è¿™ä¸¤ç§æ–¹æ³•å®ç°äº†çŸ­æ—¶è¿›ç¨‹çš„è·Ÿè¸ªç¨‹åºï¼ˆä½ å¯ä»¥åœ¨ GitHub çš„[è¿™ä¸ªé“¾æ¥](https://github.com/feiskyer/ebpf-apps)ä¸­ï¼Œæ‰¾åˆ°ä»Šå¤©çš„æ¡ˆä¾‹ä¸­æåˆ°çš„æ‰€æœ‰æºç ï¼‰ã€‚åŠ ä¸Šä¸Šä¸€è®²ä»‹ç»çš„ bpftrace æ–¹æ³•ï¼Œæˆ‘å·²ç»å¸¦ä½ æŒæ¡äº†ç›®å‰æœ€å¸¸ç”¨çš„ä¸‰ç§ eBPF ç¨‹åºå¼€å‘æ–¹æ³•ï¼Œåœ¨è¿™é‡Œæˆ‘ä¸€èµ·æ€»ç»“ä¸‹ã€‚

åœ¨å®é™…çš„åº”ç”¨ä¸­ï¼Œè¿™ä¸‰ç§æ–¹æ³•æœ‰ä¸åŒçš„ä½¿ç”¨åœºæ™¯ï¼š

- bpftrace é€šå¸¸ç”¨åœ¨**å¿«é€Ÿæ’æŸ¥å’Œå®šä½ç³»ç»Ÿ**ä¸Šï¼Œå®ƒæ”¯æŒç”¨å•è¡Œè„šæœ¬çš„æ–¹å¼æ¥å¿«é€Ÿå¼€å‘å¹¶æ‰§è¡Œä¸€ä¸ª eBPF ç¨‹åºï¼›
- BCC é€šå¸¸ç”¨åœ¨**å¼€å‘å¤æ‚çš„ eBPF ç¨‹åº**ä¸­ï¼Œå®ƒå†…ç½®çš„å„ç§å°å·¥å…·ä¹Ÿæ˜¯ç›®å‰åº”ç”¨æœ€ä¸ºå¹¿æ³›çš„ eBPF å°ç¨‹åºï¼›
- libbpf æ˜¯**ä»å†…æ ¸ä¸­æŠ½ç¦»å‡ºæ¥çš„æ ‡å‡†åº“**ï¼Œç”¨å®ƒå¼€å‘çš„ eBPF ç¨‹åºå¯ä»¥ç›´æ¥åˆ†å‘æ‰§è¡Œï¼Œä¸å†éœ€è¦åœ¨æ¯å°æœºå™¨ä¸Šéƒ½å®‰è£… LLVM å’Œå†…æ ¸å¤´æ–‡ä»¶ã€‚

é€šå¸¸æƒ…å†µä¸‹ï¼Œä½ å¯ä»¥ç”¨ bpftrace æˆ– BCC åšä¸€äº›å¿«é€ŸåŸå‹ï¼ŒéªŒè¯ä½ çš„è®¾è®¡æ€è·¯æ˜¯ä¸æ˜¯å¯è¡Œï¼Œç„¶åå†åˆ‡æ¢åˆ° libbpf ï¼Œå¼€å‘å®Œå–„çš„ eBPF ç¨‹åºåå†å»åˆ†å‘æ‰§è¡Œã€‚è¿™æ ·ï¼Œä¸ä»… eBPF ç¨‹åºè¿è¡Œå¾—æ›´å¿«ï¼ˆæ— éœ€ç¼–è¯‘æ­¥éª¤ï¼‰ï¼Œè¿˜é¿å…äº†åœ¨è¿è¡Œç¯å¢ƒä¸­å®‰è£…å¼€å‘å·¥å…·å’Œå†…æ ¸å¤´æ–‡ä»¶ã€‚

åœ¨ä¸æ”¯æŒ BTF çš„æœºå™¨ä¸­ï¼Œå¦‚æœä¸æƒ³åœ¨è¿è¡Œ eBPF æ—¶ä¾èµ–äº LLVM ç¼–è¯‘å’Œå†…æ ¸å¤´æ–‡ä»¶ï¼Œä½ è¿˜å¯ä»¥å‚è€ƒå†…æ ¸ä¸­çš„Â [BPF ç¤ºä¾‹](https://elixir.bootlin.com/linux/v5.13/source/samples/bpf)ï¼Œç›´æ¥å¼•ç”¨å†…æ ¸æºç ä¸­çš„Â `tools/lib/bpf/`Â åº“ï¼Œä»¥åŠå†…æ ¸å¤´æ–‡ä»¶ä¸­çš„æ•°æ®ç»“æ„ï¼Œæ¥å¼€å‘ eBPF ç¨‹åºã€‚

## **æ€è€ƒé¢˜**

ä»Šå¤©ä½¿ç”¨ BCC å’Œ libbpf å¼€å‘çš„ eBPF ç¨‹åºè™½ç„¶å¯ä»¥æ­£å¸¸è¿è¡Œï¼Œä½†æ˜¯æˆ‘ç›¸ä¿¡ç»†å¿ƒçš„ä½ ä¸€å®šå‘ç°äº†ï¼Œå®ƒè¿˜æœ‰ä¸å°‘å°é—®é¢˜ï¼Œæ¯”å¦‚ï¼š

- å•ä¸ªå‚æ•°è¿‡é•¿ï¼Œæˆ–è€…æ€»çš„å‚æ•°æ•°é‡æ¯”è¾ƒå¤šæ—¶ï¼Œéƒ½ä¼šè¢«æˆªæ–­ï¼Œæ²¡æ³•å®Œæ•´æ˜¾ç¤ºæ‰€æœ‰çš„å‚æ•°åˆ—è¡¨ï¼›
- åœ¨è°ƒè¯•çŸ­æ—¶è¿›ç¨‹é—®é¢˜æ—¶ï¼Œå¾ˆå¤šæƒ…å†µä¸‹æˆ‘ä»¬å¯èƒ½è¿˜éœ€è¦çˆ¶è¿›ç¨‹çš„ä¿¡æ¯ï¼Œè¿™æ ·æ‰èƒ½æ›´å¿«å®šä½å®ƒä»¬éƒ½æ˜¯è¢«å“ªäº›è¿›ç¨‹åˆ›å»ºå‡ºæ¥çš„ã€‚

å­¦ä¹ å®Œæœ€è¿‘è¿™ä¸¤è®²çš„å†…å®¹ï¼Œä½ è§‰å¾—è¯¥å¦‚ä½•è§£å†³è¿™äº›é—®é¢˜å‘¢ï¼Ÿä½ å¯ä»¥åœ¨Â [execsnoop](https://github.com/feiskyer/ebpf-apps/blob/main/bcc-apps/python/execsnoop.c)Â çš„åŸºç¡€ä¸Šæ”¹è¿›ï¼Œå¼€å‘ä¸€ä¸ªæ›´å®Œå–„çš„ eBPF ç¨‹åºå—ï¼Ÿæ¬¢è¿åœ¨è¯„è®ºåŒºå’Œæˆ‘åˆ†äº«ä½ çš„æ€è·¯å’Œè§£å†³æ–¹æ³•ã€‚

æœŸå¾…ä½ åœ¨ç•™è¨€åŒºå’Œæˆ‘è®¨è®ºï¼Œä¹Ÿæ¬¢è¿æŠŠè¿™èŠ‚è¯¾åˆ†äº«ç»™ä½ çš„åŒäº‹ã€æœ‹å‹ã€‚è®©æˆ‘ä»¬ä¸€èµ·åœ¨å®æˆ˜ä¸­æ¼”ç»ƒï¼Œåœ¨äº¤æµä¸­è¿›æ­¥ã€‚
<div><strong>ç²¾é€‰ç•™è¨€ï¼ˆ15ï¼‰</strong></div><ul>
<li><span>è«å</span> ğŸ‘ï¼ˆ12ï¼‰ ğŸ’¬ï¼ˆ3ï¼‰<p>1ã€å¯¹äºå‚æ•°é—®é¢˜ï¼Œå½“å‰ BPF ç¨‹åºå°è¯•æŠŠæ‰€æœ‰å‚æ•°ä¸€æ¬¡æ€§æ”¾å…¥ï¼Œå—é™äºæ ˆæœ€å¤§é•¿åº¦ 512ï¼Œå¾ˆå®¹æ˜“å‡ºç°è¢«æˆªæ–­ç°è±¡ã€‚ä»¥ BCC ç¨‹åºä¸ºä¾‹çš„è§£å†³æ–¹æ³•ï¼šéå†å‚æ•°åˆ—è¡¨ argv æ—¶ï¼Œæ¯ä¸ªå‚æ•°è¯»å–ä¹‹åç›´æ¥è°ƒç”¨ perf_submit æäº¤è‡³ ringbufï¼Œè€Œä¸æ˜¯è¯»å–æ‰€æœ‰å‚æ•°åä»…æäº¤ä¸€æ¬¡ï¼Œæœ€åç”¨æˆ·æ€ç¨‹åºè´Ÿè´£æŠŠè¿™äº›å­—ç¬¦ä¸²æ‹¼æ¥èµ·æ¥ã€‚è¿™æ ·å¯ä»¥åšåˆ°å‚æ•°æœ€å¤§ä¸ªæ•°ä¸å—é™åˆ¶ï¼Œä¸”æ¯ä¸ªå‚æ•°é•¿åº¦å¯æ¥è¿‘æ ˆæœ€å¤§é•¿åº¦ 512ï¼ˆå½“å‰ BPF ç¨‹åºé™åˆ¶ 64 å®¹æ˜“è¢«æˆªæ–­ï¼‰ã€‚

å¦ä¸€ä¸ªè§£å†³æ–¹å¼åº”è¯¥å¯ä»¥é‡‡ç”¨ perf-cpu array æ˜ å°„ç±»å‹ï¼Œé¿å…å ç”¨æœ‰é™çš„æ ˆç©ºé—´ï¼Œå…·ä½“æ²¡å°è¯•è¿‡ã€‚

2ã€ä»¥ BCC ç¨‹åºä¸ºä¾‹è·å–çˆ¶è¿›ç¨‹ï¼Œstruct data_t å¢åŠ  ppid å­—æ®µï¼Œç„¶åç”± task-&gt;real_parent-&gt;tgid èµ‹å€¼ã€‚

struct task_struct *task;

task = (struct task_struct *)bpf_get_current_task();
data.ppid = task-&gt;real_parent-&gt;tgid;</p>2022-02-02</li><br/><li><span>piboye</span> ğŸ‘ï¼ˆ1ï¼‰ ğŸ’¬ï¼ˆ4ï¼‰<p>golang + libbpf æ˜¯ä¸æ˜¯æ¯”BCC æ–¹æ¡ˆæ›´å¥½ï¼Ÿ</p>2022-03-15</li><br/><li><span>ä¸äº†å³°</span> ğŸ‘ï¼ˆ1ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>è¯·æ•™ä¸€ä¸‹æ–‡ç« ä¸­å…³äº ã€Œlibbpf æ–¹æ³•ã€
ä¸ºä»€ä¹ˆ æ–‡ç« ä¸­æ²¡æœ‰æåŠ  execsnoop.h  è¿™ä¸ªæ–‡ä»¶ã€‚ã€‚
è€Œ  execsnoop.bpf.c è¦ #include &quot;execsnoop.h&quot;  è¿™ä¸ªæ–‡ä»¶ ï¼Ÿ
 å…³äº  execsnoop.h  æ–‡ä»¶å†…å®¹ç”Ÿæˆï¼Œæ˜¯ä¸æ˜¯åœ¨å‰é¢çš„å‡ ç« æœ‰æ¶‰åŠï¼Ÿ</p>2022-02-21</li><br/><li><span>å†™ç‚¹å•¥å‘¢</span> ğŸ‘ï¼ˆ1ï¼‰ ğŸ’¬ï¼ˆ3ï¼‰<p>è¯·æ•™ä¸‹è€å¸ˆï¼š
1. bpfçš„è¾…åŠ©å‡½æ•°æ‰§è¡Œä¸Šä¸‹æ–‡æ˜¯åœ¨å½“å‰è¿›ç¨‹ä¸‹ä¹ˆï¼Œå› ä¸ºæˆ‘çœ‹åƒexecsnoopä¾‹å­ä¸­get_current_pid_tgidè°ƒç”¨èƒ½æ‹¿åˆ°çš„æ˜¯æ–°å¯åŠ¨è¿›ç¨‹pidã€‚
2. libbpfçš„å¼€å‘æ¨¡å¼èƒ½çœ‹åˆ°ä»ç¼–è¯‘å™¨åˆ°bpfåœ¨èƒŒååšäº†å¾ˆå¤šå·¥ä½œï¼Œå¦‚æœæƒ³äº†è§£bpfç¨‹åºçš„å®ç°ï¼Œæ¯”å¦‚å®æ˜¯å¦‚ä½•å®šä¹‰äº†æ˜ å°„å’ŒæŒ‚è½½ç‚¹ï¼Œç¨‹åºåŠ è½½çš„æ—¶å€™å¦‚ä½•ä»ç¨‹åºæ®µä¸­çš„ä¿¡æ¯å®ç°çš„æ˜ å°„åˆ›å»ºå’ŒæŒ‚è½½ï¼Œè€å¸ˆèƒ½å¦ç»™æŒ‡ä¸€ä¸ªå­¦ä¹ è·¯å¾„ï¼Ÿè°¢è°¢å•¦</p>2022-02-03</li><br/><li><span>é¾è¦</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ2ï¼‰<p>æœ€æ–°çš„ä»£ç  https:&#47;&#47;github.com&#47;feiskyer&#47;ebpf-apps&#47;tree&#47;b89ae0f
æ‰§è¡Œ make å‡ºé”™ï¼Œè¿™æ˜¯ gcc-toolset å¯¼è‡´å—ï¼Ÿè€å¸ˆï¼Œå„ä½åŒ
å­¦æ˜¯å¦é‡åˆ°è¿‡ï¼Ÿ

```
[root@Rocky-9 bpf-apps]# make
clang -g -O2 -target bpf -D__TARGET_ARCH_x86 -Ilibbpf&#47;usr&#47;include -I..&#47;libbpf&#47;include&#47;uapi -I&#47;usr&#47;include&#47;x86_64-linux-gnu -I. -c hello.bpf.c -o hello.bpf.o
&#47;usr&#47;sbin&#47;bpftool gen skeleton hello.bpf.o &gt; hello.skel.h
clang -g -O2 -Wall -Ilibbpf&#47;usr&#47;include -I..&#47;libbpf&#47;include&#47;uapi -I&#47;usr&#47;include&#47;x86_64-linux-gnu -I. -c hello.c -o hello.o
clang -Wall -O2 -g hello.o -static &#47;root&#47;ebpf-apps&#47;bpf-apps&#47;libbpf&#47;libbpf.a -lelf -lz -o hello
&#47;usr&#47;bin&#47;ld: cannot find -lelf
&#47;usr&#47;bin&#47;ld: cannot find -lz
&#47;usr&#47;bin&#47;ld: cannot find -lc
clang-14: error: linker command failed with exit code 1 (use -v to see invocation)
make: *** [Makefile:14: hello] Error 1
[root@Rocky-9 bpf-apps]#
[root@Rocky-9 bpf-apps]# clang -v
clang version 14.0.6 (Red Hat 14.0.6-4.el9_1)
Target: x86_64-redhat-linux-gnu
Thread model: posix
InstalledDir: &#47;usr&#47;bin
Found candidate GCC installation: &#47;opt&#47;rh&#47;gcc-toolset-12&#47;root&#47;usr&#47;lib&#47;gcc&#47;x86_64-redhat-linux&#47;12
Selected GCC installation: &#47;opt&#47;rh&#47;gcc-toolset-12&#47;root&#47;usr&#47;lib&#47;gcc&#47;x86_64-redhat-linux&#47;12
Candidate multilib: .;@m64
Candidate multilib: 32;@m32
Selected multilib: .;@m64
```</p>2023-02-21</li><br/><li><span>ä»è¿œæ–¹è¿‡æ¥</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ2ï¼‰<p>è€å¸ˆï¼Œæˆ‘è¿è¡Œä¸‹é¢çš„ä»£ç ï¼Œåœ¨å¦å¤–ä¸€ä¸ªshellä¸Šé¢æ‰§è¡Œchmodå‘½ä»¤ï¼Œä½†æ˜¯bccå´æ²¡æœ‰è¾“å‡ºï¼Œè¯·é—®è¿™ä¸ªæ˜¯ä»€ä¹ˆåŸå› ?

å†…æ ¸ç‰ˆæœ¬ï¼š 4.14.15-1.el7.elrepo.x86_64
æ“ä½œç³»ç»Ÿï¼š CentOS Linux release 7.9.2009 (Core)
bccç‰ˆæœ¬ï¼šbcc-0.21.0-1.el7.x86_64
               bcc-tools-0.21.0-1.el7.x86_64
               python-bcc-0.21.0-1.el7.noarch


#!&#47;usr&#47;bin&#47;env python3
# Tracing execve() system call.
from bcc import BPF
from bcc.utils import printb


chmod_prog = &quot;&quot;&quot;
&#47;* Tracing execve system call. *&#47;
#include &lt;uapi&#47;linux&#47;ptrace.h&gt;
#include &lt;linux&#47;sched.h&gt;
#include &lt;linux&#47;fs.h&gt;


&#47;&#47; perf event map (sharing data to userspace) and hash map (sharing data between tracepoints)
struct data_t {
	u32 pid;
	umode_t mode;
	char * filename;
};
BPF_PERF_OUTPUT(events);  &#47;&#47; ç”Ÿæˆä¸€ä¸ªeventäº‹ä»¶
&#47;&#47; BPF_HASH(tasks, u32, struct data_t);


&#47;&#47; sys_enter_chmod tracepoint.
TRACEPOINT_PROBE(syscalls, sys_enter_chmod)
{


	struct data_t data = {};
	u32 pid = bpf_get_current_pid_tgid();
	umode_t mode = args-&gt;mode;
	char * filename = (char *)args-&gt;filename;
	data.pid = pid ;
	data.mode = mode; 
	data.filename = filename;

	events.perf_submit(args, &amp;data, sizeof(data)); 
	return 0;
}


&quot;&quot;&quot;

# 1) load BPF program
b = BPF(text=chmod_prog)
# b = BPF(src_file=&quot;chmod.c&quot;)

# 2) print header
print(&quot;%-6s %-16s %-3s %s&quot; % (&quot;PID&quot;, &quot;COMM&quot;, &quot;RET&quot;, &quot;ARGS&quot;))


# 3) define the callback for perf event
def print_event(cpu, data, size):
    # event data struct is generated from &quot;struct data_t&quot; by bcc
    event = b[&quot;events&quot;].event(data)
    printb(b&quot;%-6d %-16s %-3d&quot; % (event.pid, event.mode, event.filename))


# 4) loop with callback to print_event
b[&quot;events&quot;].open_perf_buffer(print_event)
while 1:
    try:
        b.perf_buffer_poll()
    except KeyboardInterrupt:
        exit()





</p>2022-03-17</li><br/><li><span>heyhd9475</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>è€å¸ˆä½ å¥½ï¼Œæˆ‘æƒ³è¯·é—®ä¸ºä»€ä¹ˆæ¯æ¬¡ä½¿ç”¨bpf_probe_read_user_str()è¯»å–åä¸åœ¨æ¯æ¬¡è¯»å–åˆ°çš„å‚æ•°ä¸­é—´åŠ ä¸Šä¸€ä¸ªç©ºæ ¼å‘¢ï¼Œæˆ‘è¿™è¾¹å°è¯•åŠ è¿™ä¸ªç©ºæ ¼ï¼Œä¸ºä»€ä¹ˆä¼šæç¤ºå¦‚ä¸‹çš„æ— æ•ˆæ— é™åˆ¶å¯å˜åç§»é‡æ ˆå†™å…¥å‘¢ï¼š
invalid unbounded variable-offset write to stack R2

æŠ¥é”™çš„æºç ä¸º: data.args[data.next_arg_index-1]=&#39; &#39;;
æ˜¯å› ä¸ºbccè®¤ä¸ºå‚æ•°data.next_arg_indexæ˜¯æ²¡æœ‰é™åˆ¶èŒƒå›´çš„ï¼Œä¸å®‰å…¨çš„å—ã€‚</p>2022-02-19</li><br/><li><span>hjydxy</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>è€å¸ˆå¥½ï¼š
       åœ¨è¿™ä¸ªÂ execsnoop.skel.hÂ æ–‡ä»¶ä¸­ï¼Œæœ‰ä¸€ä¸ªâ€œexecsnoop_bpf__loadâ€å‡½æ•°ï¼Œä½ åœ¨è¯´æ˜ä¸­ä¹Ÿè¯´äº†è¿™ä¸ªå‡½æ•°æ˜¯åŠ è½½ebpfç¨‹åºç”¨çš„ï¼Œæˆ‘æƒ³è¯·æ•™ä¸‹è¿™ä¸ªå‡½æ•°å’Œ&#47;samples&#47;bpf&#47;ä¸‹ä¾‹å­ä¸­ä½¿ç”¨çš„â€œbpf_object__loadâ€æœ‰ä»€ä¹ˆåŒºåˆ«å’Œè”ç³»ï¼Œæˆ‘çš„ç†è§£æ˜¯è¿™ä¸¤ä¸ªå‡½æ•°çš„ä½œç”¨å·®ä¸å¤šï¼Œéƒ½æ˜¯åŠ è½½ebpfç¨‹åºç”¨çš„ï¼Œæ—¢ç„¶å¦‚æ­¤ï¼Œä½¿ç”¨â€œexecsnoop_bpf__loadâ€çš„æ„ä¹‰æˆ–è€…å¥½å¤„åœ¨å“ªé‡Œï¼Ÿè°¢è°¢ã€‚</p>2022-02-16</li><br/><li><span>c1</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ2ï¼‰<p>è¯·æ•™ï¼š
Ubuntu 21.10
Linux u21 5.13.0-28-generic #31-Ubuntu SMP Thu Jan 13 17:41:06 UTC 2022 x86_64 x86_64 x86_64 GNU&#47;Linux

æ‰§è¡Œexecsnoop.pyæŠ¥é”™ï¼š
...
&#47;virtual&#47;main.c:47:42: error: incomplete definition of type &#39;struct tracepoint__syscalls__sys_enter_execve&#39;
        const char **argv = (const char **)(args-&gt;argv);
...
&#47;virtual&#47;main.c:82:22: error: incomplete definition of type &#39;struct tracepoint__syscalls__sys_exit_execve&#39;
                data-&gt;retval = args-&gt;ret;
...</p>2022-02-09</li><br/><li><span>Haric</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>æ–‡ç« æåˆ°ï¼Œä½¿ç”¨libbfpæ–¹å¼åœ¨å¼€å¯äº† BTF çš„å…¶ä»–æœºå™¨éƒ½å¯ä»¥è¿è¡Œï¼Œè¯·é—®åœ¨åµŒå…¥å¼è®¾å¤‡ï¼ˆéœ€è¦äº¤å‰ç¼–è¯‘ï¼‰èƒ½è¿è¡Œå—ï¼Ÿ</p>2022-02-03</li><br/><li><span>CaptainZhao</span> ğŸ‘ï¼ˆ2ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>æ‚¨å¥½ï¼Œæˆ‘æœ€è¿‘å°è¯•ç”¨iovisor&#47;gobpfå†™golangçš„bccç¨‹åºï¼Œç”¨bccçš„runqlatæ”¹æˆäº†ç”¨æˆ·æ€æ˜¯golangçš„å®ç°ï¼Œè€ƒè™‘é•¿æ—¶é—´è·‘å¯èƒ½ä¼šå¯¹cfsæ€§èƒ½æœ‰å½±å“ï¼Œäºæ˜¯å°è¯•å†™æˆæ¯15ç§’å¼€å§‹é‡‡é›†ï¼Œç„¶åè·‘100æ¯«ç§’å…³é—­çš„æ–¹å¼ã€‚å¤§æ¦‚æ˜¯bcc.NewModule -&gt; load -&gt; attach -&gt; module.Close()ï¼Œä½†æ˜¯å‘ç°å†…å­˜æŒç»­åœ°ä¸Šæ¶¨ï¼Œç”¨pprofçœ‹äº†ä¸€ä¸‹ç¡®å®šä¸æ˜¯golangçš„å†…å­˜åœ¨ä¸Šæ¶¨ï¼Œç”¨memleakçœ‹äº†ä¸€ä¸‹å¥½åƒæ˜¯NewModuleç¼–è¯‘é˜¶æ®µllvm&#47;clangå¾ˆå¤šå†…å­˜æ²¡é‡Šæ”¾ï¼Œè¿™ä¸ªé—®é¢˜è¯¥æ€ä¹ˆè§£å†³å‘¢ï¼Ÿ</p>2022-04-12</li><br/><li><span>å¼ ä¸‰</span> ğŸ‘ï¼ˆ1ï¼‰ ğŸ’¬ï¼ˆ2ï¼‰<p>è¯·é—®trace_event_raw_sys_enterï¼Œtrace_event_raw_sys_exitè¿™ä¸¤ä¸ªå…¥å‚æ˜¯ç”±ä»€ä¹ˆå†³å®šçš„ï¼Ÿçœ‹åˆ°å…¶å®ƒåœ°æ–¹æœ‰void *çš„å…¥å‚ï¼Œä¹Ÿæœ‰å…¶å®ƒå…¥å‚</p>2023-08-13</li><br/><li><span>è¿›å‡»çš„Lancelot</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>There are two ways to nail down the argument. 
The first one is to base your `vmlinux.h`. Generally, `sys_enter_xx` corresponds to `trace_event_raw_sys_enter`, `sys_exit_xx` corresponds to `trace_event_raw_sys_exit`.  And if not found, you can try the other way. 

The second way is to create your own data structure. There are three steps:
1. confirm the format of arguments (sudo cat &#47;sys&#47;kernel&#47;debug&#47;tracing&#47;event&#47;syscalls&#47;sys_enter_exceve&#47;format)
2. create your own parameter structure, like:
```C
struct sys_enter_execve_args {
    char _[16];
    const char *filename;      &#47;&#47; offset:16
    const char *const *argv;   &#47;&#47; offset:24
    const char *const *envp;   &#47;&#47; offset:32
};
```
3. Implement your handler function
```C
SEC(&quot;tracepoint&#47;syscalls&#47;sys_enter_execve&quot;)
int tracepoint__syscalls__sys_enter_execve(struct sys_enter_execve_args *ctx) {
    struct event *event;
    const char **args = (const char **)(ctx-&gt;argv);
    const char *argp;
    
    &#47;&#47; omit some code ...
  
    &#47;&#47; query the first argument - filename
    unsigned int ret = bpf_probe_read_user_str(event-&gt;args, ARGSIZE, ctx-&gt;filename);
    
    &#47;&#47; omit some code ...
    for(int i = 1; i &lt; TOTAL_MAX_ARGS; ++i) {
       ...
    }
    ...
    return 0;
}
```</p>2024-12-26</li><br/><li><span>æ·±æ¸…ç§‹</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>åœ¨é«˜ç‰ˆæœ¬ubuntu 6.8.0-40-genericä¸‹ï¼Œè¿™ä¸ªå‘½ä»¤ä¼šæŠ¥é”™ï¼šclang -Wall -O2 -g execsnoop.o -static -lbpf -lelf -lz -o execsnoop

æŠ¥é”™ä¿¡æ¯å¦‚ä¸‹ï¼š
&#47;usr&#47;bin&#47;ld: &#47;lib&#47;x86_64-linux-gnu&#47;libelf.a(elf_compress.o): in function `__libelf_compress&#39;:
(.text+0x113): undefined reference to `ZSTD_createCCtx&#39;
&#47;usr&#47;bin&#47;ld: (.text+0x2a9): undefined reference to `ZSTD_compressStream2&#39;
&#47;usr&#47;bin&#47;ld: (.text+0x2b4): undefined reference to `ZSTD_isError&#39;
&#47;usr&#47;bin&#47;ld: (.text+0x2db): undefined reference to `ZSTD_freeCCtx&#39;
&#47;usr&#47;bin&#47;ld: (.text+0x5a0): undefined reference to `ZSTD_compressStream2&#39;
&#47;usr&#47;bin&#47;ld: (.text+0x5ab): undefined reference to `ZSTD_isError&#39;
&#47;usr&#47;bin&#47;ld: (.text+0x6b9): undefined reference to `ZSTD_freeCCtx&#39;
&#47;usr&#47;bin&#47;ld: (.text+0x835): undefined reference to `ZSTD_freeCCtx&#39;
&#47;usr&#47;bin&#47;ld: (.text+0x86f): undefined reference to `ZSTD_freeCCtx&#39;
&#47;usr&#47;bin&#47;ld: (.text+0x91b): undefined reference to `ZSTD_freeCCtx&#39;
&#47;usr&#47;bin&#47;ld: (.text+0xa12): undefined reference to `ZSTD_freeCCtx&#39;
&#47;usr&#47;bin&#47;ld: &#47;lib&#47;x86_64-linux-gnu&#47;libelf.a(elf_compress.o): in function `__libelf_decompress&#39;:
(.text+0xbfc): undefined reference to `ZSTD_decompress&#39;
&#47;usr&#47;bin&#47;ld: (.text+0xc04): undefined reference to `ZSTD_isError&#39;
&#47;usr&#47;bin&#47;ld: &#47;lib&#47;x86_64-linux-gnu&#47;libelf.a(elf_compress.o): in function `__libelf_decompress_elf&#39;:
(.text+0xd45): undefined reference to `ZSTD_decompress&#39;
&#47;usr&#47;bin&#47;ld: (.text+0xd4d): undefined reference to `ZSTD_isError&#39;

å»ºè®®å»æ‰ -static ç¼–è¯‘é€‰é¡¹å³å¯ï¼š clang -Wall -O2 -g execsnoop.o -lbpf -lelf -lz -o execsnoop
</p>2024-10-07</li><br/><li><span>å››äº”åˆå</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>è€å¸ˆï¼Œæ‚¨å¥½ æˆ‘é‡åˆ°å¦‚ä¸‹é”™è¯¯ï¼›
root@VM-16-8-ubuntu:&#47;home&#47;ubuntu&#47;code&#47;execsnoop# bpftool gen skeleton execsnoop_example.bpf.o &gt; execsnoop_example.skel.h
libbpf: elf: execsnoop_example_bpf is not a valid eBPF object file
Error: failed to open BPF object file: BPF object format invalid

root@VM-16-8-ubuntu:&#47;home&#47;ubuntu&#47;code&#47;execsnoop# uname -r
5.15.0-91-generic

root@VM-16-8-ubuntu:&#47;home&#47;ubuntu&#47;code&#47;execsnoop# bpftool -V
&#47;usr&#47;lib&#47;linux-tools&#47;5.15.0-91-generic&#47;bpftool v5.15.131
features:
root@VM-16-8-ubuntu:&#47;home&#47;ubuntu&#47;code&#47;execsnoop# clang -v
Ubuntu clang version 14.0.0-1ubuntu1.1
Target: x86_64-pc-linux-gnu
Thread model: posix
InstalledDir: &#47;usr&#47;bin
Found candidate GCC installation: &#47;usr&#47;bin&#47;..&#47;lib&#47;gcc&#47;x86_64-linux-gnu&#47;11
Selected GCC installation: &#47;usr&#47;bin&#47;..&#47;lib&#47;gcc&#47;x86_64-linux-gnu&#47;11
Candidate multilib: .;@m64
Selected multilib: .;@m64

</p>2024-03-23</li><br/>
</ul>