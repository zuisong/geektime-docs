ä¸Šä¸€èŠ‚ï¼Œæˆ‘ä»¬è®²äº†qemuå¯åŠ¨è¿‡ç¨‹ä¸­çš„å­˜å‚¨è™šæ‹ŸåŒ–ã€‚å¥½äº†ï¼Œç°åœ¨qemuå¯åŠ¨äº†ï¼Œç¡¬ç›˜è®¾å¤‡æ–‡ä»¶å·²ç»æ‰“å¼€äº†ã€‚é‚£å¦‚æœæˆ‘ä»¬è¦å¾€è™šæ‹Ÿæœºçš„ä¸€ä¸ªè¿›ç¨‹å†™å…¥ä¸€ä¸ªæ–‡ä»¶ï¼Œè¯¥æ€ä¹ˆåšå‘¢ï¼Ÿæœ€ç»ˆè¿™ä¸ªæ–‡ä»¶åˆæ˜¯å¦‚ä½•è½åˆ°å®¿ä¸»æœºä¸Šçš„ç¡¬ç›˜æ–‡ä»¶çš„å‘¢ï¼Ÿè¿™ä¸€èŠ‚ï¼Œæˆ‘ä»¬ä¸€èµ·æ¥çœ‹ä¸€çœ‹ã€‚

## å‰ç«¯è®¾å¤‡é©±åŠ¨virtio\_blk

è™šæ‹Ÿæœºé‡Œé¢çš„è¿›ç¨‹å†™å…¥ä¸€ä¸ªæ–‡ä»¶ï¼Œå½“ç„¶è¦é€šè¿‡æ–‡ä»¶ç³»ç»Ÿã€‚æ•´ä¸ªè¿‡ç¨‹å’Œå’±ä»¬åœ¨[æ–‡ä»¶ç³»ç»Ÿ](https://time.geekbang.org/column/article/97876)é‚£ä¸€èŠ‚è®²çš„è¿‡ç¨‹æ²¡æœ‰åŒºåˆ«ã€‚åªæ˜¯åˆ°äº†è®¾å¤‡é©±åŠ¨å±‚ï¼Œæˆ‘ä»¬çœ‹åˆ°çš„å°±ä¸æ˜¯æ™®é€šçš„ç¡¬ç›˜é©±åŠ¨äº†ï¼Œè€Œæ˜¯virtioçš„é©±åŠ¨ã€‚

virtioçš„é©±åŠ¨ç¨‹åºä»£ç åœ¨Linuxæ“ä½œç³»ç»Ÿçš„æºä»£ç é‡Œé¢ï¼Œæ–‡ä»¶åå«drivers/block/virtio\_blk.cã€‚

```
static int __init init(void)
{
	int error;
	virtblk_wq = alloc_workqueue("virtio-blk", 0, 0);
	major = register_blkdev(0, "virtblk");
	error = register_virtio_driver(&virtio_blk);
......
}

module_init(init);
module_exit(fini);

MODULE_DEVICE_TABLE(virtio, id_table);
MODULE_DESCRIPTION("Virtio block driver");
MODULE_LICENSE("GPL");

static struct virtio_driver virtio_blk = {
......
	.driver.name			= KBUILD_MODNAME,
	.driver.owner			= THIS_MODULE,
	.id_table			= id_table,
	.probe				= virtblk_probe,
	.remove				= virtblk_remove,
......
};
```

å‰é¢æˆ‘ä»¬ä»‹ç»è¿‡è®¾å¤‡é©±åŠ¨ç¨‹åºï¼Œä»è¿™é‡Œçš„ä»£ç ä¸­ï¼Œæˆ‘ä»¬èƒ½çœ‹åˆ°éå¸¸ç†Ÿæ‚‰çš„ç»“æ„ã€‚å®ƒä¼šåˆ›å»ºä¸€ä¸ªworkqueueï¼Œæ³¨å†Œä¸€ä¸ªå—è®¾å¤‡ï¼Œå¹¶è·å¾—ä¸€ä¸ªä¸»è®¾å¤‡å·ï¼Œç„¶åæ³¨å†Œä¸€ä¸ªé©±åŠ¨å‡½æ•°virtio\_blkã€‚

å½“ä¸€ä¸ªè®¾å¤‡é©±åŠ¨ä½œä¸ºä¸€ä¸ªå†…æ ¸æ¨¡å—è¢«åˆå§‹åŒ–çš„æ—¶å€™ï¼Œprobeå‡½æ•°ä¼šè¢«è°ƒç”¨ï¼Œå› è€Œæˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹virtblk\_probeã€‚

```
static int virtblk_probe(struct virtio_device *vdev)
{
	struct virtio_blk *vblk;
	struct request_queue *q;
......
	vdev->priv = vblk = kmalloc(sizeof(*vblk), GFP_KERNEL);
	vblk->vdev = vdev;
	vblk->sg_elems = sg_elems;
	INIT_WORK(&vblk->config_work, virtblk_config_changed_work);
......
	err = init_vq(vblk);
......
	vblk->disk = alloc_disk(1 << PART_BITS);
	memset(&vblk->tag_set, 0, sizeof(vblk->tag_set));
	vblk->tag_set.ops = &virtio_mq_ops;
	vblk->tag_set.queue_depth = virtblk_queue_depth;
	vblk->tag_set.numa_node = NUMA_NO_NODE;
	vblk->tag_set.flags = BLK_MQ_F_SHOULD_MERGE;
	vblk->tag_set.cmd_size =
		sizeof(struct virtblk_req) +
		sizeof(struct scatterlist) * sg_elems;
	vblk->tag_set.driver_data = vblk;
	vblk->tag_set.nr_hw_queues = vblk->num_vqs;
	err = blk_mq_alloc_tag_set(&vblk->tag_set);
......
	q = blk_mq_init_queue(&vblk->tag_set);
	vblk->disk->queue = q;
	q->queuedata = vblk;
	virtblk_name_format("vd", index, vblk->disk->disk_name, DISK_NAME_LEN);
	vblk->disk->major = major;
	vblk->disk->first_minor = index_to_minor(index);
	vblk->disk->private_data = vblk;
	vblk->disk->fops = &virtblk_fops;
	vblk->disk->flags |= GENHD_FL_EXT_DEVT;
	vblk->index = index;
......
	device_add_disk(&vdev->dev, vblk->disk);
	err = device_create_file(disk_to_dev(vblk->disk), &dev_attr_serial);
......
}
```

åœ¨virtblk\_probeä¸­ï¼Œæˆ‘ä»¬é¦–å…ˆçœ‹åˆ°çš„æ˜¯struct request\_queueï¼Œè¿™æ˜¯æ¯ä¸€ä¸ªå—è®¾å¤‡éƒ½æœ‰çš„ä¸€ä¸ªé˜Ÿåˆ—ã€‚è¿˜è®°å¾—å—ï¼Ÿå®ƒæœ‰ä¸¤ä¸ªå‡½æ•°ï¼Œä¸€ä¸ªæ˜¯make\_request\_fnå‡½æ•°ï¼Œç”¨äºç”Ÿæˆrequestï¼›å¦ä¸€ä¸ªæ˜¯request\_fnå‡½æ•°ï¼Œç”¨äºå¤„ç†requestã€‚

è¿™ä¸ªrequest\_queueçš„åˆå§‹åŒ–è¿‡ç¨‹åœ¨blk\_mq\_init\_queueä¸­ã€‚å®ƒä¼šè°ƒç”¨blk\_mq\_init\_allocated\_queue-&gt;blk\_queue\_make\_requestã€‚åœ¨è¿™é‡Œé¢ï¼Œæˆ‘ä»¬å¯ä»¥å°†make\_request\_fnå‡½æ•°è®¾ç½®ä¸ºblk\_mq\_make\_requestï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œä¸€æ—¦ä¸Šå±‚æœ‰å†™å…¥è¯·æ±‚ï¼Œæˆ‘ä»¬å°±é€šè¿‡blk\_mq\_make\_requestè¿™ä¸ªå‡½æ•°ï¼Œå°†è¯·æ±‚æ”¾å…¥request\_queueé˜Ÿåˆ—ä¸­ã€‚

å¦å¤–ï¼Œåœ¨virtblk\_probeä¸­ï¼Œæˆ‘ä»¬ä¼šåˆå§‹åŒ–ä¸€ä¸ªgendiskã€‚å‰é¢æˆ‘ä»¬ä¹Ÿè®²äº†ï¼Œæ¯ä¸€ä¸ªå—è®¾å¤‡éƒ½æœ‰è¿™æ ·ä¸€ä¸ªç»“æ„ã€‚

åœ¨virtblk\_probeä¸­ï¼Œè¿˜æœ‰ä¸€ä»¶é‡è¦çš„äº‹æƒ…å°±æ˜¯ï¼Œinit\_vqä¼šæ¥åˆå§‹åŒ–virtqueueã€‚

```
static int init_vq(struct virtio_blk *vblk)
{
	int err;
	int i;
	vq_callback_t **callbacks;
	const char **names;
	struct virtqueue **vqs;
	unsigned short num_vqs;
	struct virtio_device *vdev = vblk->vdev;
......
	vblk->vqs = kmalloc_array(num_vqs, sizeof(*vblk->vqs), GFP_KERNEL);
	names = kmalloc_array(num_vqs, sizeof(*names), GFP_KERNEL);
	callbacks = kmalloc_array(num_vqs, sizeof(*callbacks), GFP_KERNEL);
	vqs = kmalloc_array(num_vqs, sizeof(*vqs), GFP_KERNEL);
......
	for (i = 0; i < num_vqs; i++) {
		callbacks[i] = virtblk_done;
		names[i] = vblk->vqs[i].name;
	}

	/* Discover virtqueues and write information to configuration.  */
	err = virtio_find_vqs(vdev, num_vqs, vqs, callbacks, names, &desc);

	for (i = 0; i < num_vqs; i++) {
		vblk->vqs[i].vq = vqs[i];
	}
	vblk->num_vqs = num_vqs;
......
}
```

æŒ‰ç…§ä¸Šé¢çš„åŸç†æ¥è¯´ï¼Œvirtqueueæ˜¯ä¸€ä¸ªä»‹äºå®¢æˆ·æœºå‰ç«¯å’Œqemuåç«¯çš„ä¸€ä¸ªç»“æ„ï¼Œç”¨äºåœ¨è¿™ä¸¤ç«¯ä¹‹é—´ä¼ é€’æ•°æ®ã€‚è¿™é‡Œå»ºç«‹çš„struct virtqueueæ˜¯å®¢æˆ·æœºå‰ç«¯å¯¹äºé˜Ÿåˆ—çš„ç®¡ç†çš„æ•°æ®ç»“æ„ï¼Œåœ¨å®¢æˆ·æœºçš„linuxå†…æ ¸ä¸­é€šè¿‡kmalloc\_arrayè¿›è¡Œåˆ†é…ã€‚

è€Œé˜Ÿåˆ—çš„å®ä½“éœ€è¦é€šè¿‡å‡½æ•°virtio\_find\_vqsæŸ¥æ‰¾æˆ–è€…ç”Ÿæˆï¼Œæ‰€ä»¥è¿™é‡Œæˆ‘ä»¬è¿˜æŠŠcallbackå‡½æ•°æŒ‡å®šä¸ºvirtblk\_doneã€‚å½“bufferä½¿ç”¨å‘ç”Ÿå˜åŒ–çš„æ—¶å€™ï¼Œæˆ‘ä»¬éœ€è¦è°ƒç”¨è¿™ä¸ªcallbackå‡½æ•°è¿›è¡Œé€šçŸ¥ã€‚

```
static inline
int virtio_find_vqs(struct virtio_device *vdev, unsigned nvqs,
			struct virtqueue *vqs[], vq_callback_t *callbacks[],
			const char * const names[],
			struct irq_affinity *desc)
{
	return vdev->config->find_vqs(vdev, nvqs, vqs, callbacks, names, NULL, desc);
}

static const struct virtio_config_ops virtio_pci_config_ops = {
	.get		= vp_get,
	.set		= vp_set,
	.generation	= vp_generation,
	.get_status	= vp_get_status,
	.set_status	= vp_set_status,
	.reset		= vp_reset,
	.find_vqs	= vp_modern_find_vqs,
	.del_vqs	= vp_del_vqs,
	.get_features	= vp_get_features,
	.finalize_features = vp_finalize_features,
	.bus_name	= vp_bus_name,
	.set_vq_affinity = vp_set_vq_affinity,
	.get_vq_affinity = vp_get_vq_affinity,
};
```

æ ¹æ®virtio\_config\_opsçš„å®šä¹‰ï¼Œvirtio\_find\_vqsä¼šè°ƒç”¨vp\_modern\_find\_vqsã€‚

```
static int vp_modern_find_vqs(struct virtio_device *vdev, unsigned nvqs,
			      struct virtqueue *vqs[],
			      vq_callback_t *callbacks[],
			      const char * const names[], const bool *ctx,
			      struct irq_affinity *desc)
{
	struct virtio_pci_device *vp_dev = to_vp_device(vdev);
	struct virtqueue *vq;
	int rc = vp_find_vqs(vdev, nvqs, vqs, callbacks, names, ctx, desc);
	/* Select and activate all queues. Has to be done last: once we do
	 * this, there's no way to go back except reset.
	 */
	list_for_each_entry(vq, &vdev->vqs, list) {
		vp_iowrite16(vq->index, &vp_dev->common->queue_select);
		vp_iowrite16(1, &vp_dev->common->queue_enable);
	}

	return 0;
}
```

åœ¨vp\_modern\_find\_vqsä¸­ï¼Œvp\_find\_vqsä¼šè°ƒç”¨vp\_find\_vqs\_intxã€‚

```
static int vp_find_vqs_intx(struct virtio_device *vdev, unsigned nvqs,
		struct virtqueue *vqs[], vq_callback_t *callbacks[],
		const char * const names[], const bool *ctx)
{
	struct virtio_pci_device *vp_dev = to_vp_device(vdev);
	int i, err;

	vp_dev->vqs = kcalloc(nvqs, sizeof(*vp_dev->vqs), GFP_KERNEL);
	err = request_irq(vp_dev->pci_dev->irq, vp_interrupt, IRQF_SHARED,
			dev_name(&vdev->dev), vp_dev);
	vp_dev->intx_enabled = 1;
	vp_dev->per_vq_vectors = false;
	for (i = 0; i < nvqs; ++i) {
		vqs[i] = vp_setup_vq(vdev, i, callbacks[i], names[i],
				     ctx ? ctx[i] : false,
				     VIRTIO_MSI_NO_VECTOR);
......
	}
}
```

åœ¨vp\_find\_vqs\_intxä¸­ï¼Œæˆ‘ä»¬é€šè¿‡request\_irqæ³¨å†Œä¸€ä¸ªä¸­æ–­å¤„ç†å‡½æ•°vp\_interruptï¼Œå½“è®¾å¤‡çš„é…ç½®ä¿¡æ¯å‘ç”Ÿæ”¹å˜ï¼Œä¼šäº§ç”Ÿä¸€ä¸ªä¸­æ–­ï¼Œå½“è®¾å¤‡å‘é˜Ÿåˆ—ä¸­å†™å…¥ä¿¡æ¯æ—¶ï¼Œä¹Ÿä¼šäº§ç”Ÿä¸€ä¸ªä¸­æ–­ï¼Œæˆ‘ä»¬ç§°ä¸ºvqä¸­æ–­ï¼Œä¸­æ–­å¤„ç†å‡½æ•°éœ€è¦è°ƒç”¨ç›¸åº”çš„é˜Ÿåˆ—çš„å›è°ƒå‡½æ•°ã€‚

ç„¶åï¼Œæˆ‘ä»¬æ ¹æ®é˜Ÿåˆ—çš„æ•°ç›®ï¼Œä¾æ¬¡è°ƒç”¨vp\_setup\_vqï¼Œå®Œæˆvirtqueueã€vringçš„åˆ†é…å’Œåˆå§‹åŒ–ã€‚

```
static struct virtqueue *vp_setup_vq(struct virtio_device *vdev, unsigned index,
				     void (*callback)(struct virtqueue *vq),
				     const char *name,
				     bool ctx,
				     u16 msix_vec)
{
	struct virtio_pci_device *vp_dev = to_vp_device(vdev);
	struct virtio_pci_vq_info *info = kmalloc(sizeof *info, GFP_KERNEL);
	struct virtqueue *vq;
	unsigned long flags;
......
	vq = vp_dev->setup_vq(vp_dev, info, index, callback, name, ctx,
			      msix_vec);
	info->vq = vq;
	if (callback) {
		spin_lock_irqsave(&vp_dev->lock, flags);
		list_add(&info->node, &vp_dev->virtqueues);
		spin_unlock_irqrestore(&vp_dev->lock, flags);
	} else {
		INIT_LIST_HEAD(&info->node);
	}
	vp_dev->vqs[index] = info;
	return vq;
}

static struct virtqueue *setup_vq(struct virtio_pci_device *vp_dev,
				  struct virtio_pci_vq_info *info,
				  unsigned index,
				  void (*callback)(struct virtqueue *vq),
				  const char *name,
				  bool ctx,
				  u16 msix_vec)
{
	struct virtio_pci_common_cfg __iomem *cfg = vp_dev->common;
	struct virtqueue *vq;
	u16 num, off;
	int err;

	/* Select the queue we're interested in */
	vp_iowrite16(index, &cfg->queue_select);

	/* Check if queue is either not available or already active. */
	num = vp_ioread16(&cfg->queue_size);

	/* get offset of notification word for this vq */
	off = vp_ioread16(&cfg->queue_notify_off);

	info->msix_vector = msix_vec;

	/* create the vring */
	vq = vring_create_virtqueue(index, num,
				    SMP_CACHE_BYTES, &vp_dev->vdev,
				    true, true, ctx,
				    vp_notify, callback, name);
	/* activate the queue */
	vp_iowrite16(virtqueue_get_vring_size(vq), &cfg->queue_size);
	vp_iowrite64_twopart(virtqueue_get_desc_addr(vq),
			     &cfg->queue_desc_lo, &cfg->queue_desc_hi);
	vp_iowrite64_twopart(virtqueue_get_avail_addr(vq),
			     &cfg->queue_avail_lo, &cfg->queue_avail_hi);
	vp_iowrite64_twopart(virtqueue_get_used_addr(vq),
			     &cfg->queue_used_lo, &cfg->queue_used_hi);
......
	return vq;
}

struct virtqueue *vring_create_virtqueue(
	unsigned int index,
	unsigned int num,
	unsigned int vring_align,
	struct virtio_device *vdev,
	bool weak_barriers,
	bool may_reduce_num,
	bool context,
	bool (*notify)(struct virtqueue *),
	void (*callback)(struct virtqueue *),
	const char *name)
{
	struct virtqueue *vq;
	void *queue = NULL;
	dma_addr_t dma_addr;
	size_t queue_size_in_bytes;
	struct vring vring;

	/* TODO: allocate each queue chunk individually */
	for (; num && vring_size(num, vring_align) > PAGE_SIZE; num /= 2) {
		queue = vring_alloc_queue(vdev, vring_size(num, vring_align),
					  &dma_addr,
					  GFP_KERNEL|__GFP_NOWARN|__GFP_ZERO);
		if (queue)
			break;
	}

	if (!queue) {
		/* Try to get a single page. You are my only hope! */
		queue = vring_alloc_queue(vdev, vring_size(num, vring_align),
					  &dma_addr, GFP_KERNEL|__GFP_ZERO);
	}

	queue_size_in_bytes = vring_size(num, vring_align);
	vring_init(&vring, num, queue, vring_align);

	vq = __vring_new_virtqueue(index, vring, vdev, weak_barriers, context, notify, callback, name);

	to_vvq(vq)->queue_dma_addr = dma_addr;
	to_vvq(vq)->queue_size_in_bytes = queue_size_in_bytes;
	to_vvq(vq)->we_own_ring = true;

	return vq;
}
```

åœ¨vring\_create\_virtqueueä¸­ï¼Œæˆ‘ä»¬ä¼šè°ƒç”¨vring\_alloc\_queueï¼Œæ¥åˆ›å»ºé˜Ÿåˆ—æ‰€éœ€è¦çš„å†…å­˜ç©ºé—´ï¼Œç„¶åè°ƒç”¨vring\_initåˆå§‹åŒ–ç»“æ„struct vringï¼Œæ¥ç®¡ç†é˜Ÿåˆ—çš„å†…å­˜ç©ºé—´ï¼Œè°ƒç”¨\_\_vring\_new\_virtqueueï¼Œæ¥åˆ›å»ºstruct vring\_virtqueueã€‚

è¿™ä¸ªç»“æ„çš„ä¸€å¼€å§‹ï¼Œæ˜¯struct virtqueueï¼Œå®ƒä¹Ÿæ˜¯struct virtqueueçš„ä¸€ä¸ªæ‰©å±•ï¼Œç´§æ¥ç€åé¢å°±æ˜¯struct vringã€‚

```
struct vring_virtqueue {
	struct virtqueue vq;

	/* Actual memory layout for this queue */
	struct vring vring;
......
}
```

è‡³æ­¤æˆ‘ä»¬å‘ç°ï¼Œè™šæ‹Ÿæœºé‡Œé¢çš„virtioçš„å‰ç«¯æ˜¯è¿™æ ·çš„ç»“æ„ï¼šstruct virtio\_deviceé‡Œé¢æœ‰ä¸€ä¸ªstruct vring\_virtqueueï¼Œåœ¨struct vring\_virtqueueé‡Œé¢æœ‰ä¸€ä¸ªstruct vringã€‚

## ä¸­é—´virtioé˜Ÿåˆ—çš„ç®¡ç†

è¿˜è®°ä¸è®°å¾—æˆ‘ä»¬ä¸Šé¢è®²qemuåˆå§‹åŒ–çš„æ—¶å€™ï¼Œvirtioçš„åç«¯æœ‰æ•°æ®ç»“æ„VirtIODeviceï¼ŒVirtQueueå’Œvringä¸€æ¨¡ä¸€æ ·ï¼Œå‰ç«¯å’Œåç«¯å¯¹åº”èµ·æ¥ï¼Œéƒ½åº”è¯¥æŒ‡å‘åˆšæ‰åˆ›å»ºçš„é‚£ä¸€æ®µå†…å­˜ã€‚

ç°åœ¨çš„é—®é¢˜æ˜¯ï¼Œæˆ‘ä»¬åˆšæ‰åˆ†é…çš„å†…å­˜åœ¨å®¢æˆ·æœºçš„å†…æ ¸é‡Œé¢ï¼Œå¦‚ä½•å‘ŠçŸ¥qemuæ¥è®¿é—®è¿™æ®µå†…å­˜å‘¢ï¼Ÿ

åˆ«å¿˜äº†ï¼Œqemuæ¨¡æ‹Ÿå‡ºæ¥çš„virtio block deviceåªæ˜¯ä¸€ä¸ªPCIè®¾å¤‡ã€‚å¯¹äºå®¢æˆ·æœºæ¥è®²ï¼Œè¿™æ˜¯ä¸€ä¸ªå¤–éƒ¨è®¾å¤‡ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ç»™å¤–éƒ¨è®¾å¤‡å‘é€æŒ‡ä»¤çš„æ–¹å¼å‘ŠçŸ¥å¤–éƒ¨è®¾å¤‡ï¼Œè¿™å°±æ˜¯ä»£ç ä¸­vp\_iowrite16çš„ä½œç”¨ã€‚å®ƒä¼šè°ƒç”¨ä¸“é—¨ç»™å¤–éƒ¨è®¾å¤‡å‘é€æŒ‡ä»¤çš„å‡½æ•°iowriteï¼Œå‘Šè¯‰å¤–éƒ¨çš„PCIè®¾å¤‡ã€‚

å‘ŠçŸ¥çš„æœ‰ä¸‰ä¸ªåœ°å€virtqueue\_get\_desc\_addrã€virtqueue\_get\_avail\_addrï¼Œvirtqueue\_get\_used\_addrã€‚ä»å®¢æˆ·æœºè§’åº¦æ¥çœ‹ï¼Œè¿™é‡Œé¢çš„åœ°å€éƒ½æ˜¯ç‰©ç†åœ°å€ï¼Œä¹Ÿå³GPAï¼ˆGuest Physical Addressï¼‰ã€‚å› ä¸ºåªæœ‰ç‰©ç†åœ°å€æ‰æ˜¯å®¢æˆ·æœºå’Œqemuç¨‹åºéƒ½è®¤å¯çš„åœ°å€ï¼Œæœ¬æ¥å®¢æˆ·æœºçš„ç‰©ç†å†…å­˜ä¹Ÿæ˜¯qemuæ¨¡æ‹Ÿå‡ºæ¥çš„ã€‚

åœ¨qemuä¸­ï¼Œå¯¹PCIæ€»çº¿æ·»åŠ ä¸€ä¸ªè®¾å¤‡çš„æ—¶å€™ï¼Œæˆ‘ä»¬ä¼šè°ƒç”¨virtio\_pci\_device\_pluggedã€‚

```
static void virtio_pci_device_plugged(DeviceState *d, Error **errp)
{
    VirtIOPCIProxy *proxy = VIRTIO_PCI(d);
......
    memory_region_init_io(&proxy->bar, OBJECT(proxy),
                              &virtio_pci_config_ops,
                              proxy, "virtio-pci", size);
......
}

static const MemoryRegionOps virtio_pci_config_ops = {
    .read = virtio_pci_config_read,
    .write = virtio_pci_config_write,
    .impl = {
        .min_access_size = 1,
        .max_access_size = 4,
    },
    .endianness = DEVICE_LITTLE_ENDIAN,
};
```

åœ¨è¿™é‡Œé¢ï¼Œå¯¹äºè¿™ä¸ªåŠ è½½çš„è®¾å¤‡è¿›è¡ŒI/Oæ“ä½œï¼Œä¼šæ˜ å°„åˆ°è¯»å†™æŸä¸€å—å†…å­˜ç©ºé—´ï¼Œå¯¹åº”çš„æ“ä½œä¸ºvirtio\_pci\_config\_opsï¼Œä¹Ÿå³å†™å…¥è¿™å—å†…å­˜ç©ºé—´ï¼Œè¿™å°±ç›¸å½“äºå¯¹äºè¿™ä¸ªPCIè®¾å¤‡è¿›è¡ŒæŸç§é…ç½®ã€‚

å¯¹PCIè®¾å¤‡è¿›è¡Œé…ç½®çš„æ—¶å€™ï¼Œä¼šæœ‰è¿™æ ·çš„è°ƒç”¨é“¾ï¼švirtio\_pci\_config\_write-&gt;virtio\_ioport\_write-&gt;virtio\_queue\_set\_addrã€‚è®¾ç½®virtioçš„queueçš„åœ°å€æ˜¯ä¸€é¡¹å¾ˆé‡è¦çš„æ“ä½œã€‚

```
void virtio_queue_set_addr(VirtIODevice *vdev, int n, hwaddr addr)
{
    vdev->vq[n].vring.desc = addr;
    virtio_queue_update_rings(vdev, n);
}
```

ä»è¿™é‡Œæˆ‘ä»¬å¯ä»¥çœ‹å‡ºï¼Œqemuåç«¯çš„VirtIODeviceçš„VirtQueueçš„vringçš„åœ°å€ï¼Œè¢«è®¾ç½®æˆäº†åˆšæ‰ç»™é˜Ÿåˆ—åˆ†é…çš„å†…å­˜çš„GPAã€‚

![](https://static001.geekbang.org/resource/image/25/d0/2572f8b1e75b9eaab6560866fcb31fd0.jpg?wh=5158%2A4690)

æ¥ç€ï¼Œæˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹è¿™ä¸ªé˜Ÿåˆ—çš„æ ¼å¼ã€‚

![](https://static001.geekbang.org/resource/image/49/db/49414d5acc81933b66410bbba102b0db.jpg?wh=1546%2A1303)

```
/* Virtio ring descriptors: 16 bytes.  These can chain together via "next". */
struct vring_desc {
	/* Address (guest-physical). */
	__virtio64 addr;
	/* Length. */
	__virtio32 len;
	/* The flags as indicated above. */
	__virtio16 flags;
	/* We chain unused descriptors via this, too */
	__virtio16 next;
};

struct vring_avail {
	__virtio16 flags;
	__virtio16 idx;
	__virtio16 ring[];
};

/* u32 is used here for ids for padding reasons. */
struct vring_used_elem {
	/* Index of start of used descriptor chain. */
	__virtio32 id;
	/* Total length of the descriptor chain which was used (written to) */
	__virtio32 len;
};

struct vring_used {
	__virtio16 flags;
	__virtio16 idx;
	struct vring_used_elem ring[];
};

struct vring {
	unsigned int num;

	struct vring_desc *desc;

	struct vring_avail *avail;

	struct vring_used *used;
};
```

vringåŒ…å«ä¸‰ä¸ªæˆå‘˜ï¼š

- vring\_descæŒ‡å‘åˆ†é…çš„å†…å­˜å—ï¼Œç”¨äºå­˜æ”¾å®¢æˆ·æœºå’Œqemuä¹‹é—´ä¼ è¾“çš„æ•°æ®ã€‚
- avail-&gt;ring\[]æ˜¯å‘é€ç«¯ç»´æŠ¤çš„ç¯å½¢é˜Ÿåˆ—ï¼ŒæŒ‡å‘éœ€è¦æ¥æ”¶ç«¯å¤„ç†çš„vring\_descã€‚
- used-&gt;ring\[]æ˜¯æ¥æ”¶ç«¯ç»´æŠ¤çš„ç¯å½¢é˜Ÿåˆ—ï¼ŒæŒ‡å‘è‡ªå·±å·²ç»å¤„ç†è¿‡äº†çš„vring\_descã€‚

## æ•°æ®å†™å…¥çš„æµç¨‹

æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬æ¥çœ‹ï¼ŒçœŸçš„å†™å…¥ä¸€ä¸ªæ•°æ®çš„æ—¶å€™ï¼Œä¼šå‘ç”Ÿä»€ä¹ˆã€‚

æŒ‰ç…§ä¸Šé¢virtioé©±åŠ¨åˆå§‹åŒ–çš„æ—¶å€™çš„é€»è¾‘ï¼Œblk\_mq\_make\_requestä¼šè¢«è°ƒç”¨ã€‚è¿™ä¸ªå‡½æ•°æ¯”è¾ƒå¤æ‚ï¼Œä¼šåˆ†æˆå¤šä¸ªåˆ†æ”¯ï¼Œä½†æ˜¯æœ€ç»ˆéƒ½ä¼šè°ƒç”¨åˆ°request\_queueçš„virtio\_mq\_opsçš„queue\_rqå‡½æ•°ã€‚

```
struct request_queue *q = rq->q;
q->mq_ops->queue_rq(hctx, &bd);

static const struct blk_mq_ops virtio_mq_ops = {
	.queue_rq	= virtio_queue_rq,
	.complete	= virtblk_request_done,
	.init_request	= virtblk_init_request,
	.map_queues	= virtblk_map_queues,
};
```

æ ¹æ®virtio\_mq\_opsçš„å®šä¹‰ï¼Œæˆ‘ä»¬ç°åœ¨è¦è°ƒç”¨virtio\_queue\_rqã€‚

```
static blk_status_t virtio_queue_rq(struct blk_mq_hw_ctx *hctx,
			   const struct blk_mq_queue_data *bd)
{
	struct virtio_blk *vblk = hctx->queue->queuedata;
	struct request *req = bd->rq;
	struct virtblk_req *vbr = blk_mq_rq_to_pdu(req);
......
	err = virtblk_add_req(vblk->vqs[qid].vq, vbr, vbr->sg, num);
......
	if (notify)
		virtqueue_notify(vblk->vqs[qid].vq);
	return BLK_STS_OK;
}
```

åœ¨virtio\_queue\_rqä¸­ï¼Œæˆ‘ä»¬ä¼šå°†è¯·æ±‚å†™å…¥çš„æ•°æ®ï¼Œé€šè¿‡virtblk\_add\_reqæ”¾å…¥struct virtqueueã€‚

å› æ­¤ï¼Œæ¥ä¸‹æ¥çš„è°ƒç”¨é“¾ä¸ºï¼švirtblk\_add\_req-&gt;virtqueue\_add\_sgs-&gt;virtqueue\_addã€‚

```
static inline int virtqueue_add(struct virtqueue *_vq,
				struct scatterlist *sgs[],
				unsigned int total_sg,
				unsigned int out_sgs,
				unsigned int in_sgs,
				void *data,
				void *ctx,
				gfp_t gfp)
{
	struct vring_virtqueue *vq = to_vvq(_vq);
	struct scatterlist *sg;
	struct vring_desc *desc;
	unsigned int i, n, avail, descs_used, uninitialized_var(prev), err_idx;
	int head;
	bool indirect;
......
	head = vq->free_head;

	indirect = false;
	desc = vq->vring.desc;
	i = head;
	descs_used = total_sg;

	for (n = 0; n < out_sgs; n++) {
		for (sg = sgs[n]; sg; sg = sg_next(sg)) {
			dma_addr_t addr = vring_map_one_sg(vq, sg, DMA_TO_DEVICE);
......
			desc[i].flags = cpu_to_virtio16(_vq->vdev, VRING_DESC_F_NEXT);
			desc[i].addr = cpu_to_virtio64(_vq->vdev, addr);
			desc[i].len = cpu_to_virtio32(_vq->vdev, sg->length);
			prev = i;
			i = virtio16_to_cpu(_vq->vdev, desc[i].next);
		}
	}

	/* Last one doesn't continue. */
	desc[prev].flags &= cpu_to_virtio16(_vq->vdev, ~VRING_DESC_F_NEXT);

	/* We're using some buffers from the free list. */
	vq->vq.num_free -= descs_used;

	/* Update free pointer */
	vq->free_head = i;

	/* Store token and indirect buffer state. */
	vq->desc_state[head].data = data;

	/* Put entry in available array (but don't update avail->idx until they do sync). */
	avail = vq->avail_idx_shadow & (vq->vring.num - 1);
	vq->vring.avail->ring[avail] = cpu_to_virtio16(_vq->vdev, head);

	/* Descriptors and available array need to be set before we expose the new available array entries. */
	virtio_wmb(vq->weak_barriers);
	vq->avail_idx_shadow++;
	vq->vring.avail->idx = cpu_to_virtio16(_vq->vdev, vq->avail_idx_shadow);
	vq->num_added++;
......
	return 0;
}
```

åœ¨virtqueue\_addå‡½æ•°ä¸­ï¼Œæˆ‘ä»¬èƒ½çœ‹åˆ°ï¼Œfree\_headæŒ‡å‘çš„æ•´ä¸ªå†…å­˜å—ç©ºé—²é“¾è¡¨çš„èµ·å§‹ä½ç½®ï¼Œç”¨headå˜é‡è®°ä½è¿™ä¸ªèµ·å§‹ä½ç½®ã€‚

æ¥ä¸‹æ¥ï¼Œiä¹ŸæŒ‡å‘è¿™ä¸ªèµ·å§‹ä½ç½®ï¼Œç„¶åæ˜¯ä¸€ä¸ªforå¾ªç¯ï¼Œå°†æ•°æ®æ”¾åˆ°å†…å­˜å—é‡Œé¢ï¼Œæ”¾çš„è¿‡ç¨‹ä¸­ï¼Œnextä¸æ–­æŒ‡å‘ä¸‹ä¸€ä¸ªç©ºé—²ä½ç½®ï¼Œè¿™æ ·ç©ºé—²çš„å†…å­˜å—è¢«ä¸æ–­çš„å ç”¨ã€‚ç­‰æ‰€æœ‰çš„å†™å…¥éƒ½ç»“æŸäº†ï¼Œiå°±ä¼šæŒ‡å‘è¿™æ¬¡å­˜æ”¾çš„å†…å­˜å—çš„ä¸‹ä¸€ä¸ªç©ºé—²ä½ç½®ï¼Œç„¶åfree\_headå°±æŒ‡å‘iï¼Œå› ä¸ºå‰é¢çš„éƒ½å¡«æ»¡äº†ã€‚

è‡³æ­¤ï¼Œä»headåˆ°iä¹‹é—´çš„å†…å­˜å—ï¼Œå°±æ˜¯è¿™æ¬¡å†™å…¥çš„å…¨éƒ¨æ•°æ®ã€‚

äºæ˜¯ï¼Œåœ¨vringçš„availå˜é‡ä¸­ï¼Œåœ¨ring\[]æ•°ç»„ä¸­åˆ†é…æ–°çš„ä¸€é¡¹ï¼Œåœ¨availçš„ä½ç½®ï¼Œavailçš„è®¡ç®—æ˜¯avail\_idx\_shadow &amp; (vq-&gt;vring.num - 1)ï¼Œå…¶ä¸­ï¼Œavail\_idx\_shadowæ˜¯ä¸Šä¸€æ¬¡çš„availçš„ä½ç½®ã€‚è¿™é‡Œå¦‚æœè¶…è¿‡äº†ring\[]æ•°ç»„çš„ä¸‹æ ‡ï¼Œåˆ™é‡æ–°è·³åˆ°èµ·å§‹ä½ç½®ï¼Œå°±è¯´æ˜æ˜¯ä¸€ä¸ªç¯ã€‚è¿™æ¬¡åˆ†é…çš„æ–°çš„availçš„ä½ç½®å°±å­˜æ”¾æ–°å†™å…¥çš„ä»headåˆ°iä¹‹é—´çš„å†…å­˜å—ã€‚ç„¶åæ˜¯avail\_idx\_shadow++ï¼Œè¿™è¯´æ˜è¿™ä¸€å—å†…å­˜å¯ä»¥è¢«æ¥æ”¶æ–¹è¯»å–äº†ã€‚

æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å›åˆ°virtio\_queue\_rqï¼Œè°ƒç”¨virtqueue\_notifyé€šçŸ¥æ¥æ”¶æ–¹ã€‚è€Œvirtqueue\_notifyä¼šè°ƒç”¨vp\_notifyã€‚

```
bool vp_notify(struct virtqueue *vq)
{
	/* we write the queue's selector into the notification register to
	 * signal the other end */
	iowrite16(vq->index, (void __iomem *)vq->priv);
	return true;
}
```

ç„¶åï¼Œæˆ‘ä»¬å†™å…¥ä¸€ä¸ªI/Oä¼šè§¦å‘VM exitã€‚æˆ‘ä»¬åœ¨è§£æCPUçš„æ—¶å€™çœ‹åˆ°è¿‡è¿™ä¸ªé€»è¾‘ã€‚

```
int kvm_cpu_exec(CPUState *cpu)
{
    struct kvm_run *run = cpu->kvm_run;
    int ret, run_ret;
......
    run_ret = kvm_vcpu_ioctl(cpu, KVM_RUN, 0);
......
    switch (run->exit_reason) {
        case KVM_EXIT_IO:
            DPRINTF("handle_io\n");
            /* Called outside BQL */
            kvm_handle_io(run->io.port, attrs,
                          (uint8_t *)run + run->io.data_offset,
                          run->io.direction,
                          run->io.size,
                          run->io.count);
            ret = 0;
            break;
    }
......
}
```

è¿™æ¬¡å†™å…¥çš„ä¹Ÿæ˜¯ä¸€ä¸ªI/Oçš„å†…å­˜ç©ºé—´ï¼ŒåŒæ ·ä¼šè§¦å‘virtio\_ioport\_writeï¼Œè¿™æ¬¡ä¼šè°ƒç”¨virtio\_queue\_notifyã€‚

```
void virtio_queue_notify(VirtIODevice *vdev, int n)
{
    VirtQueue *vq = &vdev->vq[n];
......
    if (vq->handle_aio_output) {
        event_notifier_set(&vq->host_notifier);
    } else if (vq->handle_output) {
        vq->handle_output(vdev, vq);
    }
}
```

virtio\_queue\_notifyä¼šè°ƒç”¨VirtQueueçš„handle\_outputå‡½æ•°ï¼Œå‰é¢æˆ‘ä»¬å·²ç»è®¾ç½®è¿‡è¿™ä¸ªå‡½æ•°äº†ï¼Œæ˜¯virtio\_blk\_handle\_outputã€‚

æ¥ä¸‹æ¥çš„è°ƒç”¨é“¾ä¸ºï¼švirtio\_blk\_handle\_output-&gt;virtio\_blk\_handle\_output\_do-&gt;virtio\_blk\_handle\_vqã€‚

```
bool virtio_blk_handle_vq(VirtIOBlock *s, VirtQueue *vq)
{
    VirtIOBlockReq *req;
    MultiReqBuffer mrb = {};
    bool progress = false;
......
    do {
        virtio_queue_set_notification(vq, 0);

        while ((req = virtio_blk_get_request(s, vq))) {
            progress = true;
            if (virtio_blk_handle_request(req, &mrb)) {
                virtqueue_detach_element(req->vq, &req->elem, 0);
                virtio_blk_free_request(req);
                break;
            }
        }

        virtio_queue_set_notification(vq, 1);
    } while (!virtio_queue_empty(vq));

    if (mrb.num_reqs) {
        virtio_blk_submit_multireq(s->blk, &mrb);
    }
......
    return progress;
}
```

åœ¨virtio\_blk\_handle\_vqä¸­ï¼Œæœ‰ä¸€ä¸ªwhileå¾ªç¯ï¼Œåœ¨å¾ªç¯ä¸­è°ƒç”¨å‡½æ•°virtio\_blk\_get\_requestä»vqä¸­å–å‡ºè¯·æ±‚ï¼Œç„¶åè°ƒç”¨virtio\_blk\_handle\_requestå¤„ç†ä»vqä¸­å–å‡ºçš„è¯·æ±‚ã€‚

æˆ‘ä»¬å…ˆæ¥çœ‹virtio\_blk\_get\_requestã€‚

```
static VirtIOBlockReq *virtio_blk_get_request(VirtIOBlock *s, VirtQueue *vq)
{
    VirtIOBlockReq *req = virtqueue_pop(vq, sizeof(VirtIOBlockReq));

    if (req) {
        virtio_blk_init_request(s, vq, req);
    }
    return req;
}

void *virtqueue_pop(VirtQueue *vq, size_t sz)
{
    unsigned int i, head, max;
    VRingMemoryRegionCaches *caches;
    MemoryRegionCache *desc_cache;
    int64_t len;
    VirtIODevice *vdev = vq->vdev;
    VirtQueueElement *elem = NULL;
    unsigned out_num, in_num, elem_entries;
    hwaddr addr[VIRTQUEUE_MAX_SIZE];
    struct iovec iov[VIRTQUEUE_MAX_SIZE];
    VRingDesc desc;
    int rc;
......
    /* When we start there are none of either input nor output. */
    out_num = in_num = elem_entries = 0;

    max = vq->vring.num;

    i = head;

    caches = vring_get_region_caches(vq);
    desc_cache = &caches->desc;
    vring_desc_read(vdev, &desc, desc_cache, i);
......
    /* Collect all the descriptors */
    do {
        bool map_ok;

        if (desc.flags & VRING_DESC_F_WRITE) {
            map_ok = virtqueue_map_desc(vdev, &in_num, addr + out_num,
                                        iov + out_num,
                                        VIRTQUEUE_MAX_SIZE - out_num, true,
                                        desc.addr, desc.len);
        } else {
            map_ok = virtqueue_map_desc(vdev, &out_num, addr, iov,
                                        VIRTQUEUE_MAX_SIZE, false,
                                        desc.addr, desc.len);
        }
......
        rc = virtqueue_read_next_desc(vdev, &desc, desc_cache, max, &i);
    } while (rc == VIRTQUEUE_READ_DESC_MORE);
......
    /* Now copy what we have collected and mapped */
    elem = virtqueue_alloc_element(sz, out_num, in_num);
    elem->index = head;
    for (i = 0; i < out_num; i++) {
        elem->out_addr[i] = addr[i];
        elem->out_sg[i] = iov[i];
    }
    for (i = 0; i < in_num; i++) {
        elem->in_addr[i] = addr[out_num + i];
        elem->in_sg[i] = iov[out_num + i];
    }

    vq->inuse++;
......
    return elem;
}
```

æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œvirtio\_blk\_get\_requestä¼šè°ƒç”¨virtqueue\_popã€‚åœ¨è¿™é‡Œé¢ï¼Œæˆ‘ä»¬èƒ½çœ‹åˆ°å¯¹äºvringçš„æ“ä½œï¼Œä¹Ÿå³ä»è¿™é‡Œé¢å°†å®¢æˆ·æœºé‡Œé¢å†™å…¥çš„æ•°æ®è¯»å–å‡ºæ¥ï¼Œæ”¾åˆ°VirtIOBlockReqç»“æ„ä¸­ã€‚

æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°±è¦è°ƒç”¨virtio\_blk\_handle\_requestå¤„ç†è¿™äº›æ•°æ®ã€‚æ‰€ä»¥æ¥ä¸‹æ¥çš„è°ƒç”¨é“¾ä¸ºï¼švirtio\_blk\_handle\_request-&gt;virtio\_blk\_submit\_multireq-&gt;submit\_requestsã€‚

```
static inline void submit_requests(BlockBackend *blk, MultiReqBuffer *mrb,int start, int num_reqs, int niov)
{
    QEMUIOVector *qiov = &mrb->reqs[start]->qiov;
    int64_t sector_num = mrb->reqs[start]->sector_num;
    bool is_write = mrb->is_write;

    if (num_reqs > 1) {
        int i;
        struct iovec *tmp_iov = qiov->iov;
        int tmp_niov = qiov->niov;
        qemu_iovec_init(qiov, niov);

        for (i = 0; i < tmp_niov; i++) {
            qemu_iovec_add(qiov, tmp_iov[i].iov_base, tmp_iov[i].iov_len);
        }

        for (i = start + 1; i < start + num_reqs; i++) {
            qemu_iovec_concat(qiov, &mrb->reqs[i]->qiov, 0,
                              mrb->reqs[i]->qiov.size);
            mrb->reqs[i - 1]->mr_next = mrb->reqs[i];
        }

        block_acct_merge_done(blk_get_stats(blk),
                              is_write ? BLOCK_ACCT_WRITE : BLOCK_ACCT_READ,
                              num_reqs - 1);
    }

    if (is_write) {
        blk_aio_pwritev(blk, sector_num << BDRV_SECTOR_BITS, qiov, 0,
                        virtio_blk_rw_complete, mrb->reqs[start]);
    } else {
        blk_aio_preadv(blk, sector_num << BDRV_SECTOR_BITS, qiov, 0,
                       virtio_blk_rw_complete, mrb->reqs[start]);
    }
}
```

åœ¨submit\_requestsä¸­ï¼Œæˆ‘ä»¬çœ‹åˆ°äº†BlockBackendã€‚è¿™æ˜¯åœ¨qemuå¯åŠ¨çš„æ—¶å€™ï¼Œæ‰“å¼€qcow2æ–‡ä»¶çš„æ—¶å€™ç”Ÿæˆçš„ï¼Œç°åœ¨æˆ‘ä»¬å¯ä»¥ç”¨å®ƒæ¥å†™å…¥æ–‡ä»¶äº†ï¼Œè°ƒç”¨çš„æ˜¯blk\_aio\_pwritevã€‚

```
BlockAIOCB *blk_aio_pwritev(BlockBackend *blk, int64_t offset,
                            QEMUIOVector *qiov, BdrvRequestFlags flags,
                            BlockCompletionFunc *cb, void *opaque)
{
    return blk_aio_prwv(blk, offset, qiov->size, qiov,
                        blk_aio_write_entry, flags, cb, opaque);
}

static BlockAIOCB *blk_aio_prwv(BlockBackend *blk, int64_t offset, int bytes,
                                void *iobuf, CoroutineEntry co_entry,
                                BdrvRequestFlags flags,
                                BlockCompletionFunc *cb, void *opaque)
{
    BlkAioEmAIOCB *acb;
    Coroutine *co;
    acb = blk_aio_get(&blk_aio_em_aiocb_info, blk, cb, opaque);
    acb->rwco = (BlkRwCo) {
        .blk    = blk,
        .offset = offset,
        .iobuf  = iobuf,
        .flags  = flags,
        .ret    = NOT_DONE,
    };
    acb->bytes = bytes;
    acb->has_returned = false;

    co = qemu_coroutine_create(co_entry, acb);
    bdrv_coroutine_enter(blk_bs(blk), co);

    acb->has_returned = true;
    return &acb->common;
}
```

åœ¨blk\_aio\_pwritevä¸­ï¼Œæˆ‘ä»¬çœ‹åˆ°ï¼Œåˆæ˜¯åˆ›å»ºäº†ä¸€ä¸ªåç¨‹æ¥è¿›è¡Œå†™å…¥ã€‚å†™å…¥å®Œæ¯•ä¹‹åè°ƒç”¨virtio\_blk\_rw\_complete-&gt;virtio\_blk\_req\_completeã€‚

```
static void virtio_blk_req_complete(VirtIOBlockReq *req, unsigned char status)
{
    VirtIOBlock *s = req->dev;
    VirtIODevice *vdev = VIRTIO_DEVICE(s);

    trace_virtio_blk_req_complete(vdev, req, status);

    stb_p(&req->in->status, status);
    virtqueue_push(req->vq, &req->elem, req->in_len);
    virtio_notify(vdev, req->vq);
}
```

åœ¨virtio\_blk\_req\_completeä¸­ï¼Œæˆ‘ä»¬å…ˆæ˜¯è°ƒç”¨virtqueue\_pushï¼Œæ›´æ–°vringä¸­usedå˜é‡ï¼Œè¡¨ç¤ºè¿™éƒ¨åˆ†å·²ç»å†™å…¥å®Œæ¯•ï¼Œç©ºé—´å¯ä»¥å›æ”¶åˆ©ç”¨äº†ã€‚ä½†æ˜¯ï¼Œè¿™éƒ¨åˆ†çš„æ”¹å˜ä»…ä»…æ”¹å˜äº†qemuåç«¯çš„vringï¼Œæˆ‘ä»¬è¿˜éœ€è¦é€šçŸ¥å®¢æˆ·æœºä¸­virtioå‰ç«¯çš„vringçš„å€¼ï¼Œå› è€Œè¦è°ƒç”¨virtio\_notifyã€‚virtio\_notifyä¼šè°ƒç”¨virtio\_irqå‘é€ä¸€ä¸ªä¸­æ–­ã€‚

è¿˜è®°å¾—å’±ä»¬å‰é¢æ³¨å†Œè¿‡ä¸€ä¸ªä¸­æ–­å¤„ç†å‡½æ•°vp\_interruptå—ï¼Ÿå®ƒå°±æ˜¯å¹²è¿™ä¸ªäº‹æƒ…çš„ã€‚

```
static irqreturn_t vp_interrupt(int irq, void *opaque)
{
	struct virtio_pci_device *vp_dev = opaque;
	u8 isr;

	/* reading the ISR has the effect of also clearing it so it's very
	 * important to save off the value. */
	isr = ioread8(vp_dev->isr);

	/* Configuration change?  Tell driver if it wants to know. */
	if (isr & VIRTIO_PCI_ISR_CONFIG)
		vp_config_changed(irq, opaque);

	return vp_vring_interrupt(irq, opaque);
}
```

å°±åƒå‰é¢è¯´çš„ä¸€æ ·vp\_interruptè¿™ä¸ªä¸­æ–­å¤„ç†å‡½æ•°ï¼Œä¸€æ˜¯å¤„ç†é…ç½®å˜åŒ–ï¼ŒäºŒæ˜¯å¤„ç†I/Oç»“æŸã€‚ç¬¬äºŒç§çš„è°ƒç”¨é“¾ä¸ºï¼švp\_interrupt-&gt;vp\_vring\_interrupt-&gt;vring\_interruptã€‚

```
irqreturn_t vring_interrupt(int irq, void *_vq)
{
	struct vring_virtqueue *vq = to_vvq(_vq);
......
	if (vq->vq.callback)
		vq->vq.callback(&vq->vq);

	return IRQ_HANDLED;
}
```

åœ¨vring\_interruptä¸­ï¼Œæˆ‘ä»¬ä¼šè°ƒç”¨callbackå‡½æ•°ï¼Œè¿™ä¸ªä¹Ÿæ˜¯åœ¨å‰é¢æ³¨å†Œè¿‡çš„ï¼Œæ˜¯virtblk\_doneã€‚

æ¥ä¸‹æ¥çš„è°ƒç”¨é“¾ä¸ºï¼švirtblk\_done-&gt;virtqueue\_get\_buf-&gt;virtqueue\_get\_buf\_ctxã€‚

```
void *virtqueue_get_buf_ctx(struct virtqueue *_vq, unsigned int *len,
			    void **ctx)
{
	struct vring_virtqueue *vq = to_vvq(_vq);
	void *ret;
	unsigned int i;
	u16 last_used;
......
	last_used = (vq->last_used_idx & (vq->vring.num - 1));
	i = virtio32_to_cpu(_vq->vdev, vq->vring.used->ring[last_used].id);
	*len = virtio32_to_cpu(_vq->vdev, vq->vring.used->ring[last_used].len);
......
	/* detach_buf clears data, so grab it now. */
	ret = vq->desc_state[i].data;
	detach_buf(vq, i, ctx);
	vq->last_used_idx++;
......
	return ret;
}
```

åœ¨virtqueue\_get\_buf\_ctxä¸­ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œvirtioå‰ç«¯çš„vringä¸­çš„last\_used\_idxåŠ ä¸€ï¼Œè¯´æ˜è¿™å—æ•°æ®qemuåç«¯å·²ç»æ¶ˆè´¹å®Œæ¯•ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡detach\_bufå°†å…¶æ”¾å…¥ç©ºé—²é˜Ÿåˆ—ä¸­ï¼Œç•™ç»™ä»¥åçš„å†™å…¥è¯·æ±‚ä½¿ç”¨ã€‚

è‡³æ­¤ï¼Œæ•´ä¸ªå­˜å‚¨è™šæ‹ŸåŒ–çš„å†™å…¥æµç¨‹æ‰å…¨éƒ¨å®Œæˆã€‚

## æ€»ç»“æ—¶åˆ»

ä¸‹é¢æˆ‘ä»¬æ¥æ€»ç»“ä¸€ä¸‹å­˜å‚¨è™šæ‹ŸåŒ–çš„åœºæ™¯ä¸‹ï¼Œæ•´ä¸ªå†™å…¥çš„è¿‡ç¨‹ã€‚

- åœ¨è™šæ‹Ÿæœºé‡Œé¢ï¼Œåº”ç”¨å±‚è°ƒç”¨writeç³»ç»Ÿè°ƒç”¨å†™å…¥æ–‡ä»¶ã€‚
- writeç³»ç»Ÿè°ƒç”¨è¿›å…¥è™šæ‹Ÿæœºé‡Œé¢çš„å†…æ ¸ï¼Œç»è¿‡VFSï¼Œé€šç”¨å—è®¾å¤‡å±‚ï¼ŒI/Oè°ƒåº¦å±‚ï¼Œåˆ°è¾¾å—è®¾å¤‡é©±åŠ¨ã€‚
- è™šæ‹Ÿæœºé‡Œé¢çš„å—è®¾å¤‡é©±åŠ¨æ˜¯virtio\_blkï¼Œå®ƒå’Œé€šç”¨çš„å—è®¾å¤‡é©±åŠ¨ä¸€æ ·ï¼Œæœ‰ä¸€ä¸ªrequest queueï¼Œå¦å¤–æœ‰ä¸€ä¸ªå‡½æ•°make\_request\_fnä¼šè¢«è®¾ç½®ä¸ºblk\_mq\_make\_requestï¼Œè¿™ä¸ªå‡½æ•°ç”¨äºå°†è¯·æ±‚æ”¾å…¥é˜Ÿåˆ—ã€‚
- è™šæ‹Ÿæœºé‡Œé¢çš„å—è®¾å¤‡é©±åŠ¨æ˜¯virtio\_blkä¼šæ³¨å†Œä¸€ä¸ªä¸­æ–­å¤„ç†å‡½æ•°vp\_interruptã€‚å½“qemuå†™å…¥å®Œæˆä¹‹åï¼Œå®ƒä¼šé€šçŸ¥è™šæ‹Ÿæœºé‡Œé¢çš„å—è®¾å¤‡é©±åŠ¨ã€‚
- blk\_mq\_make\_requestæœ€ç»ˆè°ƒç”¨virtqueue\_addï¼Œå°†è¯·æ±‚æ·»åŠ åˆ°ä¼ è¾“é˜Ÿåˆ—virtqueueä¸­ï¼Œç„¶åè°ƒç”¨virtqueue\_notifyé€šçŸ¥qemuã€‚
- åœ¨qemuä¸­ï¼Œæœ¬æ¥è™šæ‹Ÿæœºæ­£å¤„äºKVM\_RUNçš„çŠ¶æ€ï¼Œä¹Ÿå³å¤„äºå®¢æˆ·æœºçŠ¶æ€ã€‚
- qemuæ”¶åˆ°é€šçŸ¥åï¼Œé€šè¿‡VM exitæŒ‡ä»¤é€€å‡ºå®¢æˆ·æœºçŠ¶æ€ï¼Œè¿›å…¥å®¿ä¸»æœºçŠ¶æ€ï¼Œæ ¹æ®é€€å‡ºåŸå› ï¼Œå¾—çŸ¥æœ‰I/Oéœ€è¦å¤„ç†ã€‚
- qemuè°ƒç”¨virtio\_blk\_handle\_outputï¼Œæœ€ç»ˆè°ƒç”¨virtio\_blk\_handle\_vqã€‚
- virtio\_blk\_handle\_vqé‡Œé¢æœ‰ä¸€ä¸ªå¾ªç¯ï¼Œåœ¨å¾ªç¯ä¸­ï¼Œvirtio\_blk\_get\_requestå‡½æ•°ä»ä¼ è¾“é˜Ÿåˆ—ä¸­æ‹¿å‡ºè¯·æ±‚ï¼Œç„¶åè°ƒç”¨virtio\_blk\_handle\_requestå¤„ç†è¯·æ±‚ã€‚
- virtio\_blk\_handle\_requestä¼šè°ƒç”¨blk\_aio\_pwritevï¼Œé€šè¿‡BlockBackendé©±åŠ¨å†™å…¥qcow2æ–‡ä»¶ã€‚
- å†™å…¥å®Œæ¯•ä¹‹åï¼Œvirtio\_blk\_req\_completeä¼šè°ƒç”¨virtio\_notifyé€šçŸ¥è™šæ‹Ÿæœºé‡Œé¢çš„é©±åŠ¨ã€‚æ•°æ®å†™å…¥å®Œæˆï¼Œåˆšæ‰æ³¨å†Œçš„ä¸­æ–­å¤„ç†å‡½æ•°vp\_interruptä¼šæ”¶åˆ°è¿™ä¸ªé€šçŸ¥ã€‚

![](https://static001.geekbang.org/resource/image/79/0c/79ad143a3149ea36bc80219940d7d00c.jpg?wh=2503%2A5023)

## è¯¾å ‚ç»ƒä¹ 

è¯·ä½ æ²¿ç€ä»£ç ï¼Œä»”ç»†åˆ†æå¹¶ç‰¢è®°virtqueueçš„ç»“æ„ä»¥åŠå†™å…¥å’Œè¯»å–æ–¹å¼ã€‚è¿™ä¸ªç»“æ„åœ¨ä¸‹é¢çš„ç½‘ç»œä¼ è¾“è¿‡ç¨‹ä¸­ï¼Œè¿˜è¦èµ·å¤§ä½œç”¨ã€‚

æ¬¢è¿ç•™è¨€å’Œæˆ‘åˆ†äº«ä½ çš„ç–‘æƒ‘å’Œè§è§£ï¼Œä¹Ÿæ¬¢è¿æ”¶è—æœ¬èŠ‚å†…å®¹ï¼Œåå¤ç ”è¯»ã€‚ä½ ä¹Ÿå¯ä»¥æŠŠä»Šå¤©çš„å†…å®¹åˆ†äº«ç»™ä½ çš„æœ‹å‹ï¼Œå’Œä»–ä¸€èµ·å­¦ä¹ å’Œè¿›æ­¥ã€‚

![](https://static001.geekbang.org/resource/image/8c/37/8c0a95fa07a8b9a1abfd394479bdd637.jpg?wh=1110%2A659)
<div><strong>ç²¾é€‰ç•™è¨€ï¼ˆ5ï¼‰</strong></div><ul>
<li><span>æ²¡å¿ƒæ²¡è‚º</span> ğŸ‘ï¼ˆ17ï¼‰ ğŸ’¬ï¼ˆ2ï¼‰<p>æ¯æ¬¡çœ‹åˆ°æ–‡ä¸­è¯´è¿˜è®°å¾—ä»€ä¹ˆä»€ä¹ˆå—ï¼Œæˆ‘å¿ƒé‡Œæ€»æ˜¯é»˜é»˜å›ç­”:ä¸ è®° å¾—ğŸ˜‚</p>2019-07-31</li><br/><li><span>Adam Lau</span> ğŸ‘ï¼ˆ13ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>å¦ç™½è¯´ï¼Œè¿™æ˜¯æå®¢ä¸ŠæŠ€æœ¯å«é‡æœ€å¥½çš„ä¸“æ äº†ï¼Œå¬ä¸æ‡‚äº†ï¼Œä½†æ˜¯è¡¨ç¤ºæ•¬æ„ã€‚</p>2020-04-17</li><br/><li><span>williamcai</span> ğŸ‘ï¼ˆ3ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>è°ƒç”¨é“¾æ¡å¥½é•¿ï¼Œçªç„¶æ¥ä¸ªå›é©¬æªï¼Œä¸€ä¸‹å­æ€åˆ°å¼€å§‹çš„åœ°æ–¹
</p>2019-12-23</li><br/><li><span>shangyu</span> ğŸ‘ï¼ˆ3ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>è€å¸ˆèƒ½ä¸èƒ½è§£é‡Šä¸‹è¿™ç§ç‰¹æ®Šçš„é©±åŠ¨æ¨¡å¼ä¸ç›´æ¥ç¿»è¯‘writeè¯·æ±‚çš„æ€§èƒ½å·®å¼‚</p>2019-12-23</li><br/><li><span>è¿½é£ç­çš„äºº</span> ğŸ‘ï¼ˆ1ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>å¥½å¤æ‚é¸­</p>2019-11-26</li><br/>
</ul>