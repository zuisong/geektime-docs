ä½ å¥½ï¼Œæˆ‘æ˜¯ç‹äº‰ã€‚åˆäºŒå¥½ï¼

ä¸ºäº†å¸®ä½ å·©å›ºæ‰€å­¦ï¼ŒçœŸæ­£æŒæ¡æ•°æ®ç»“æ„å’Œç®—æ³•ï¼Œæˆ‘æ•´ç†äº†æ•°æ®ç»“æ„å’Œç®—æ³•ä¸­ï¼Œå¿…çŸ¥å¿…ä¼šçš„30ä¸ªä»£ç å®ç°ï¼Œåˆ†7å¤©å‘å¸ƒå‡ºæ¥ï¼Œä¾›ä½ å¤ä¹ å·©å›ºæ‰€ç”¨ã€‚ä»Šå¤©æ˜¯ç¬¬äºŒç¯‡ã€‚

å’Œæ˜¨å¤©ä¸€æ ·ï¼Œä½ å¯ä»¥èŠ±ä¸€ç‚¹æ—¶é—´ï¼Œæ¥å®Œæˆæµ‹éªŒã€‚æµ‹éªŒå®Œæˆåï¼Œä½ å¯ä»¥æ ¹æ®ç»“æœï¼Œå›åˆ°ç›¸åº”ç« èŠ‚ï¼Œæœ‰é’ˆå¯¹æ€§åœ°è¿›è¡Œå¤ä¹ ã€‚

* * *

## å…³äºæ ˆã€é˜Ÿåˆ—å’Œé€’å½’çš„å‡ ä¸ªå¿…çŸ¥å¿…ä¼šçš„ä»£ç å®ç°

### æ ˆ

- ç”¨æ•°ç»„å®ç°ä¸€ä¸ªé¡ºåºæ ˆ
- ç”¨é“¾è¡¨å®ç°ä¸€ä¸ªé“¾å¼æ ˆ
- ç¼–ç¨‹æ¨¡æ‹Ÿå®ç°ä¸€ä¸ªæµè§ˆå™¨çš„å‰è¿›ã€åé€€åŠŸèƒ½

### é˜Ÿåˆ—

- ç”¨æ•°ç»„å®ç°ä¸€ä¸ªé¡ºåºé˜Ÿåˆ—
- ç”¨é“¾è¡¨å®ç°ä¸€ä¸ªé“¾å¼é˜Ÿåˆ—
- å®ç°ä¸€ä¸ªå¾ªç¯é˜Ÿåˆ—

### é€’å½’

- ç¼–ç¨‹å®ç°æ–æ³¢é‚£å¥‘æ•°åˆ—æ±‚å€¼f(n)=f(n-1)+f(n-2)
- ç¼–ç¨‹å®ç°æ±‚é˜¶ä¹˜n!
- ç¼–ç¨‹å®ç°ä¸€ç»„æ•°æ®é›†åˆçš„å…¨æ’åˆ—

## å¯¹åº”çš„LeetCodeç»ƒä¹ é¢˜ï¼ˆ@Smallfly æ•´ç†ï¼‰

### æ ˆ

- Valid Parenthesesï¼ˆæœ‰æ•ˆçš„æ‹¬å·ï¼‰

è‹±æ–‡ç‰ˆï¼š[https://leetcode.com/problems/valid-parentheses/](https://leetcode.com/problems/valid-parentheses/)

ä¸­æ–‡ç‰ˆï¼š[https://leetcode-cn.com/problems/valid-parentheses/](https://leetcode-cn.com/problems/valid-parentheses/)

- Longest Valid Parenthesesï¼ˆæœ€é•¿æœ‰æ•ˆçš„æ‹¬å·ï¼‰

è‹±æ–‡ç‰ˆï¼š[https://leetcode.com/problems/longest-valid-parentheses/](https://leetcode.com/problems/longest-valid-parentheses/)

ä¸­æ–‡ç‰ˆï¼š[https://leetcode-cn.com/problems/longest-valid-parentheses/](https://leetcode-cn.com/problems/longest-valid-parentheses/)

- Evaluate Reverse Polish Notatioï¼ˆé€†æ³¢å…°è¡¨è¾¾å¼æ±‚å€¼ï¼‰

è‹±æ–‡ç‰ˆï¼š[https://leetcode.com/problems/evaluate-reverse-polish-notation/](https://leetcode.com/problems/evaluate-reverse-polish-notation/)

ä¸­æ–‡ç‰ˆï¼š[https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/)

### é˜Ÿåˆ—

- Design Circular Dequeï¼ˆè®¾è®¡ä¸€ä¸ªåŒç«¯é˜Ÿåˆ—ï¼‰

è‹±æ–‡ç‰ˆï¼š[https://leetcode.com/problems/design-circular-deque/](https://leetcode.com/problems/design-circular-deque/)

ä¸­æ–‡ç‰ˆï¼š[https://leetcode-cn.com/problems/design-circular-deque/](https://leetcode-cn.com/problems/design-circular-deque/)

- Sliding Window Maximumï¼ˆæ»‘åŠ¨çª—å£æœ€å¤§å€¼ï¼‰

è‹±æ–‡ç‰ˆï¼š[https://leetcode.com/problems/sliding-window-maximum/](https://leetcode.com/problems/sliding-window-maximum/)

ä¸­æ–‡ç‰ˆï¼š[https://leetcode-cn.com/problems/sliding-window-maximum/](https://leetcode-cn.com/problems/sliding-window-maximum/)

### é€’å½’

- Climbing Stairsï¼ˆçˆ¬æ¥¼æ¢¯ï¼‰

è‹±æ–‡ç‰ˆï¼š[https://leetcode.com/problems/climbing-stairs/](https://leetcode.com/problems/climbing-stairs/)

ä¸­æ–‡ç‰ˆï¼š[https://leetcode-cn.com/problems/climbing-stairs/](https://leetcode-cn.com/problems/climbing-stairs/)

* * *

æ˜¨å¤©çš„ç¬¬ä¸€ç¯‡ï¼Œæ˜¯å…³äºæ•°ç»„å’Œé“¾è¡¨çš„ï¼Œå¦‚æœä½ é”™è¿‡äº†ï¼Œç‚¹å‡»æ–‡æœ«çš„â€œä¸Šä¸€ç¯‡â€ï¼Œå³å¯è¿›å…¥æµ‹è¯•ã€‚

ç¥ä½ å–å¾—å¥½æˆç»©ï¼æ˜å¤©è§ï¼
<div><strong>ç²¾é€‰ç•™è¨€ï¼ˆ15ï¼‰</strong></div><ul>
<li><span>Abner</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>javaå®ç°ä¸€ä¸ªå¾ªç¯é˜Ÿåˆ—
ä»£ç å¦‚ä¸‹ï¼š
package queue;

public class CircularQueue {
    
    private String[] data;
    private int size;
    private int head;
    private int tail;
    
    public CircularQueue(int capacity) {
        data = new String[capacity];
        size = capacity;
        head = 0;
        tail = 0;
    }
    
    public boolean enqueue(String item) {
        if ((tail + 1) % size == head) {
            return false;
        }
        data[tail] = item;
        tail = (tail + 1) % size;
        return true;
    }

    public String dequeue() {
        if (head == tail) {
            return null;
        }
        String value = data[head];
        head = (head + 1) % size;
        return value;
    }

    public void printAll() {
        if (0 == size) {
            return ;
        }
        for (int i = head;i % size != tail;i++) {
            System.out.print(data[i] + &quot; &quot;);
        }
        System.out.println();
    }
    
    public static void main(String[] args) {
        CircularQueue circularQueue = new CircularQueue(5);
        circularQueue.enqueue(&quot;hello1&quot;);
        circularQueue.enqueue(&quot;hello2&quot;);
        circularQueue.enqueue(&quot;hello3&quot;);
        circularQueue.enqueue(&quot;hello4&quot;);
        circularQueue.dequeue();
        circularQueue.printAll();
    }
}
</p>2019-02-12</li><br/><li><span>ç¥ç›¾å±€é—¹åˆ«æ‰­</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>å…¨æ’åˆ—å®ç°ï¼š
void Dopermute(char *pstr, char *pBegin)
{
	if (*pBegin == &#39;\0&#39;)
		printf(&quot;%s\n&quot;, pstr);

	for (char *pCur = pBegin; *pCur != &#39;\0&#39;; pCur++)
	{

		char temp = *pBegin;
		*pBegin = *pCur;
		*pCur = temp;

		Dopermute_v2(pstr, pBegin + 1);

		temp = *pBegin;
		*pBegin = *pCur;
		*pCur = temp;

	}
}
void Permute(char* pstr)
{
	if (pstr == nullptr)
		return;
	Dopermute(pstr, pstr);
}</p>2019-02-09</li><br/><li><span>molybdenum</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>è€å¸ˆæ–°å¹´å¥½ è¿™æ˜¯æˆ‘çš„ä½œä¸š

https:&#47;&#47;blog.csdn.net&#47;github_38313296&#47;article&#47;details&#47;86819684</p>2019-02-09</li><br/><li><span>èœèœ</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>æ±‚æ–æ³¢é‚£å¥‘æ•°åˆ—ï¼Œå½“ç„¶æœ€ç»å…¸çš„ç®—æ³•å°±æ˜¯é€’å½’ï¼Œä½†æ˜¯é€’å½’çš„æ•ˆç‡éå¸¸ä½ï¼Œå› ä¸ºä¸­é—´è¿‡è½¦ä¼šè®¡ç®—å¤§é‡é‡å¤çš„å­èŠ‚ç‚¹ã€‚åœ¨ã€Šå‰‘æŒ‡Offerã€‹ä¸€ä¹¦ä¸­ï¼Œæåˆ°äº†ä¸€ä¸ªè‡ªä¸‹è€Œä¸Šè®¡ç®—çš„æ–¹æ³•ã€‚æˆ‘ä»¬çŸ¥é“f(0)=0,f(1)=1,å†è®¡ç®—f(2),f(3)ä¸€ç›´åˆ°f(n)ã€‚è¿™æ ·ï¼Œæ—¶é—´å¤æ‚åº¦å°±æ˜¯O(n)ã€‚</p>2019-02-06</li><br/><li><span>æçš®çš®çš®çš®çš®</span> ğŸ‘ï¼ˆ11ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>åŸºç¡€æ•°æ®ç»“æ„å’Œç®—æ³•æ˜¯åŸºçŸ³ï¼Œçµæ´»è¿ç”¨æ˜¯è§£é¢˜çš„å…³é”®ã€‚æ ˆï¼Œé˜Ÿåˆ—è¿™äº›æ•°æ®ç»“æ„è¯´åˆ°åº•å°±æ˜¯ç»™é¡ºåºè¡¨æ·»åŠ çº¦æŸï¼Œæ›´ä¾¿äºè§£å†³æŸä¸€ç±»é—®é¢˜ã€‚å­¦ä¹ ä¸­åŸ¹å…»ç®—æ³•çš„è®¾è®¡æ€æƒ³æ˜¯éå¸¸å…³é”®çš„ã€‚è€Œä¸”æ€æƒ³æ˜¯å¯ä»¥é€šç”¨çš„ã€‚ä¹‹å‰è¯»ã€Šæš—æ—¶é—´ã€‹ä¸€ä¹¦ï¼Œæ”¶è·é¢‡æ·±ã€‚ä¹¦ä¸­ä»‹ç»ä¹‹æ­£æ¨åæ¨æˆ‘åœ¨åšç¨‹åºé¢˜æ—¶ç«Ÿå‡ºå¥‡çš„å¥½ç”¨ã€‚</p>2019-02-05</li><br/><li><span>Abner</span> ğŸ‘ï¼ˆ3ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>javaç”¨æ•°ç»„å®ç°ä¸€ä¸ªé¡ºåºæ ˆ
ä»£ç å¦‚ä¸‹ï¼š
package stack;

public class ArrayStack {

    private String[] data;
    private int count;
    private int size;

    public ArrayStack(int n) {
        this.data = new String[n];
        this.count = 0;
        this.size = n;
    }
    
    public boolean push(String value) {
        if (count == size) {
            return false;
        } else {
            data[count] = value;
            count++;
            return true;
        }
    }

    public String pop() {
        if (count == 0) {
            return null;
        } else {
            count--;
            return data[count];
        }
    }
}
</p>2019-02-11</li><br/><li><span>Abner</span> ğŸ‘ï¼ˆ2ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>javaç”¨é€’å½’å®ç°æ–æ³¢é‚£å¥‘æ•°åˆ—
ä»£ç å¦‚ä¸‹ï¼š
package recursion;

public class Fib {

    public long calFib(long n) {
        if (n == 0 || n == 1) {
            return 1;
        } else {
            return calFib(n - 1) + calFib(n - 2);
        }
    }
    
    public static void main(String[] args) {
        Fib fib = new Fib();
        long result = fib.calFib(5);
        System.out.println(result);
    }
}
</p>2019-02-11</li><br/><li><span>Abner</span> ğŸ‘ï¼ˆ2ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>javaç”¨é€’å½’å®ç°æ±‚è§£n!
ä»£ç å¦‚ä¸‹ï¼š
package recursion;

public class Fac {

    public long calFac(long n) {
        if (n == 0) {
            return 1;
        } 
        return calFac(n - 1) * n;
    }

    public static void main(String[] args) {
        Fac fac = new Fac();
        long result = fac.calFac(10);
        System.out.println(result);
    }
}</p>2019-02-11</li><br/><li><span>kai</span> ğŸ‘ï¼ˆ2ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>1. ç¼–ç¨‹å®ç°æ–æ³¢é‚£å¥‘æ•°åˆ—æ±‚å€¼ f(n)=f(n-1)+f(n-2ï¼‰
public class Fibonacci {
    public static int fib(int n) {
        if (n &lt;= 0) {
            return 0;
        }
        if (n == 1) {
            return 1;
        }

        return  fib(n-1) + fib(n-2);
    }
}

2. Climbing Stairsï¼ˆçˆ¬æ¥¼æ¢¯ï¼‰
public class ClimbStairs {
    public int climbFloor(int n) {
        if (n == 1 || n == 2) {
            return n;
        }

        return climbFloor(n - 1) + climbFloor(n - 2);
    }

    public int climbFloorIter(int n) {
        if (n == 1 || n == 2) {
            return n;
        }

        int jump1 = 1;
        int jump2 = 2;
        int jumpN = 0;

        for (int i = 3; i &lt;= n; i++) {
            jumpN = jump1 + jump2;

            jump1 = jump2;
            jump2 = jumpN;
        }

        return jumpN;
    }
}

3. Sliding Window Maximumï¼ˆæ»‘åŠ¨çª—å£æœ€å¤§å€¼)
import java.util.ArrayList;
import java.util.LinkedList;

public class MaxNumOfSlidingWindow {
    public ArrayList&lt;Integer&gt; maxInWindows(int [] num, int size)
    {
        ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;();

        if (num == null || num.length &lt;= 0 || size &lt;= 0 || size &gt; num.length) {
            return res;
        }

        LinkedList&lt;Integer&gt; qMax = new LinkedList&lt;&gt;();  &#47;&#47; åŒç«¯é˜Ÿåˆ—ï¼šå·¦ç«¯æ›´æ–°max,å³ç«¯æ·»åŠ æ•°æ®

        int left = 0;

        for (int right = 0; right &lt; num.length; right++) {
            &#47;&#47; æ›´æ–°å³ç«¯æ•°æ®
            while (!qMax.isEmpty() &amp;&amp; num[qMax.peekLast()] &lt;= num[right]) {
                qMax.pollLast();
            }

            qMax.addLast(right);

            &#47;&#47; æ›´æ–°maxï¼šå¦‚æœmaxçš„ç´¢å¼•ä¸åœ¨çª—å£å†…,åˆ™æ›´æ–°
            if (qMax.peekFirst() == right - size) {
                qMax.pollFirst();
            }

            &#47;&#47; å¾…çª—å£è¾¾åˆ°sizeï¼Œè¾“å‡ºmax
            if (right &gt;= size-1) {
                res.add(num[qMax.peekFirst()]);
                left++;
            }
        }

        return res;
    }
}</p>2019-02-11</li><br/><li><span>Abner</span> ğŸ‘ï¼ˆ1ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>javaç”¨é“¾è¡¨å®ç°ä¸€ä¸ªé“¾å¼æ ˆ
ä»£ç å¦‚ä¸‹ï¼š
package stack;

public class LinkedStack {
    
    private Node top = null;
    
    public static class Node {
        
        private String data;
        private Node next;
        
        public Node(String data, Node next) {
            this.data = data;
            this.next = next;
        }
        
        public String getData() {
            return data;
        }
    }
    
    public void push(String item) {
        Node newNode = new Node(item, null);
        if (top == null) {
            top = newNode;
        } else {
            newNode.next = top;
            top = newNode;
        }
    }
    
    public String pop() {
        if (top == null) {
            return null;
        }
        String value = top.data;
        top = top.next;
        return value;
    }
    
    public void printAll() {
        Node pNode = top;
        while (pNode != null) {
            System.out.print(pNode.data + &quot; &quot;);
            pNode = pNode.next;
        }
        System.out.println();
    }
    
    public static void main(String[] args) {
        LinkedStack linkedStack = new LinkedStack();
        linkedStack.push(&quot;haha&quot;);
        linkedStack.push(&quot;nihao&quot;);
        linkedStack.printAll();
    }
}
</p>2019-02-12</li><br/><li><span>Abner</span> ğŸ‘ï¼ˆ1ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>javaç”¨æ•°ç»„å®ç°ä¸€ä¸ªé¡ºåºé˜Ÿåˆ—
ä»£ç å¦‚ä¸‹ï¼š
package queue;

public class ArrayQueue {
    
    private String[] data;
    private int size;
    private int head;
    private int tail;
    
    public ArrayQueue(int capacity) {
        data = new String[capacity];
        size = capacity;
        head = 0;
        tail = 0;
    }
    
    public boolean enqueue(String value) {
        if (tail == size) {
            return false;
        }
        data[tail] = value;
        tail++;
        return true;
    }

    public String dequeue() {
        if (tail == 0) {
            return null;
        }
        String value = data[head];
        head++;
        return value;
    }
}
</p>2019-02-11</li><br/><li><span>ALAN</span> ğŸ‘ï¼ˆ1ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>import java.util.Arrays;

&#47;**
 * 
 *Stack 1 solution
 *&#47;
public class StackArray {

	public Object[] arr = new Object[10];
	public int count;

	public void push(Object ele) {
		if (count == arr.length) { &#47;&#47; expand size
			arr = Arrays.copyOf(arr, arr.length * 2);
		}
		arr[count] = ele;
		count++;
	}

	public Object pop() {
		if (count == 0)
			return null;
		if (count &lt; arr.length &#47; 2) {
			arr = Arrays.copyOf(arr, arr.length &#47; 2);
		}
		return arr[--count];

	}
}

&#47;**
 * 
 *Stack 2 solution
 *&#47;
class StackLinked {
	Node head;
	Node tail;

	public void push(Object ele) {

		if (head == null) {
			head = new Node(ele);
			tail = head;
		} else {
			Node node = new Node(ele);
			tail.next = node;
			node.prev = tail;
			tail = node;
		}
	}

	public Object pop() {
		if (tail == null)
			return null;
		Node node = tail;
		if (tail == head) {
			head = null;
			tail = null;
		} else
			tail = tail.prev;
		return node;

	}
}
class Node {
	Node prev;
	Node next;
	Object value;

	public Node(Object ele) {
		value = ele;
	}
}</p>2019-02-08</li><br/><li><span>TryTs</span> ğŸ‘ï¼ˆ1ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>ä¹‹å‰æœ‰ä¸ªç±»ä¼¼çš„é¢˜ï¼Œèµ°æ¥¼æ¢¯ï¼Œè£…è‹¹æœï¼Œå°±æ˜¯æŠŠè‹¹æœè£…å…¥ç›˜å­ï¼Œå¯ä»¥åˆ†ä¸ºæœ‰ä¸€ä¸ªç›˜å­ä¸ºç©ºï¼ˆé€’å½’ï¼‰ï¼Œå’Œå…¨éƒ¨è£…æ»¡æ²¡æœ‰ç©ºçš„æƒ…å†µï¼Œæ‰¾å‡ºçŠ¶æ€æ–¹ç¨‹ï¼Œé€’å½’å°±å¯ä»¥åˆ—å‡ºæ¥äº†ã€‚æˆ‘è§‰å¾—æœ€å…³é”®æ˜¯è¦åˆ—å‡ºçŠ¶æ€æ–¹ç¨‹ï¼Œä¹‹å‰è€å¸ˆç±»ä¼¼äºè¯´çš„ä¸éœ€è¦å…³æ³¨ç‰¹åˆ«ç»†èŠ‚ï¼Œä¸è¦æƒ³æŠŠæ¯ä¸€æ­¥éƒ½è¦æƒ³æ˜ç™½ï¼Œå¿«é€Ÿæ’åºä¸é€’å½’æ’åºä¹‹ç±»çš„ç®—æ³•ï¼Œä¹‹å‰æ€»æ˜¯æƒ³æŠŠå¾ˆç»†èŠ‚çš„å¼„æ‡‚ï¼Œå´å‘ç°ç†è§£æœ‰å›°éš¾ã€‚</p>2019-02-06</li><br/><li><span>æ¨å»ºæ–Œ(young)</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>æ»‘åŠ¨çª—å£æœ€å¤§å€¼
public static void main(String[] args) {

        PriorityQueue&lt;Integer[]&gt; queue = new PriorityQueue(3, new Comparator&lt;Integer[]&gt;() {
            @Override
            public int compare(Integer[] o1, Integer[] o2) {
                if (o1[0] == o2[0]) {
                    return o2[1] - o1[1];
                }
                return o2[0] - o1[0];
            }
        });

        int[] nums = new int[]{7, 3, -1, -3, 5, 3, 6, 7};
        for (int i = 0; i &lt; 3; i++) {
            queue.add(new Integer[]{nums[i], i});
        }

        int[] ret = new int[nums.length - 3 + 1];
        ret[0] = queue.peek()[0];
        for (int i = 3; i &lt; nums.length; i++) {
            queue.add(new Integer[]{nums[i], i});
            if (queue.peek()[1] &lt; i - 3 + 1) {
                queue.poll();
            }
            ret[i - 3 + 1] = queue.peek()[0];
        }

        System.out.println(ret);


    }</p>2023-06-29</li><br/><li><span>æ¨å»ºæ–Œ(young)</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>åŒç«¯é˜Ÿåˆ—
    static class MyCircularDeque {
        private int[] elements;
        &#47;&#47;è·å¾—åŒç«¯é˜Ÿåˆ—çš„æœ€årearä¸€ä¸ªå…ƒç´ 

        private int rear, front;
        &#47;&#47;å†…å®¹ä¸ªæ•°
        private int capacity;

       

        public boolean insertFront(int value) {
            if (elements.length == capacity) {
                return false;
            }
            if (capacity == 0) {
                rear = front = 0;
            } else {
                front = front - 1;
                if (front &lt; 0) {
                    front += elements.length;
                }
            }
            elements[front] = value;
            capacity++;
            return true;
        }

        public boolean insertLast(int value) {
            if (elements.length == capacity) {
                return false;
            }
            if (capacity == 0) {
                rear = front = 0;
            } else {
                rear = (rear + 1) % elements.length;
            }
            elements[rear] = value;
            capacity++;
            return true;
        }

        public boolean deleteFront() {
            if (capacity == 0) {
                return false;
            }
            int idx = front;
            front = front + 1;
            if (front &gt; elements.length) {
                front = 0;
            }
            elements[idx] = -1;
            capacity--;
            return true;
        }

        public boolean deleteLast() {
            if (capacity == 0) {
                return false;
            }
            int idx = rear;
            rear = rear - 1;
            elements[idx] = -1;
            capacity--;
            return true;
        }

        public int getFront() {
            if (front != -1) {
                return elements[front];
            }
            return -1;
        }

        public int getRear() {
            if (rear != -1) {
                return elements[rear];
            }
            return -1;
        }
    }</p>2023-06-29</li><br/>
</ul>