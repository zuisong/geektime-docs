æˆ‘ä»¬åœ¨å‰é¢è®¨è®ºäº†è¯¥æ€ä¹ˆå–ä¸€ä¸ªå¥½åå­—ã€‚åœ¨ç¼–ç¨‹è¯­è¨€é‡Œï¼Œæˆ‘ä»¬ä½¿ç”¨æ ‡è¯†ç¬¦æ¥è¡¨ç¤ºä¸åŒçš„é€»è¾‘å’Œå¯¹è±¡ã€‚å£°æ˜å°±æ˜¯ç”¨æ¥å®šä¹‰è¿™äº›æ ‡è¯†ç¬¦çš„ã€‚æ ‡è¯†ç¬¦å£°æ˜çš„åœ°æ–¹ï¼Œå°±æ˜¯å–åå­—å’Œç¬¬ä¸€æ¬¡ä½¿ç”¨åå­—çš„åœ°æ–¹ã€‚è¿™ä¸€æ¬¡ï¼Œæˆ‘ä»¬èŠä¸€èŠè¯¥æ€ä¹ˆå£°æ˜ä¸€ä¸ªæ ‡è¯†ç¬¦ã€‚

â€œå£°æ˜â€æ˜¯æˆ‘ä»¬å’Œæ ‡è¯†ç¬¦åˆæ¬¡è§é¢çš„åœ°æ–¹ï¼Œç¬¬ä¸€å°è±¡å°±æ˜¾å¾—ç‰¹åˆ«é‡è¦ã€‚å¦‚æœæˆ‘ä»¬å¿˜è®°äº†ï¼Œå›å¤´èƒ½å¤Ÿæ¸…æ™°åœ°æ‰¾åˆ°å®ƒï¼Œä¹Ÿå¾ˆé‡è¦ã€‚å¦‚æœæˆ‘ä»¬å°è±¡æ¨¡ç³Šäº†ï¼Œå›å¤´èƒ½å¤Ÿé‡æ–°è®¤è¯†å®ƒï¼Œå¯¹äºæˆ‘ä»¬é˜…è¯»ç¨‹åºä¹Ÿæœ‰å¾ˆå¤§çš„å¸®åŠ©ã€‚

ä¸€ä¸ªæ ‡è¯†ç¬¦ï¼Œä¸ä»…ä»…åªæ˜¯ä¸€ä¸ªåå­—ã€‚ åƒäººåˆ†ç”·å¥³ã€é«˜çŸ®èƒ–ç˜¦ä¸€æ ·ï¼Œæ ‡è¯†ç¬¦ä¹Ÿå¯ä»¥æœ‰é™„åŠ ä¿¡æ¯ï¼Œç”¨æ¥å¢å¼ºäººä»¬å¯¹å®ƒçš„è®¤è¯†ã€‚

ä¸€ä¸ªå£°æ˜ï¼Œä¸€èˆ¬è‡³å°‘åŒ…å«ä¸¤ä¸ªéƒ¨åˆ†ï¼Œä¸€ä¸ªæ˜¯æ ‡è¯†ç¬¦çš„åå­—ï¼Œä¸€ä¸ªæ˜¯æ ‡è¯†ç¬¦çš„ç±»å‹ã€‚ æ¯”å¦‚ï¼š

```
int size;
```

æœ‰çš„å£°æ˜ï¼Œè¿˜æœ‰ä¿®é¥°å’Œé™å®šéƒ¨åˆ†ï¼Œæ¯”å¦‚Javaçš„è®¿é—®æ§åˆ¶ä¿®é¥°ç¬¦ï¼ˆprivateï¼Œpublicç­‰ï¼‰ï¼š

```
private int size;
```

æˆ–è€…Cè¯­è¨€çš„å­˜å‚¨ç±»åˆ«é™å®šç¬¦ï¼ˆautoï¼Œexternç­‰ï¼‰ï¼š

```
auto int size;
```

å†™å£°æ˜å¾ˆç®€å•ï¼Œä½†å†™å¥½å£°æ˜ä¹Ÿå¹¶éæ˜“äº‹ã€‚æˆ‘ä»¬ä»¥Javaè¯­è¨€ä¸ºä¾‹æ¥è®¨è®ºå£°æ˜çš„ç¼–ç é£æ ¼ã€‚åœ¨Javaè¯­è¨€é‡Œï¼Œå£°æ˜å¯ä»¥ç”¨æ¥å®šä¹‰ç±»ã€æ–¹æ³•ã€ç±»å˜é‡ã€å±€éƒ¨å˜é‡å’Œå¸¸é‡ã€‚ä¸åŒå£°æ˜çš„è¯­æ³•æœ‰ç€å·¨å¤§çš„å·®åˆ«ï¼Œä½†æ˜¯ä¹Ÿæœ‰å¾ˆå¤šå…±é€šçš„åœ°æ–¹ï¼Œä½ å¯ä»¥æŠŠè¿™äº›æ€è·¯ç”¨åœ¨è‡ªå·±ç†Ÿæ‚‰çš„è¯­è¨€ä¸Šã€‚
<div><strong>ç²¾é€‰ç•™è¨€ï¼ˆ17ï¼‰</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/0f/88/c8/6af6d27e.jpg" width="30px"><span>Y024</span> ğŸ‘ï¼ˆ9ï¼‰ ğŸ’¬ï¼ˆ2ï¼‰<div>ä»£ç å›¾ç‰‡å»ºè®®ç”¨ carbon ç¾åŒ–ä¸‹ï¼Œå¯è¯»æ€§ä¼šæ›´å¥½ï¼šï¼‰

https:&#47;&#47;carbon.now.sh&#47;</div>2019-01-29</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/ibZVAmmdAibBeVpUjzwId8ibgRzNk7fkuR5pgVicB5mFSjjmt2eNadlykVLKCyGA0GxGffbhqLsHnhDRgyzxcKUhjg/132" width="30px"><span>pyhhou</span> ğŸ‘ï¼ˆ4ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<div>ç¬¬28ï¼Œ29ï¼Œ39ï¼Œ40ï¼Œ44è¡Œç›¸å¯¹åº”å¸¦ä¸Šå¤§æ‹¬å·ä¼šæ›´å¥½
ç¬¬39ï¼Œ40ï¼Œ44è¡Œå±äºä¸€è¡Œè¡¨ç¤ºå¤šé‡è¡Œä¸ºï¼Œä¸ä¾¿äºè§‚å¯Ÿå’Œç†è§£ï¼Œæ¢è¡Œä¼šæ›´å¥½
ç¬¬28ï¼Œ31ï¼Œ36ï¼Œ42ï¼Œ47è¡Œçš„ä»£ç ä¸å‰é¢çš„ä»£ç æ²¡æœ‰å¾ˆå¥½çš„åˆ†å—ï¼Œæ„æˆä¸äº†è§†è§‰ä¸Šé¢æ¸…æ™°çš„ä»£ç å—ï¼Œåœ¨å‰é¢åŠ ä¸Šç©ºè¡Œä¼šæ›´å¥½
ç¬¬35è¡Œå‘½åä¸å¤Ÿæ¸…æ™°ï¼Œä¿®æ”¹ä¸ºMap&lt;Character, Character&gt; charMapping = new HashMap&lt;&gt;();
ç¬¬29è¡Œï¼Œå°±åƒå‰é¢ @èƒŒç€å‰ä»–çš„å¤§æ¼ ç‹¼ åŒå­¦è¯´çš„ï¼Œif é‡Œé¢çš„ match å‡½æ•°å…¶å®è¡¨ç¤ºçš„æ„ä¹‰ä¸å¤ªæ˜ç¡®ï¼Œè¯»è€…éœ€è¦å»çœ‹ match å‡½æ•°çš„å¤§è‡´å®ç°ï¼Œå¦‚æœåœ¨æ­¤ä¹‹å‰å®šä¹‰ä¸€ä¸ªboolean isMatched = match(word, pattern); å†å°† isMatched æ”¾åˆ° if é‡Œé¢ä¼šå¥½å¾ˆå¤šï¼›è€Œä¸”æŠŠå‡½æ•°ç›´æ¥æ”¾åœ¨ if è¯­å¥é‡Œé¢å…¶å®ä¹Ÿè¿åäº†æˆ‘ä»¬ä¹‹å‰æåˆ°çš„å•è¡Œå•ä¸€è¡Œä¸ºçš„åŸåˆ™ï¼Œå› ä¸ºè¿è¡Œå‡½æ•°è¿”å›ç»“æœå’Œè¡¨è¾¾å¼æ¡ä»¶åˆ¤æ–­åœ¨æ¦‚å¿µä¸Šæœ¬å°±æ˜¯ä¸¤ä¸ªå®Œå…¨ä¸åŒçš„è¡Œä¸º

èƒ½çœ‹åˆ°çš„å°±è¿™äº›äº†ï¼Œä¸è¶³ä¹‹å¤„è¿˜è¯·è€å¸ˆå’Œå¤§ç¥ä»¬è¡¥å……</div>2019-01-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/0b/4e/fd946cb2.jpg" width="30px"><span>allean</span> ğŸ‘ï¼ˆ4ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<div>ç»†èŠ‚æ— å°äº‹ï¼Œé«˜æ‰‹ä¸æ˜¯æŒæ¡äº†é™é¾™åå…«æŒï¼Œè€Œæ˜¯ç®€å•çš„äº‹ä¹Ÿèƒ½åšåˆ°æè‡´ï¼Œå­¦ä¹ äº†ã€‚</div>2019-01-21</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/13/0b/e6/b626aa9c.jpg" width="30px"><span>Lindroid</span> ğŸ‘ï¼ˆ2ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<div>lengthæ–¹æ³•ç›´æ¥å†™åœ¨forå¾ªç¯è¯­å¥ä¸­ä¼šä¸ä¼šä¸æ˜¯å¾ˆå¥½å‘¢ï¼Ÿå› ä¸ºè¿™æ ·æ¯æ¬¡å¾ªç¯éƒ½ä¼šè°ƒç”¨å®ƒå»è·å–wordå­—ç¬¦çš„é•¿åº¦ï¼Œæ‰€ä»¥æˆ‘è§‰å¾—å¯ä»¥åœ¨forå¾ªç¯ç›´æ¥å£°æ˜ä¸€ä¸ªå˜é‡ï¼Œå€¼å°±æ˜¯wordçš„å­—ç¬¦é•¿åº¦ï¼š
        int wordLength = word.length();
        for (int i = 0; i &lt; wordLength; i++) {
           â€¦â€¦
        }</div>2019-01-31</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/79/69/5960a2af.jpg" width="30px"><span>ç‹æ™º</span> ğŸ‘ï¼ˆ2ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<div>```
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

class Solution {
    &#47;**
     * Return a list of the words in words that match the given pattern.
     *
     * A word matches the pattern if there exists a permutation of
     * letters p so that after replacing every letter x in the pattern
     * with p(x), we get the desired word.
     *
     * Example:
     *     Input: words = [&quot;abc&quot;,&quot;deq&quot;,&quot;mee&quot;,&quot;aqq&quot;,&quot;dkd&quot;,&quot;ccc&quot;],
     *            pattern = &quot;abb&quot;
     *     Output: [&quot;mee&quot;,&quot;aqq&quot;]
     *
     *     Explanation: &quot;mee&quot; matches the pattern because there is
     *         a permutation {a -&gt; m, b -&gt; e, ...}.
     *
     *        &quot;ccc&quot; does not match the pattern because
     *        {a -&gt; c, b -&gt; c, ...} is not a permutation, since a
     *        and b map to the same letter.
     *&#47;
    public List&lt;String&gt; findAndReplacePattern(String[] words, String pattern) {
        List&lt;String&gt; ans = new ArrayList();
        for (String word : words) {
            if (match(word, pattern)) {
                ans.add(word);
            }
        }
        return ans;
    }

    public boolean match(String word, String pattern) {
        Map&lt;Character, Character&gt; M = new HashMap();
        for (int i = 0; i &lt; word.length(); ++i) {
            char w = word.charAt(i);
            char p = pattern.charAt(i);
            if (!M.containsKey(w)) {
                M.put(w, p);
            }
            if (M.get(w) != p) {
                return false;
            }
        }
        boolean[] seen = new boolean[26];
        for (char p : M.values()) {
            if (seen[p - &#39;a&#39;]) {
                return false;
            }
            seen[p - &#39;a&#39;] = true;
        }
        return true;
    }
}
```
æ”¹æˆæˆ‘å–œæ¬¢çš„æ ¼å¼,è™½ç„¶ä¸ä¸€å®šå‡†ç¡®,ä½†æ˜¯è‡ªå·±çœ‹ä¸Šå»èˆ’æœå¾ˆå¤š </div>2019-01-21</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/f7/c4/bd7dd30a.jpg" width="30px"><span>å°æ–‡</span> ğŸ‘ï¼ˆ1ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<div>è¿˜æƒ³é—®ä¸ªé—®é¢˜å°±æ˜¯c++å¾—æˆå‘˜å˜é‡åˆå§‹åŒ–å¯ä»¥å†å£°æ˜çš„æ—¶å€™åˆå§‹åŒ–ä¹Ÿå¯ä»¥åœ¨æ„é€ å‡½æ•°åˆå§‹åŒ–ï¼Œé‚£å“ªç§æ¯”è¾ƒå¥½å‘¢</div>2019-02-15</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/00/dc/165a601f.jpg" width="30px"><span>èƒŒç€å‰ä»–çš„å¤§æ¼ ç‹¼</span> ğŸ‘ï¼ˆ1ï¼‰ ğŸ’¬ï¼ˆ2ï¼‰<div>1ï¼Œifè¯­å¥å°½é‡ä¸è¦æ¶‰åŠå¤æ‚çš„è¡¨è¾¾å¼ï¼Œå¯ä»¥ç”¨å±€éƒ¨å˜é‡ç”³æ˜å‡ºæ¥
2ï¼Œä¾‹å­ä¸­æœ‰äº›è®¸çš„ä¸åŒè¯­ä¹‰çš„å¸è½½äº†åŒä¸€è¡Œï¼Œå†™æ²¡å¾ˆå¥½ä½¿ç”¨èŠ±æ‹¬å·
3ï¼Œæ–¹æ³•ä½“å†…å¯ä»¥å°†ç”³æ˜éƒ¨åˆ†ä¸é€»è¾‘éƒ¨åˆ†ä½¿ç”¨ç©ºè¡ŒåŠ å¼ºé˜…è¯»ç†è§£</div>2019-01-21</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg" width="30px"><span>Demon.Lee</span> ğŸ‘ï¼ˆ1ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<div>è€å¸ˆï¼Œå£°æ˜æ—¶å°±åˆå§‹åŒ–ï¼Œå¥½åƒæˆ‘å®šä¹‰é‚£äº›å®ä½“Beanæ—¶å€™ï¼Œå¹¶æ²¡æœ‰è¿™ä¹ˆåšï¼Œè¿™ä¸ªä¹Ÿè¦çœ‹æƒ…å†µå§ï¼Ÿ</div>2019-01-21</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg" width="30px"><span>aoe</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ2ï¼‰<div>è€å¸ˆï¼Œè¯·æ•™æ‚¨ä¸€ä¸ªé—®é¢˜ï¼š
Javaä¸­ç±»å˜é‡çš„åˆå§‹åŒ–ä¸æ˜¯éƒ½æ”¾åœ¨æ„é€ å‡½æ•°æˆ–è€…åˆå§‹åŒ–å‡½æ•°ä¸­å—ï¼Ÿæ‚¨çš„ç¤ºä¾‹ä¸­æ˜¯å£°æ˜çš„æ—¶å€™ç›´æ¥åˆå§‹åŒ–çš„ï¼Œæ˜¯ä¸æ˜¯æœ‰å¤æ‚é€»è¾‘ï¼ˆéœ€è¦é€šè¿‡è°ƒç”¨æ–¹æ³•èµ‹å€¼ï¼‰çš„æ‰éœ€è¦æ”¾åœ¨åˆå§‹åŒ–å‡½æ•°ä¸­ï¼Ÿ</div>2021-12-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/a2/58/d313b781.jpg" width="30px"><span>newtonker</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<div>emptyMethodçš„æ–¹æ³•ä½“é‡Œè¿˜éœ€è¦åŠ ä¸€è¡Œblankçš„æ³¨é‡Šå—ï¼Ÿ</div>2020-09-08</li><br/><li><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/ooZCPFY1xgC81h0Eu3vuqbWG5MaBp8RNmvXXGQwupo2LpSOLq0rBlTDRAF1yM6wF09WdeG49rA9dJSVKIUBxnQ/132" width="30px"><span>Sisyphus235</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<div>å£°æ˜åŒ…å«å‘½åè§„èŒƒå’Œç±»å‹ï¼Œå‘½åè§„èŒƒä¹‹å‰çš„æ–‡ç« æ¢è®¨è¿‡ï¼Œæˆ‘è§‰å¾—è¿™é‡Œæ›´é‡è¦çš„æ˜¯ç±»å‹ã€‚æ–‡ä¸­æåˆ°å¾ˆå¤šæ ¼å¼ä¸Šçš„æ³¨æ„ï¼Œæˆ‘è¡¥å……ä¸€äº›ç±»å‹ä¸Šçš„æ¢è®¨ï¼Œä½¿ç”¨ç±»å‹ä¸Šæœ‰å¾ˆå¤§å­¦é—®ï¼Œä¸ªäººè§‰å¾— function èƒ½è§£å†³çš„ä¸ç”¨ classï¼Œä¸å˜çš„å˜é‡è¦ä½¿ç”¨ immutable çš„ç±»å‹ï¼Œé¿å…ä¸­é—´èµ‹å€¼çš„æ”¹å˜ï¼Œæ•´å‹èƒ½è¡¨è¾¾çš„ä¸ç”¨æµ®ç‚¹å‹ï¼Œé‡‘é’±ç­‰ç²¾ç¡®åº¦è¦æ±‚é«˜çš„å˜é‡è½¬æ¢æˆæ•´å‹ã€‚

å¦å¤–å°±æ˜¯ä¸åŒä»£ç æ¨¡å—ä¼ å‚çš„æ—¶å€™ï¼Œç›¸åŒå£°æ˜å¯èƒ½ä¼šé€ æˆè¯¯è§£ï¼Œæˆ–è€…ä¸€äº›è¯­è¨€ä¼šå‡ºç°ä¸åŒ namespace ä¸å¯çŸ¥çš„å˜é‡å€¼æ”¹å˜ã€‚</div>2019-05-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/f7/c4/bd7dd30a.jpg" width="30px"><span>å°æ–‡</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<div>ä¸æ˜ç™½ä¸ºä»€ä¹ˆåƒè¿™ç§int size, length;ä¸€è¡Œå£°æ˜å¤šä¸ªçš„å½¢å¼è¦è¢«è®¾è®¡å‡ºæ¥ï¼Œä¸è®©ç”¨ä¸å°±å¾—äº†ï¼Œå”‰â€¦â€¦
</div>2019-02-15</li><br/><li><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erTP9oVUWrHicg8korhaiakmWnskgZDQ4zLF91wLPrOrGicnCOiczIHqSceH4P2ZfdUfV9Tk13kbJfRTQ/132" width="30px"><span>ç‹å°è±ª</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<div>å¾ˆæœ‰ç”¨ï½å°±æ˜¯æ„Ÿè§‰æœ‰ç‚¹çŸ­å‘ğŸ˜‚</div>2019-01-21</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg" width="30px"><span>ifelse</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<div>å–å¥½åå­—ï¼Œå®¹æ˜“è¯†åˆ«--è®°ä¸‹æ¥</div>2022-07-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/08/5a/d1c64d21.jpg" width="30px"><span>Mr.yu</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<div>è¶Šæ¥è¶Šå‘ç°æŠ€æœ¯å¥½åˆ°ä¸€å®šç¨‹åº¦çš„äººï¼Œå¾€å¾€æ±‰å­—ä¹Ÿå†™çš„å¾ˆå¥½ã€‚</div>2021-05-11</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/08/5a/d1c64d21.jpg" width="30px"><span>Mr.yu</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<div>package com.jikeshijian.fanxuelie;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

class Solution {

    &#47;**
     * Return a list of the words in words that match the given pattern.
     *
     * A word matches the pattern if there exists a permutation of letters p so that after replacing
     * every letter x in the pattern with p(x), we get the desired word.
     *
     * Example: Input: words = [&quot;abc&quot;,&quot;deq&quot;,&quot;mee&quot;,&quot;aqq&quot;,&quot;dkd&quot;,&quot;ccc&quot;], pattern = &quot;abb&quot; Output:
     * [&quot;mee&quot;,&quot;aqq&quot;]
     *
     * Explanation: &quot;mee&quot; matches the pattern because there is a permutation {a -&gt; m, b -&gt; e, ...}.
     *
     * &quot;ccc&quot; does not match the pattern because {a -&gt; c, b -&gt; c, ...} is not a permutation, since a
     * and b map to the same letter.
     *&#47;
    public List&lt;String&gt; findAndReplacePattern(String[] words, String pattern) {
        List&lt;String&gt; ans = new ArrayList();
        for (String word : words) {
            if (match(word, pattern)) {
                ans.add(word);
            }
        }
        return ans;
    }

    public boolean match(String word, String pattern) {
        Map&lt;Character, Character&gt; M = new HashMap();
        for (int i = 0; i &lt; word.length(); ++i) {
            char w = word.charAt(i);
            char p = pattern.charAt(i);
            if (!M.containsKey(w)) {
                M.put(w, p);
            }
            if (M.get(w) != p) {
                return false;
            }
        }
        boolean[] seen = new boolean[26];
        for (char p : M.values()) {
            if (seen[p - &#39;a&#39;]) {
                return false;
            }
            seen[p - &#39;a&#39;] = true;
        }
        return true;
    }
}
</div>2021-05-11</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/08/df/4e5c2b29.jpg" width="30px"><span>æ‹‰æ ¼æœ—æ—¥çš„å¿§æ¡‘</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<div>import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

class Solution {

	private static final char CHAR_VALUE = &#39;a&#39;;
	
	
    &#47;**
     * Return a list of the words in words that match the given pattern.
     *
     * A word matches the pattern if there exists a permutation of
     * letters p so that after replacing every letter x in the pattern
     * with p(x), we get the desired word.
     *
     * Example:
     *     Input: words = [&quot;abc&quot;,&quot;deq&quot;,&quot;mee&quot;,&quot;aqq&quot;,&quot;dkd&quot;,&quot;ccc&quot;],
     *            pattern = &quot;abb&quot;
     *     Output: [&quot;mee&quot;,&quot;aqq&quot;]
     *
     *     Explanation: &quot;mee&quot; matches the pattern because there is
     *         a permutation {a -&gt; m, b -&gt; e, ...}.
     *
     *        &quot;ccc&quot; does not match the pattern because
     *        {a -&gt; c, b -&gt; c, ...} is not a permutation, since a
     *        and b map to the same letter.
     *&#47;
    public List&lt;String&gt; findAndReplacePattern(String[] words, String pattern) {
        List&lt;String&gt; result = new ArrayList();
		
        for (String word: words)
		{
		    if (match(word, pattern))
			{
			
			    result.add(word);
			}
                
		}
            
        return result;
    }

    public boolean match(String word, String pattern) {
        Map&lt;Character, Character&gt; map = new HashMap();
		
        for (int i = 0; i &lt; word.length(); ++i) {
		
            char wordChar = word.charAt(i);
            char patternChar = pattern.charAt(i);
			
            if (!map.containsKey(w))
			{
			    map.put(wordChar, patternChar);
			}
            if (map.get(wordChar) != patternChar) 
			{
			    return false;
			}
			
        }
		
        boolean[] seen = new boolean[26];
		
        for (char charPattern: map.values()) {
			
            if (seen[charPattern - CHAR_VALUE]) 
			{
				return false;
			}
			
            seen[charPattern - CHAR_VALUE] = true;
        }
		
        return true;
    }
}
</div>2019-02-22</li><br/>
</ul>