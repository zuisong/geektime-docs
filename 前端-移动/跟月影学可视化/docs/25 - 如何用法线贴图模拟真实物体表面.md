ä½ å¥½ï¼Œæˆ‘æ˜¯æœˆå½±ã€‚

ä¸ŠèŠ‚è¯¾ï¼Œæˆ‘ä»¬è®²äº†å…‰ç…§çš„Phongåå°„æ¨¡å‹ï¼Œå¹¶ä½¿ç”¨å®ƒç»™å‡ ä½•ä½“æ·»åŠ äº†å…‰ç…§æ•ˆæœã€‚ä¸è¿‡ï¼Œæˆ‘ä»¬ä½¿ç”¨çš„å‡ ä½•ä½“è¡¨é¢éƒ½æ˜¯å¹³æ•´çš„ï¼Œæ²¡æœ‰å‡¹å‡¸æ„Ÿã€‚è€ŒçœŸå®ä¸–ç•Œä¸­ï¼Œå¤§éƒ¨åˆ†ç‰©ä½“çš„è¡¨é¢éƒ½æ˜¯å‡¹å‡¸ä¸å¹³çš„ï¼Œè¿™è‚¯å®šä¼šå½±å“å…‰ç…§çš„åå°„æ•ˆæœã€‚

å› æ­¤ï¼Œåªæœ‰å¤„ç†å¥½ç‰©ä½“å‡¹å‡¸è¡¨é¢çš„å…‰ç…§æ•ˆæœï¼Œæˆ‘ä»¬æ‰èƒ½æ›´åŠ çœŸå®åœ°æ¨¡æ‹Ÿç‰©ä½“è¡¨é¢ã€‚åœ¨å›¾å½¢å­¦ä¸­å°±æœ‰ä¸€ç§å¯¹åº”çš„æŠ€æœ¯ï¼Œå«åš**æ³•çº¿è´´å›¾**ã€‚ä»Šå¤©ï¼Œæˆ‘ä»¬å°±ä¸€èµ·æ¥å­¦ä¹ ä¸€ä¸‹ã€‚

## å¦‚ä½•ä½¿ç”¨æ³•çº¿è´´å›¾ç»™å‡ ä½•ä½“è¡¨é¢å¢åŠ å‡¹å‡¸æ•ˆæœï¼Ÿ

é‚£ä»€ä¹ˆæ˜¯æ³•çº¿è´´å›¾ï¼Ÿæˆ‘ä»¬ç›´æ¥é€šè¿‡ä¸€ä¸ªä¾‹å­æ¥ç†è§£ã€‚

é¦–å…ˆï¼Œæˆ‘ä»¬ç”¨Phongåå°„æ¨¡å‹ç»˜åˆ¶ä¸€ä¸ªç°è‰²çš„ç«‹æ–¹ä½“ï¼Œå¹¶ç»™å®ƒæ·»åŠ ä¸¤é“å¹³è¡Œå…‰ã€‚å…·ä½“çš„ä»£ç å’Œæ•ˆæœå¦‚ä¸‹ï¼š

```
import {Phong, Material, vertex as v, fragment as f} from '../common/lib/phong.js';

const scene = new Transform();

const phong = new Phong();
phong.addLight({
  direction: [0, -3, -3],
});
phong.addLight({
  direction: [0, 3, 3],
});
const matrial = new Material(new Color('#808080'));

const program = new Program(gl, {
  vertex: v,
  fragment: f,
  uniforms: {
    ...phong.uniforms,
    ...matrial.uniforms,
  },
});

const geometry = new Box(gl);
const cube = new Mesh(gl, {geometry, program});
cube.setParent(scene);
cube.rotation.x = -Math.PI / 2;
```

![](https://static001.geekbang.org/resource/image/c0/1f/c0241f80436bd66bb9b2ee37912e6a1f.jpeg?wh=1920%2A1080)

ç°åœ¨è¿™ä¸ªç«‹æ–¹ä½“çš„è¡¨é¢æ˜¯å…‰æ»‘çš„ï¼Œå¦‚æœæˆ‘ä»¬æƒ³åœ¨ç«‹æ–¹ä½“çš„è¡¨é¢è´´ä¸Šå‡¹å‡¸çš„èŠ±çº¹ã€‚æˆ‘ä»¬å¯ä»¥åŠ è½½ä¸€å¼ **æ³•çº¿çº¹ç†**ï¼Œè¿™æ˜¯ä¸€å¼ åè“è‰²è°ƒçš„çº¹ç†å›¾ç‰‡ã€‚

![](https://static001.geekbang.org/resource/image/8c/f7/8c13477872b6bc541ab1f9ec8017bbf7.jpeg?wh=1920%2A1080)

```
const normalMap = await loadTexture('../assets/normal_map.png');
```

ä¸ºä»€ä¹ˆè¿™å¼ çº¹ç†å›¾ç‰‡æ˜¯åè“è‰²è°ƒçš„å‘¢ï¼Ÿå®é™…ä¸Šï¼Œè¿™å¼ çº¹ç†å›¾ç‰‡ä¿å­˜çš„æ˜¯å‡ ä½•ä½“è¡¨é¢çš„æ¯ä¸ªåƒç´ çš„æ³•å‘é‡æ•°æ®ã€‚æˆ‘ä»¬çŸ¥é“ï¼Œæ­£å¸¸æƒ…å†µä¸‹ï¼Œå…‰æ»‘ç«‹æ–¹ä½“æ¯ä¸ªé¢çš„æ³•å‘é‡æ˜¯å›ºå®šçš„ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºï¼š

[![](https://static001.geekbang.org/resource/image/13/e4/13f742cafbf21d5afe6bef06a65ae3e4.jpeg?wh=1920%2A782)](http://www.mbsoftworks.sk/tutorials/opengl4/014-normals-diffuse-lighting/)

ä½†å¦‚æœè¡¨é¢æœ‰å‡¹å‡¸çš„èŠ±çº¹ï¼Œé‚£ä¸åŒä½ç½®çš„æ³•å‘é‡å°±ä¼šå‘ç”Ÿå˜åŒ–ã€‚åœ¨**åˆ‡çº¿ç©ºé—´**ä¸­ï¼Œå› ä¸ºæ³•çº¿éƒ½åå‘äºzè½´ï¼Œä¹Ÿå°±æ˜¯æ³•å‘é‡åå‘äº(0,0,1)ï¼Œæ‰€ä»¥è½¬æ¢æˆçš„æ³•çº¿çº¹ç†å°±åå‘äºè“è‰²ã€‚å¦‚æœæˆ‘ä»¬æ ¹æ®èŠ±çº¹å°†æ¯ä¸ªç‚¹çš„æ³•å‘é‡éƒ½ä¿å­˜ä¸‹æ¥ï¼Œå°±ä¼šå¾—åˆ°ä¸Šé¢é‚£å¼ æ³•çº¿çº¹ç†çš„å›¾ç‰‡ã€‚

### å¦‚ä½•ç†è§£åˆ‡çº¿ç©ºé—´ï¼Ÿ

æˆ‘åˆšæ‰æåˆ°äº†ä¸€ä¸ªè¯ï¼Œåˆ‡çº¿ç©ºé—´ï¼Œé‚£ä»€ä¹ˆæ˜¯åˆ‡çº¿ç©ºé—´å‘¢ï¼Ÿåˆ‡çº¿ç©ºé—´ï¼ˆTangent Spaceï¼‰æ˜¯ä¸€ä¸ªç‰¹æ®Šçš„åæ ‡ç³»ï¼Œå®ƒæ˜¯ç”±å‡ ä½•ä½“é¡¶ç‚¹æ‰€åœ¨å¹³é¢çš„uvåæ ‡å’Œæ³•çº¿æ„æˆçš„ã€‚

[![](https://static001.geekbang.org/resource/image/eb/91/ebaaafe6749e1ea9d47712d259f2c291.jpeg?wh=1920%2A884 "åˆ‡çº¿ç©ºé—´")](https://math.stackexchange.com/questions/342211/difference-between-tangent-space-and-tangent-plane)

åˆ‡çº¿ç©ºé—´çš„ä¸‰ä¸ªè½´ï¼Œä¸€èˆ¬ç”¨ T (Tangent)ã€B (Bitangent)ã€N (Normal) ä¸‰ä¸ªå­—æ¯è¡¨ç¤ºï¼Œæ‰€ä»¥åˆ‡çº¿ç©ºé—´ä¹Ÿè¢«ç§°ä¸ºTBNç©ºé—´ã€‚å…¶ä¸­Tè¡¨ç¤ºåˆ‡çº¿ã€Bè¡¨ç¤ºå‰¯åˆ‡çº¿ã€Nè¡¨ç¤ºæ³•çº¿ã€‚

å¯¹äºå¤§éƒ¨åˆ†ä¸‰ç»´å‡ ä½•ä½“æ¥è¯´ï¼Œå› ä¸ºæ¯ä¸ªç‚¹çš„æ³•çº¿ä¸åŒï¼Œæ‰€ä»¥å®ƒä»¬å„è‡ªçš„åˆ‡çº¿ç©ºé—´ä¹Ÿä¸åŒã€‚

æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬æ¥å…·ä½“è¯´è¯´ï¼Œåˆ‡çº¿ç©ºé—´ä¸­çš„TBNæ˜¯æ€ä¹ˆè®¡ç®—çš„ã€‚

é¦–å…ˆï¼Œæˆ‘ä»¬æ¥å›å¿†ä¸€ä¸‹ï¼Œæ€ä¹ˆè®¡ç®—å‡ ä½•ä½“ä¸‰è§’å½¢ç½‘æ ¼çš„æ³•å‘é‡ã€‚å‡è®¾ä¸€ä¸ªä¸‰è§’å½¢ç½‘æ ¼æœ‰ä¸‰ä¸ªç‚¹v1ã€v2ã€v3ï¼Œæˆ‘ä»¬æŠŠè¾¹v1v2è®°ä¸ºe1ï¼Œè¾¹v1v3è®°ä¸ºe2ï¼Œé‚£ä¸‰è§’å½¢çš„æ³•å‘é‡å°±æ˜¯e1å’Œe2çš„å‰ç§¯è¡¨ç¤ºçš„å½’ä¸€åŒ–å‘é‡ã€‚ç”¨JavaScriptä»£ç å®ç°å°±æ˜¯ä¸‹é¢è¿™æ ·ï¼š

```
function getNormal(v1, v2, v3) {
  const e1 = Vec3.sub(v2, v1);
  const e2 = Vec3.sub(v3, v1);
  const normal = Vec3.cross(e1, e1).normalize();
  return normal;
}
```

è€Œè®¡ç®—åˆ‡çº¿å’Œå‰¯åˆ‡çº¿ï¼Œè¦æ¯”è®¡ç®—æ³•çº¿å¤æ‚å¾—å¤šï¼Œä¸è¿‡ï¼Œå› ä¸º[æ•°å­¦æ¨å¯¼è¿‡ç¨‹](https://learnopengl.com/Advanced-Lighting/Normal-Mapping)æ¯”è¾ƒå¤æ‚ï¼Œæˆ‘ä»¬åªè¦è®°ä½ç»“è®ºå°±å¯ä»¥äº†ã€‚

![](https://static001.geekbang.org/resource/image/33/6b/336454df02a6f150eff17a0760c2616b.jpeg?wh=1920%2A1080)

å¦‚ä¸Šå›¾å’Œå…¬å¼ï¼Œæˆ‘ä»¬å°±å¯ä»¥é€šè¿‡UVåæ ‡å’Œç‚¹P1ã€P2ã€P3çš„åæ ‡æ±‚å‡ºå¯¹åº”çš„Tå’ŒBåæ ‡äº†ï¼Œå¯¹åº”çš„JavaScriptå‡½æ•°å¦‚ä¸‹ï¼š

```
function createTB(geometry) {
  const {position, index, uv} = geometry.attributes;
  if(!uv) throw new Error('NO uv.');
  function getTBNTriangle(p1, p2, p3, uv1, uv2, uv3) {
    const edge1 = new Vec3().sub(p2, p1);
    const edge2 = new Vec3().sub(p3, p1);
    const deltaUV1 = new Vec2().sub(uv2, uv1);
    const deltaUV2 = new Vec2().sub(uv3, uv1);

    const tang = new Vec3();
    const bitang = new Vec3();

    const f = 1.0 / (deltaUV1.x * deltaUV2.y - deltaUV2.x * deltaUV1.y);

    tang.x = f * (deltaUV2.y * edge1.x - deltaUV1.y * edge2.x);
    tang.y = f * (deltaUV2.y * edge1.y - deltaUV1.y * edge2.y);
    tang.z = f * (deltaUV2.y * edge1.z - deltaUV1.y * edge2.z);

    tang.normalize();

    bitang.x = f * (-deltaUV2.x * edge1.x + deltaUV1.x * edge2.x);
    bitang.y = f * (-deltaUV2.x * edge1.y + deltaUV1.x * edge2.y);
    bitang.z = f * (-deltaUV2.x * edge1.z + deltaUV1.x * edge2.z);

    bitang.normalize();

    return {tang, bitang};
  }

  const size = position.size;
  if(size < 3) throw new Error('Error dimension.');

  const len = position.data.length / size;
  const tang = new Float32Array(len * 3);
  const bitang = new Float32Array(len * 3);

  for(let i = 0; i < index.data.length; i += 3) {
    const i1 = index.data[i];
    const i2 = index.data[i + 1];
    const i3 = index.data[i + 2];

    const p1 = [position.data[i1 * size], position.data[i1 * size + 1], position.data[i1 * size + 2]];
    const p2 = [position.data[i2 * size], position.data[i2 * size + 1], position.data[i2 * size + 2]];
    const p3 = [position.data[i3 * size], position.data[i3 * size + 1], position.data[i3 * size + 2]];

    const u1 = [uv.data[i1 * 2], uv.data[i1 * 2 + 1]];
    const u2 = [uv.data[i2 * 2], uv.data[i2 * 2 + 1]];
    const u3 = [uv.data[i3 * 2], uv.data[i3 * 2 + 1]];

    const {tang: t, bitang: b} = getTBNTriangle(p1, p2, p3, u1, u2, u3);
    tang.set(t, i1 * 3);
    tang.set(t, i2 * 3);
    tang.set(t, i3 * 3);
    bitang.set(b, i1 * 3);
    bitang.set(b, i2 * 3);
    bitang.set(b, i3 * 3);
  }
  geometry.addAttribute('tang', {data: tang, size: 3});
  geometry.addAttribute('bitang', {data: bitang, size: 3});
  return geometry;
}

```

è™½ç„¶ä¸Šé¢è¿™æ®µä»£ç æ¯”è¾ƒé•¿ï¼Œä½†å¹¶ä¸å¤æ‚ã€‚å…·ä½“çš„æ€è·¯å°±æ˜¯æŒ‰ç…§æˆ‘ç»™å‡ºçš„å…¬å¼ï¼Œå…ˆè¿›è¡Œå‘é‡è®¡ç®—ï¼Œç„¶åå°†tangå’Œbitangçš„å€¼æ·»åŠ åˆ°geometryå¯¹è±¡ä¸­å»ã€‚

### æ„å»ºTBNçŸ©é˜µæ¥è®¡ç®—æ³•å‘é‡

æœ‰äº†tangå’Œbitangä¹‹åï¼Œæˆ‘ä»¬å°±å¯ä»¥æ„å»ºTBNçŸ©é˜µæ¥è®¡ç®—æ³•çº¿äº†ã€‚è¿™é‡Œçš„TBNçŸ©é˜µçš„ä½œç”¨ï¼Œå°±æ˜¯å°†æ³•çº¿è´´å›¾é‡Œé¢è¯»å–çš„æ³•å‘é‡æ•°æ®ï¼Œè½¬æ¢ä¸ºå¯¹åº”çš„åˆ‡çº¿ç©ºé—´ä¸­å®é™…çš„æ³•å‘é‡ã€‚è¿™é‡Œçš„åˆ‡çº¿ç©ºé—´ï¼Œå®é™…ä¸Šå¯¹åº”ç€æˆ‘ä»¬è§‚å¯Ÿè€…ï¼ˆç›¸æœºï¼‰ä½ç½®çš„åæ ‡ç³»ã€‚

æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å¯¹åº”é¡¶ç‚¹ç€è‰²å™¨å’Œç‰‡å…ƒç€è‰²å™¨æ¥è¯´è¯´ï¼Œæ€ä¹ˆæ„å»ºTBNçŸ©é˜µå¾—å‡ºæ³•çº¿æ–¹å‘ã€‚

å…ˆçœ‹é¡¶ç‚¹ç€è‰²å™¨ï¼Œæˆ‘ä»¬å¢åŠ äº†tangå’Œbitangè¿™ä¸¤ä¸ªå±æ€§ã€‚æ³¨æ„ï¼Œè¿™é‡Œæˆ‘ä»¬ç”¨äº†webgl2.0çš„å†™æ³•ï¼Œå› ä¸ºWebGL2.0å¯¹åº”OpenGL ES3.0ï¼Œæ‰€ä»¥è¿™æ®µä»£ç å’Œæˆ‘ä»¬ä¹‹å‰çœ‹åˆ°çš„ç€è‰²å™¨ä»£ç ç•¥æœ‰ä¸åŒã€‚

é¦–å…ˆå®ƒçš„ç¬¬ä¸€è¡Œå£°æ˜ #version 300 es è¡¨ç¤ºè¿™æ®µä»£ç æ˜¯OpenGL ES3.0çš„ï¼Œç„¶åæˆ‘ä»¬ç”¨inå’Œoutå¯¹åº”å˜é‡çš„è¾“å…¥å’Œè¾“å‡ºï¼Œæ¥å–ä»£WebGL2.0çš„attributeå’Œvaryingï¼Œå…¶ä»–çš„åœ°æ–¹åŸºæœ¬å’ŒWebGL1.0ä¸€æ ·ã€‚å› ä¸ºOGLé»˜è®¤æ”¯æŒWebGL2.0ï¼Œæ‰€ä»¥åœ¨åç»­ä¾‹å­ä¸­ä½ è¿˜ä¼šçœ‹åˆ°æ›´å¤šOpenGL ES3.0çš„ç€è‰²å™¨å†™æ³•ï¼Œä¸è¿‡å› ä¸ºä¸¤ä¸ªç‰ˆæœ¬å·®åˆ«ä¸å¤§ï¼Œä¹Ÿä¸ä¼šå¦¨ç¢æˆ‘ä»¬ç†è§£ä»£ç ã€‚

```
#version 300 es
precision highp float;

in vec3 position;
in vec3 normal;
in vec2 uv;
in vec3 tang;
in vec3 bitang;

uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 viewMatrix;
uniform mat4 projectionMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;

out vec3 vNormal;
out vec3 vPos;
out vec2 vUv;
out vec3 vCameraPos;
out mat3 vTBN;

void main() {
  vec4 pos = modelViewMatrix * vec4(position, 1.0);
  vPos = pos.xyz;
  vUv = uv;
  vCameraPos = (viewMatrix * vec4(cameraPosition, 1.0)).xyz;
  vNormal = normalize(normalMatrix * normal);

  vec3 N = vNormal;
  vec3 T = normalize(normalMatrix * tang);
  vec3 B = normalize(normalMatrix * bitang);

  vTBN = mat3(T, B, N);
  
  gl_Position = projectionMatrix * pos;
}

```

æ¥ç€æ¥çœ‹ä»£ç ï¼Œæˆ‘ä»¬é€šè¿‡normalã€tangå’Œbitangå»ºç«‹TBNçŸ©é˜µã€‚æ³¨æ„ï¼Œå› ä¸ºnormalã€tangå’Œbitangéƒ½éœ€è¦æ¢åˆ°ä¸–ç•Œåæ ‡ä¸­ï¼Œæ‰€ä»¥æˆ‘ä»¬è¦è®°å¾—å°†å®ƒä»¬å·¦ä¹˜æ³•å‘é‡çŸ©é˜µnormalMatrixï¼Œç„¶åæˆ‘ä»¬æ„å»ºTBNçŸ©é˜µ(vTBN=mat(T,B,N))ï¼Œå°†å®ƒä¼ ç»™ç‰‡å…ƒç€è‰²å™¨ã€‚

ä¸‹é¢ï¼Œæˆ‘ä»¬æ¥ç€æ¥çœ‹ç‰‡å…ƒç€è‰²å™¨ã€‚

```
#version 300 es
precision highp float;

#define MAX_LIGHT_COUNT 16
uniform mat4 viewMatrix;

uniform vec3 ambientLight;
uniform vec3 directionalLightDirection[MAX_LIGHT_COUNT];
uniform vec3 directionalLightColor[MAX_LIGHT_COUNT];
uniform vec3 pointLightColor[MAX_LIGHT_COUNT];
uniform vec3 pointLightPosition[MAX_LIGHT_COUNT];
uniform vec3 pointLightDecay[MAX_LIGHT_COUNT];
uniform vec3 spotLightColor[MAX_LIGHT_COUNT];
uniform vec3 spotLightDirection[MAX_LIGHT_COUNT];
uniform vec3 spotLightPosition[MAX_LIGHT_COUNT];
uniform vec3 spotLightDecay[MAX_LIGHT_COUNT];
uniform float spotLightAngle[MAX_LIGHT_COUNT];

uniform vec3 materialReflection;
uniform float shininess;
uniform float specularFactor;

uniform sampler2D tNormal;

in vec3 vNormal;
in vec3 vPos;
in vec2 vUv;
in vec3 vCameraPos;
in mat3 vTBN;

out vec4 FragColor;

float getSpecular(vec3 dir, vec3 normal, vec3 eye) {
  vec3 reflectionLight = reflect(-dir, normal);
  float eyeCos = max(dot(eye, reflectionLight), 0.0);
  return specularFactor *  pow(eyeCos, shininess);
}

vec4 phongReflection(vec3 pos, vec3 normal, vec3 eye) {
  float specular = 0.0;
  vec3 diffuse = vec3(0);
  
  // å¤„ç†å¹³è¡Œå…‰
  for(int i = 0; i < MAX_LIGHT_COUNT; i++) {
    vec3 dir = directionalLightDirection[i];
    if(dir.x == 0.0 && dir.y == 0.0 && dir.z == 0.0) continue;
    vec4 d = viewMatrix * vec4(dir, 0.0);
    dir = normalize(-d.xyz);
    float cos = max(dot(dir, normal), 0.0);
    diffuse += cos * directionalLightColor[i];
    specular += getSpecular(dir, normal, eye);
  }

  // å¤„ç†ç‚¹å…‰æº
  for(int i = 0; i < MAX_LIGHT_COUNT; i++) {
    vec3 decay = pointLightDecay[i];
    if(decay.x == 0.0 && decay.y == 0.0 && decay.z == 0.0) continue;
    vec3 dir = (viewMatrix * vec4(pointLightPosition[i], 1.0)).xyz - pos;
    float dis = length(dir);
    dir = normalize(dir);
    float cos = max(dot(dir, normal), 0.0);
    float d = min(1.0, 1.0 / (decay.x * pow(dis, 2.0) + decay.y * dis + decay.z));
    diffuse += d * cos * pointLightColor[i];
    specular += getSpecular(dir, normal, eye);
  }

  // å¤„ç†èšå…‰ç¯
  for(int i = 0; i < MAX_LIGHT_COUNT; i++) {
    vec3 decay = spotLightDecay[i];
    if(decay.x == 0.0 && decay.y == 0.0 && decay.z == 0.0) continue;

    vec3 dir = (viewMatrix * vec4(spotLightPosition[i], 1.0)).xyz - pos;
    float dis = length(dir);
    dir = normalize(dir);

    // èšå…‰ç¯çš„æœå‘
    vec3 spotDir = (viewMatrix * vec4(spotLightDirection[i], 0.0)).xyz;
    // é€šè¿‡ä½™å¼¦å€¼åˆ¤æ–­å¤¹è§’èŒƒå›´
    float ang = cos(spotLightAngle[i]);
    float r = step(ang, dot(dir, normalize(-spotDir)));

    float cos = max(dot(dir, normal), 0.0);
    float d = min(1.0, 1.0 / (decay.x * pow(dis, 2.0) + decay.y * dis + decay.z));
    diffuse += r * d * cos * spotLightColor[i];
    specular += r * getSpecular(dir, normal, eye);
  }

  return vec4(diffuse, specular);
}

vec3 getNormal() {
  vec3 n = texture(tNormal, vUv).rgb * 2.0 - 1.0;
  return normalize(vTBN * n);
}

void main() {
  vec3 eyeDirection = normalize(vCameraPos - vPos);
  vec3 normal = getNormal();
  vec4 phong = phongReflection(vPos, normal, eyeDirection);

  // åˆæˆé¢œè‰²
  FragColor.rgb = phong.w + (phong.xyz + ambientLight) * materialReflection;
  FragColor.a = 1.0;
}

```

ç‰‡å…ƒç€è‰²å™¨ä»£ç è™½ç„¶ä¹Ÿå¾ˆé•¿ï¼Œä½†ä¹Ÿå¹¶ä¸å¤æ‚ã€‚å› ä¸ºå…¶ä¸­çš„Phongåå°„æ¨¡å‹ï¼Œæˆ‘ä»¬å·²ç»æ¯”è¾ƒç†Ÿæ‚‰äº†ã€‚å‰©ä¸‹çš„éƒ¨åˆ†ï¼Œæˆ‘ä»¬é‡ç‚¹ç†è§£ï¼Œæ€ä¹ˆä»æ³•çº¿çº¹ç†ä¸­æå–æ•°æ®å’ŒTBNçŸ©é˜µï¼Œæ¥è®¡ç®—å¯¹åº”çš„æ³•çº¿å°±è¡Œäº†ã€‚å…·ä½“çš„è®¡ç®—æ–¹æ³•å°±æ˜¯æŠŠæ³•çº¿çº¹ç†è´´å›¾ä¸­æå–çš„æ•°æ®è½¬æ¢åˆ°\[-1ï¼Œ1]åŒºé—´ï¼Œç„¶åå·¦ä¹˜TBNçŸ©é˜µå¹¶å½’ä¸€åŒ–ã€‚

ç„¶åï¼Œæˆ‘ä»¬å°†ç»è¿‡å¤„ç†ä¹‹åçš„æ³•å‘é‡ä¼ ç»™phongReflectionè®¡ç®—å…‰ç…§ï¼Œå°±å¾—åˆ°äº†æ³•çº¿è´´å›¾åçš„ç»“æœï¼Œæ•ˆæœå¦‚ä¸‹å›¾ï¼š

![](https://static001.geekbang.org/resource/image/f6/b7/f669899196e94d06b101bb5eeea69db7.gif?wh=492%2A440)

åˆ°è¿™é‡Œæˆ‘ä»¬å°±å®ç°äº†å®Œæ•´çš„æ³•çº¿è´´å›¾ã€‚æ³•çº¿è´´å›¾å°±æ˜¯æ ¹æ®æ³•çº¿çº¹ç†ä¸­ä¿å­˜çš„æ³•å‘é‡æ•°æ®ä»¥åŠTBNçŸ©é˜µï¼Œå°†å®é™…çš„æ³•çº¿è®¡ç®—å‡ºæ¥ï¼Œç„¶åç”¨å®é™…çš„æ³•çº¿æ¥è®¡ç®—å…‰ç…§çš„åå°„ã€‚å…·ä½“ç‚¹æ¥è¯´ï¼Œè¦å®ç°æ³•çº¿è´´å›¾ï¼Œæˆ‘ä»¬éœ€è¦é€šè¿‡é¡¶ç‚¹æ•°æ®è®¡ç®—å‡ ä½•ä½“çš„åˆ‡çº¿å’Œå‰¯åˆ‡çº¿ï¼Œç„¶åå¾—åˆ°TBNçŸ©é˜µï¼Œç”¨TBNçŸ©é˜µå’Œæ³•çº¿çº¹ç†æ•°æ®æ¥è®¡ç®—æ³•å‘é‡ï¼Œä»è€Œå®Œæˆæ³•çº¿è´´å›¾ã€‚

### ä½¿ç”¨åå¯¼æ•°æ¥å®ç°æ³•çº¿è´´å›¾

ä½†æ˜¯ï¼Œæ„å»ºTBNçŸ©é˜µæ±‚æ³•å‘é‡çš„æ–¹æ³•è¿˜æ˜¯æœ‰ç‚¹éº»çƒ¦ã€‚äº‹å®ä¸Šï¼Œè¿˜æœ‰ä¸€ç§æ›´å·§å¦™çš„æ–¹æ³•ï¼Œä¸éœ€è¦ç”¨é¡¶ç‚¹æ•°æ®è®¡ç®—å‡ ä½•ä½“çš„åˆ‡çº¿å’Œå‰¯åˆ‡çº¿ï¼Œè€Œæ˜¯ç›´æ¥ç”¨åæ ‡æ’å€¼å’Œæ³•çº¿çº¹ç†æ¥è®¡ç®—ã€‚

```
vec3 getNormal() {
  vec3 pos_dx = dFdx(vPos.xyz);
  vec3 pos_dy = dFdy(vPos.xyz);
  vec2 tex_dx = dFdx(vUv);
  vec2 tex_dy = dFdy(vUv);

  vec3 t = normalize(pos_dx * tex_dy.t - pos_dy * tex_dx.t);
  vec3 b = normalize(-pos_dx * tex_dy.s + pos_dy * tex_dx.s);
  mat3 tbn = mat3(t, b, normalize(vNormal));

  vec3 n = texture(tNormal, vUv).rgb * 2.0 - 1.0;
  return normalize(tbn * n);
}
```

å¦‚ä¸Šé¢ä»£ç æ‰€ç¤ºï¼ŒdFdxã€dFdyæ˜¯GLSLå†…ç½®å‡½æ•°ï¼Œå¯ä»¥æ±‚æ’å€¼çš„å±æ€§åœ¨xã€yè½´ä¸Šçš„åå¯¼æ•°ã€‚é‚£æˆ‘ä»¬ä¸ºä»€ä¹ˆè¦æ±‚åå¯¼æ•°å‘¢ï¼Ÿ**åå¯¼æ•°**å…¶å®å°±ä»£è¡¨æ’å€¼çš„å±æ€§å‘é‡åœ¨xã€yè½´ä¸Šçš„å˜åŒ–ç‡ï¼Œæˆ–è€…è¯´æ›²é¢çš„åˆ‡çº¿ã€‚ç„¶åï¼Œæˆ‘ä»¬å†å°†é¡¶ç‚¹åæ ‡æ›²é¢åˆ‡çº¿ä¸uvåæ ‡çš„åˆ‡çº¿æ±‚å‰ç§¯ï¼Œå°±èƒ½å¾—åˆ°å‚ç›´äºä¸¤æ¡åˆ‡çº¿çš„æ³•çº¿ã€‚

é‚£æˆ‘ä»¬åœ¨xã€yä¸¤ä¸ªæ–¹å‘ä¸Šæ±‚å‡ºçš„ä¸¤æ¡æ³•çº¿ï¼Œå°±å¯¹åº”TBNç©ºé—´çš„åˆ‡çº¿tangå’Œå‰¯åˆ‡çº¿bitangã€‚ç„¶åï¼Œæˆ‘ä»¬ä½¿ç”¨åå¯¼æ•°æ„å»ºTBNçŸ©é˜µï¼ŒåŒæ ·ä¹Ÿæ˜¯æŠŠTBNçŸ©é˜µå·¦ä¹˜ä»æ³•çº¿çº¹ç†ä¸­æå–å‡ºçš„å€¼ï¼Œå°±å¯ä»¥è®¡ç®—å‡ºå¯¹åº”çš„æ³•å‘é‡äº†ã€‚

è¿™æ ·åšçš„å¥½å¤„æ˜¯ï¼Œæˆ‘ä»¬ä¸éœ€è¦é¢„å…ˆè®¡ç®—å‡ ä½•ä½“çš„tangå’Œbitangäº†ã€‚ä¸è¿‡åœ¨ç‰‡å…ƒç€è‰²å™¨ä¸­è®¡ç®—åå¯¼æ•°ä¹Ÿæœ‰ä¸€å®šçš„æ€§èƒ½å¼€é”€ï¼Œæ‰€ä»¥å„æœ‰åˆ©å¼Šï¼Œæˆ‘ä»¬å¯ä»¥æ ¹æ®ä¸åŒæƒ…å†µé€‰æ‹©ä¸åŒçš„æ–¹æ¡ˆã€‚

## æ³•çº¿è´´å›¾çš„åº”ç”¨

æ³•çº¿è´´å›¾çš„ä¸¤ç§å®ç°æ–¹å¼ï¼Œæˆ‘ä»¬éƒ½å­¦ä¼šäº†ã€‚é‚£æ³•çº¿è´´å›¾é™¤äº†ç»™å‡ ä½•ä½“è¡¨é¢å¢åŠ èŠ±çº¹ä»¥å¤–ï¼Œè¿˜å¯ä»¥ç”¨æ¥å¢å¼ºç‰©ä½“ç»†èŠ‚ï¼Œè®©ç‰©ä½“çœ‹èµ·æ¥æ›´åŠ çœŸå®ã€‚æ¯”å¦‚è¯´ï¼Œåœ¨å®ç°ä¸€ä¸ªçŸ³å—è¢«å˜åŒ–çš„å…‰æºç…§äº®æ•ˆæœçš„æ—¶å€™ï¼Œæˆ‘ä»¬å°±å¯ä»¥è¿ç”¨æ³•çº¿è´´å›¾æŠ€æœ¯ï¼Œè®©çŸ³å—çš„è¡¨é¢çº¹è·¯ç»†èŠ‚æ˜¾å¾—éå¸¸çš„é€¼çœŸã€‚æˆ‘æŠŠå¯¹åº”çš„ç‰‡å…ƒç€è‰²å™¨æ ¸å¿ƒä»£ç æ”¾åœ¨äº†ä¸‹é¢ï¼Œä½ å¯ä»¥åˆ©ç”¨ä»Šå¤©å­¦åˆ°çš„çŸ¥è¯†è‡ªå·±æ¥å®ç°ä¸€ä¸‹ã€‚

![](https://static001.geekbang.org/resource/image/b2/5b/b28f5b31af8af0708e77e47e584a845b.gif?wh=454%2A394)

```
uniform float uTime;

void main() {
  vec3 eyeDirection = normalize(vCameraPos - vPos);
  vec3 normal = getNormal();
  vec4 phong = phongReflection(vPos, normal, eyeDirection);
  // vec4 phong = phongReflection(vPos, vNormal, eyeDirection);

  vec3 tex = texture(tMap, vUv).rgb;
  vec3 light = normalize(vec3(sin(uTime), 1.0, cos(uTime)));
  float shading = dot(normal, light) * 0.5;
  
  FragColor.rgb = tex + shading;
  FragColor.a = 1.0;
}
```

## è¦ç‚¹æ€»ç»“

è¿™èŠ‚è¯¾ï¼Œæˆ‘ä»¬è¯¦ç»†è¯´äº†æ³•çº¿è´´å›¾è¿™ä¸ªæŠ€æœ¯ã€‚æ³•çº¿è´´å›¾æ˜¯ä¸€ç§ç»å…¸çš„å›¾å½¢å­¦æŠ€æœ¯ï¼Œå¯ä»¥ç”¨æ¥ç»™ç‰©ä½“è¡¨é¢å¢åŠ ç»†èŠ‚ï¼Œè®©æˆ‘ä»¬å®ç°çš„æ•ˆæœæ›´é€¼çœŸã€‚

å…·ä½“æ¥è¯´ï¼Œæ³•çº¿è´´å›¾æ˜¯ç”¨ä¸€å¼ å›¾ç‰‡æ¥å­˜å‚¨è¡¨é¢çš„æ³•çº¿æ•°æ®ã€‚è¿™å¼ å›¾ç‰‡å«åšæ³•çº¿çº¹ç†ï¼Œå®ƒä¸Šé¢çš„æ¯ä¸ªåƒç´ å¯¹åº”ä¸€ä¸ªåæ ‡ç‚¹çš„æ³•çº¿æ•°æ®ã€‚

è¦æƒ³ä½¿ç”¨æ³•çº¿çº¹ç†çš„æ•°æ®ï¼Œæˆ‘ä»¬è¿˜éœ€è¦æ„å»ºTBNçŸ©é˜µã€‚è¿™ä¸ªçŸ©é˜µé€šè¿‡å‘é‡ã€çŸ©é˜µä¹˜æ³•å°†æ³•çº¿æ•°æ®è½¬æ¢åˆ°ä¸–ç•Œåæ ‡ä¸­ã€‚

æ„å»ºTBNçŸ©é˜µæˆ‘ä»¬æœ‰ä¸¤ä¸ªæ–¹æ³•ï¼Œä¸€ä¸ªæ˜¯æ ¹æ®å‡ ä½•ä½“é¡¶ç‚¹æ•°æ®æ¥è®¡ç®—åˆ‡çº¿ï¼ˆTangentï¼‰ã€å‰¯åˆ‡çº¿ï¼ˆBitangentï¼‰ï¼Œç„¶åç»“åˆæ³•å‘é‡ä¸€èµ·æ„å»ºTBNçŸ©é˜µã€‚å¦ä¸€ä¸ªæ–¹æ³•æ˜¯ä½¿ç”¨åå¯¼æ•°æ¥è®¡ç®—ï¼Œè¿™æ ·æˆ‘ä»¬å°±ä¸ç”¨é¢„å…ˆåœ¨é¡¶ç‚¹ä¸­è®¡ç®—Tangentå’ŒBitangentäº†ã€‚ä¸¤ç§æ–¹æ³•å„æœ‰åˆ©å¼Šï¼Œæˆ‘ä»¬å¯ä»¥æ ¹æ®å®é™…æƒ…å†µæ¥åˆç†é€‰æ‹©ã€‚

## å°è¯•ç‰›åˆ€

è¿™é‡Œï¼Œæˆ‘ç»™å‡ºäº†ä¸¤å¼ å›¾ç‰‡ï¼Œä¸€å¼ æ˜¯çº¹ç†å›¾ç‰‡ï¼Œä¸€å¼ æ˜¯æ³•çº¿çº¹ç†ï¼Œä½ èƒ½ç”¨å®ƒä»¬åˆ†åˆ«æ¥ç»˜åˆ¶ä¸€é¢å¢™ï¼Œå¹¶ä¸”å¼•å…¥Phongåå°„æ¨¡å‹ï¼Œæ¥å®ç°å…‰ç…§æ•ˆæœå—ï¼Ÿä½ è¿˜å¯ä»¥æ€è€ƒä¸€ä¸‹ï¼Œåº”ç”¨æ³•çº¿è´´å›¾å’Œä¸åº”ç”¨æ³•çº¿è´´å›¾ç»˜åˆ¶å‡ºæ¥çš„å¢™ï¼Œæœ‰ä»€ä¹ˆå·®åˆ«ï¼Ÿ

![](https://static001.geekbang.org/resource/image/d1/3b/d107b4eeb30d46a37fa9ca85fa9b223b.jpeg?wh=1920%2A802)

æ¬¢è¿åœ¨ç•™è¨€åŒºå’Œæˆ‘è®¨è®ºï¼Œåˆ†äº«ä½ çš„ç­”æ¡ˆå’Œæ€è€ƒï¼Œä¹Ÿæ¬¢è¿ä½ æŠŠè¿™èŠ‚è¯¾åˆ†äº«ç»™ä½ çš„æœ‹å‹ï¼Œæˆ‘ä»¬ä¸‹èŠ‚è¯¾å†è§ï¼

* * *

## æºç 

è¯¾ç¨‹ä¸­å®Œæ•´ç¤ºä¾‹ä»£ç è§[GitHubä»“åº“](https://github.com/akira-cn/graphics/tree/master/normal-maps)

## æ¨èé˜…è¯»

[Normal mapping](https://learnopengl.com/Advanced-Lighting/Normal-Mapping)
<div><strong>ç²¾é€‰ç•™è¨€ï¼ˆ3ï¼‰</strong></div><ul>
<li><span>î€šè¥¿é—¨å¹é›ª</span> ğŸ‘ï¼ˆ1ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>æ„Ÿè§‰è¶Šçœ‹è¶Šéš¾ æ˜¯æ•°å­¦ä¸å¥½å—</p>2020-12-23</li><br/><li><span>é˜¿ä¸æ™•</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>æ³•çº¿è´´å›¾åŒ…å«é¢œè‰²ä¿¡æ¯ä¹ˆã€‚</p>2022-08-24</li><br/><li><span>Geek_29c515</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>è€å¸ˆï¼Œæ‚¨å¥½ï¼Œçœ‹äº†è¿™ä¹ˆæ¡ˆä¾‹ç‰¹æ•ˆéƒ½æ˜¯åŸºäºå›¾å½¢æˆ–å›¾ç‰‡çš„ï¼Œæˆ‘æƒ³æŒæ¡glslåŠ¨æ€æ–‡å­—æˆ–è‰ºæœ¯å­—ç›¸å…³çš„ï¼Œæœ‰ä»€ä¹ˆæ€è·¯æˆ–å»ºè®®å—ï¼Ÿ</p>2021-04-20</li><br/>
</ul>