ä½ å¥½ï¼Œæˆ‘æ˜¯æµ·çº³ã€‚

ç¬¬ 22 è¯¾æˆ‘ç»™ä½ ä»‹ç»äº†åƒåœ¾å›æ”¶çš„åŸºæœ¬ç®—æ³•åŸç†ï¼Œç¬¬23è¯¾æˆ‘ä»¬é€šè¿‡ä¿®æ”¹ä»£ç å®ç°äº†åœ¨å †ä¸­åˆ†é…è™šæ‹Ÿæœºå¯¹è±¡çš„åŠŸèƒ½ï¼Œä»è€ŒæŠŠæ‰€æœ‰çš„å¯¹è±¡éƒ½æ”¾ç½®åœ¨å †é‡Œã€‚

ç„¶è€Œï¼Œè¿™äº›å·¥ä½œå®é™…ä¸Šåªå®Œæˆäº†åƒåœ¾å›æ”¶å™¨ä¸€åŠçš„å·¥ä½œã€‚é™¤äº†å¯ä»¥åˆ†é…ç©ºé—´ï¼Œåƒåœ¾å›æ”¶å™¨è¿˜æœ‰ä¸€ä¸ªé‡è¦åŠŸèƒ½æ˜¯å›æ”¶ç©ºé—´ã€‚å¤åˆ¶ç®—æ³•æ˜¯é€šè¿‡æŠŠå­˜æ´»å¯¹è±¡æ¬åˆ°å¹¸å­˜è€…ç©ºé—´ï¼ˆSurvivor Spaceï¼‰æ¥å®ç°ç©ºé—´å›æ”¶åŠŸèƒ½çš„ã€‚æ‰€ä»¥è¿™ä¸€èŠ‚è¯¾ï¼Œæˆ‘ä»¬å°±é‡ç‚¹å®ç°**æ¬ç§»å­˜æ´»å¯¹è±¡**çš„åŠŸèƒ½ã€‚

## æ¬ç§»å¯¹è±¡

æœ€é€‚åˆå®Œæˆæ¬ç§»å¯¹è±¡åŠŸèƒ½çš„ç»“æ„å°±æ˜¯**è®¿é—®è€…æ¨¡å¼**ã€‚æˆ‘ä»¬å®šä¹‰ä¸€ä¸ª ScavengeOopClosure ç±»ï¼Œå®ƒåœ¨è®¿é—®æ¯ä¸€ä¸ªå †å†…çš„å¯¹è±¡æ—¶ï¼Œå°±å¯ä»¥å®Œæˆå¯¹è±¡çš„æ¬ç§»å’ŒæŒ‡é’ˆä¿®æ”¹ã€‚

```c++
// [memory/heap.cpp]
void Heap::copy_live_objects() {
    ScavengeOopClosure(eden, survivor, metaspace).scavenge();
}

// [memory/oopClosure.hpp]
class OopClosure {
public:
    virtual void do_oop(HiObject** obj) = 0;

    virtual void do_array_list(ArrayList<Klass*>** alist) = 0;
    virtual void do_array_list(ArrayList<HiObject*>** alist) = 0;
    virtual void do_array_list(ArrayList<HiString*>** alist) = 0;

    virtual void do_map(Map<HiObject*, HiObject*>** amap) = 0;
    virtual void do_raw_mem(char** mem, int length) = 0;
    virtual void do_klass(Klass** k) = 0;
};

class ScavengeOopClosure : public OopClosure {
private:
    Space* _from;
    Space* _to;
    Space* _meta;

    Stack<HiObject*>* _oop_stack;

    HiObject* copy_and_push(HiObject* obj);

public:
    ScavengeOopClosure(Space* from, Space* to, Space* meta);
    virtual ~ScavengeOopClosure();

    virtual void do_oop(HiObject** oop);

    virtual void do_array_list(ArrayList<Klass*>** alist);
    virtual void do_array_list(ArrayList<HiObject*>** alist);
    virtual void do_array_list(ArrayList<HiString*>** alist);

    template <typename T>
    void do_array_list_nv(ArrayList<T>** alist);

    virtual void do_map(Map<HiObject*, HiObject*>** amap);
    virtual void do_raw_mem(char** mem, int length);
    // CAUTION : we do not move Klass, because they locate at MetaSpace.
    virtual void do_klass(Klass** k);

    void scavenge();
    void process_roots();
};
```

è¿™æ®µä»£ç å®šä¹‰äº† ScavengeOopClosure å’Œå®ƒçš„çˆ¶ç±» OopClosureã€‚æˆ‘ä»¬æ¥å›å¿†ä¸€ä¸‹è®¿é—®è€…æ¨¡å¼ï¼ŒOopClosure æ˜¯è®¿é—®è€…çš„æ¥å£ç±»ï¼Œæ‰€ä»¥é‡Œé¢å®šä¹‰çš„æ–¹æ³•éƒ½æ˜¯çº¯è™šæ–¹æ³•ã€‚

ScavengeOopClosure æ˜¯è®¿é—®è€…çš„å…·ä½“å®ç°ç±»ï¼Œé’ˆå¯¹ä¸åŒçš„è¢«è®¿é—®è€…æä¾›äº†å…·ä½“çš„è®¿é—®æ–¹æ³•ã€‚å¦‚æœå¯¹è±¡æ˜¯ HiObjectï¼Œå°±ä½¿ç”¨ do\_oop è¿›è¡Œè®¿é—®ï¼Œå¦‚æœå¯¹è±¡æ˜¯ Mapï¼Œå°±ä½¿ç”¨ do\_map è¿›è¡Œè®¿é—®ã€‚

å½“ç„¶ï¼Œå…·ä½“å®ç°ç±»ä¸ä»…ä»…æ˜¯ ScavengeOopClosure è¿™ä¸€ç§ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥é€šè¿‡ç»§æ‰¿ OopClosure å®ç°å…¶ä»–çš„ GC ç®—æ³•ï¼Œä¾‹å¦‚æ ‡è®°æ¸…é™¤å’Œæ ‡è®°å‹ç¼©ç­‰ã€‚

ScavengeOopClosure ä¸­çš„ \_from æŒ‡é’ˆå’Œ \_to æŒ‡é’ˆï¼Œåœ¨ç¬¬ 22 è¯¾æˆ‘ä»¬åˆ†æç®—æ³•ç†è®ºçš„æ—¶å€™å°±å·²ç»ä»‹ç»è¿‡äº†ï¼Œå®ƒä»¬æœ¬è´¨ä¸Šåªæ˜¯ survivor space å’Œ eden space çš„åˆ«åã€‚\_meta å°±æ˜¯ MetaSpaceã€‚

\_oop\_stack æ˜¯ä¸ºäº†å®ç°éé€’å½’çš„æ·±åº¦ä¼˜å…ˆæœç´¢è€Œå¼•å…¥çš„ã€‚æ³¨æ„å®ƒçš„ç±»å‹æ˜¯ Stackï¼Œè€Œæ²¡æœ‰ä½¿ç”¨å·²çŸ¥çš„ ArrayListï¼Œæˆ–è€…æ˜¯ HiListã€‚

ä¹‹å‰ Frame å¯¹è±¡ä¸­çš„æ“ä½œæ•°æ ˆï¼Œæˆ‘ä»¬å°±æ˜¯ä½¿ç”¨äº† HiListï¼Œä¸ºä»€ä¹ˆè¿™é‡Œè¿˜è¦å†å®ç°ä¸€ä¸ª Stack å‘¢ï¼Ÿå› ä¸ºæ— è®ºæ˜¯ HiList è¿˜æ˜¯ ArrayListï¼Œå®ƒä»¬éƒ½æ˜¯åœ¨å †é‡Œåˆ†é…çš„ï¼Œå½“ GC åœ¨æ‰§è¡Œçš„æ—¶å€™ï¼Œå¾ˆéš¾ä¿è¯å †ä¸­çš„å¯¹è±¡ä¸å—å½±å“ã€‚æ‰€ä»¥ï¼Œæœ€ç®€å•çš„åšæ³•æ˜¯ GC éœ€è¦ä½¿ç”¨çš„æ•°æ®ç»“æ„åœ¨å †å¤–åˆ›å»ºï¼Œ**ä¿è¯åœ¨ GC è¿›è¡Œçš„è¿‡ç¨‹ä¸­ä¸åœ¨å †å†…åˆ†é…ç©ºé—´ã€‚**

Stack çš„å®ç°ä¹Ÿéå¸¸ç®€å•ï¼Œæ¥å£åªæœ‰ pushã€pop ç­‰å‡ ä¸ªï¼Œæ•°é‡ä¸å¤šï¼Œæ²¡æœ‰åŠ¨æ€æ‰©å±•å®¹é‡ã€æŸ¥æ‰¾ç­‰å…¶ä»–åŠŸèƒ½ã€‚å½“ç„¶ï¼Œåœ¨ä¸€ä¸ªçœŸå®åœºæ™¯ä¸­è¿è¡Œçš„è™šæ‹Ÿæœºï¼Œæ ˆç»“æ„åŠ¨æ€æ‰©å®¹çš„åŠŸèƒ½æ˜¯å¿…å¤‡çš„ï¼Œä½œä¸ºç¤ºä¾‹ï¼Œè¿™é‡Œæˆ‘ä»¬å°±åªæä¾›ä¸€ä¸ªæœ€ç®€å®ç°ã€‚ä½ å¯ä»¥çœ‹ä¸€ä¸‹å…·ä½“çš„å®ç°ä»£ç ã€‚

```c++
template<typename V>
class Stack {
private:
    V* vector;
    int _capacity;
    int _length;

public:
    Stack(int n = 16) {
        _capacity = n;
        vector = new V[n];
        _length = 0;
    }

    ~Stack() {
        delete[] vector;
        _capacity = 0;
        _length = 0;
    }

    void push(V v);

    V pop() {
        return vector[--_length];
    }

    V top() {
        return vector[_length - 1];
    }

    V peek(int index) {
        return vector[_length - index - 1];
    }

    int capacity() {
        return _capacity;
    }

    int length() {
        return _length;
    }

    bool empty() {
        return _length == 0;
    }

    void copy(const Stack<V>* stack);

    void oops_do(OopClosure* f);
};
```

scavenge æ–¹æ³•æ˜¯æ•´ä¸ª GC ç®—æ³•çš„å…¥å£ï¼Œæ˜¯å¼€å§‹çš„åœ°æ–¹ã€‚è¿™ä¸ªæ–¹æ³•åˆ†ä¸¤æ­¥ï¼Œç¬¬ä¸€æ­¥æ˜¯å¤„ç†æ ¹é›†åˆã€‚ç¬¬äºŒæ­¥æ˜¯ä»¥æ ¹é›†åˆä¸ºèµ·å§‹ï¼Œéå†æ•´ä¸ªå †ä¸­çš„æ‰€æœ‰å­˜æ´»å¯¹è±¡ã€‚æˆ‘ä»¬å…ˆæ¥è®¨è®ºä¸€ä¸‹å¦‚ä½•å¤„ç†æ ¹é›†åˆã€‚

## å¤„ç†æ ¹é›†åˆï¼ˆrootsï¼‰

æ ¹é›†åˆ roots æ˜¯æ‰€æœ‰ä¸åœ¨å †é‡ŒæŒ‡å‘å †å†…å¯¹è±¡çš„å¼•ç”¨çš„é›†åˆã€‚

```c++
void ScavengeOopClosure::scavenge() {
Â  Â  // step 1, mark roots
Â  Â  process_roots();

Â  Â  // step2, process all objects;
Â  Â  while (!_oop_stack->empty()) {
Â  Â  Â  Â  _oop_stack->pop()->oops_do(this);
Â  Â  }
}
```

åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæœ‰å“ªäº›å¼•ç”¨æ˜¯ roots é‡Œçš„å‘¢ï¼Ÿ

é¦–å…ˆï¼ŒUniverse ä¸­çš„ HiTrueã€HiFalse ç­‰å…¨å±€å¯¹è±¡æŒ‡é’ˆè‚¯å®šå±äº rootsï¼ŒåŒç†ï¼ŒStringTable ä¸­å®šä¹‰çš„å­—ç¬¦ä¸²ä¹Ÿå¯ä»¥çœ‹åšæ˜¯å…¨å±€å¯¹è±¡ï¼Œå®ƒä»¬ä¹Ÿæ˜¯ roots é›†åˆä¸­çš„ã€‚

å¦å¤–ï¼Œæœ€é‡è¦æ ¹å¼•ç”¨ä½äºç¨‹åºæ ˆä¸Šï¼Œä¹Ÿå°±æ˜¯ Interpreter ä¸­ä½¿ç”¨çš„ Frame å¯¹è±¡ï¼Œå…¶ä¸­è®°å½•çš„å±€éƒ¨å˜é‡è¡¨ã€å…¨å±€å˜é‡è¡¨ã€æ“ä½œæ•°æ ˆç­‰ï¼Œéƒ½æœ‰å¯èƒ½æ˜¯ä¸€ä¸ªæ™®é€šçš„ HiObject å¯¹è±¡çš„å¼•ç”¨ï¼Œè¿™äº›éƒ½å±äº roots é›†åˆã€‚

```c++
void ScavengeOopClosure::process_roots() {
Â  Â  Universe::oops_do(this);
Â  Â  Interpreter::get_instance()->oops_do(this);
Â  Â  StringTable::get_instance()->oops_do(this);
}

// [runtime/universe]
class Universe {
public:
Â  Â  ...
Â  Â  static CodeObject* main_code;
};

CodeObject* Universe::main_code = NULL;

void Universe::oops_do(OopClosure* closure) {
Â  Â  closure->do_oop((HiObject**)&HiTrue);
Â  Â  closure->do_oop((HiObject**)&HiFalse);
Â  Â  closure->do_oop((HiObject**)&HiNone);

Â  Â  closure->do_oop((HiObject**)&main_code);
Â  Â  closure->do_array_list(&klasses);
}

// [main.cpp]
int main(int argc, char** argv) {
Â  Â  ...
Â  Â  Universe::genesis();
Â  Â  BufferedInputStream stream(argv[1]);
Â  Â  BinaryFileParser parser(&stream);
Â  Â  Universe::main_code = parser.parse();
Â  Â  Universe::heap->gc();

Â  Â  Interpreter::get_instance()->run(Universe::main_code);

Â  Â  return 0;
}
```

æˆ‘ä»¬å…ˆæ¥åˆ†æ Universe çš„ oops\_do æ–¹æ³•ã€‚

ç¬¬ä¸€ä¸ªéœ€è¦æ³¨æ„çš„ç‚¹æ˜¯ CodeObjectã€‚æˆ‘ä»¬çŸ¥é“ CodeObject ä¹Ÿç»§æ‰¿è‡ª HiObjectï¼Œä¸ºäº†èƒ½è®©å›æ”¶å™¨æ­£ç¡®åœ°ç»´æŠ¤å®ƒï¼Œå¯ä»¥åœ¨ Universe ç±»é‡ŒæŠŠå®ƒå¼•ç”¨èµ·æ¥ã€‚å°±åƒä»£ç é‡Œå±•ç¤ºçš„é‚£æ ·ï¼Œåœ¨ Universe ä¸­å¢åŠ å£°æ˜å’Œå®šä¹‰ï¼Œåœ¨ main æ–¹æ³•é‡Œå¢åŠ åˆå§‹åŒ–ã€‚

ç¬¬äºŒï¼ŒUniverse çš„ oops\_do æ˜¯å…¸å‹çš„è®¿é—®è€…æ¨¡å¼çš„å®ç°ï¼Œå®ƒæ¥å—ä¸€ä¸ªè®¿é—®è€…åŸºç±»ç±»å‹çš„å¯¹è±¡ä½œä¸ºå‚æ•°ï¼Œç„¶åå¯¹è‡ªå·±æ‰€å¼•ç”¨çš„æ¯ä¸€ä¸ªå¯¹è±¡ï¼Œéƒ½è°ƒç”¨è®¿é—®è€…çš„è®¿é—®æ–¹æ³•ï¼Œä¹Ÿå°±æ˜¯ do\_XXX æ–¹æ³•ã€‚

è®¿é—®è€…æ¨¡å¼çš„ä¼˜ç‚¹å†ä¸€æ¬¡å±•ç°å¾—æ·‹æ¼“å°½è‡´ï¼Œè®¿é—®è€…å¯¹äºè¢«è®¿é—®è€…çš„å†…éƒ¨ç»“æ„å®Œå…¨ä¸å¿…çŸ¥æƒ…ï¼Œè®¿é—®åŠ¨ä½œçš„å…·ä½“å®ç°å®Œå…¨ç”±è¢«è®¿é—®è€…å†³å®šã€‚ç”±äº Universe å¯¹è‡ªå·±å¼•ç”¨äº†å“ªäº›å¯¹è±¡ååˆ†æ¸…æ¥šï¼Œæ‰€ä»¥åœ¨ oops\_do ä¸­ï¼Œå®ƒåˆ†åˆ«å¯¹è¿™äº›å¯¹è±¡è°ƒç”¨äº†ç›¸åº”ç±»å‹çš„ do\_XXX æ–¹æ³•ã€‚

ææ¸…æ¥šäº†è¿™ä¸ªåŸºæœ¬çš„ç»“æ„ï¼Œæˆ‘ä»¬å†æ¥åˆ†æ do\_XXX æ–¹æ³•æ˜¯å¦‚ä½•å®ç°çš„ã€‚ä½ çœ‹ä¸€ä¸‹æˆ‘ç»™å‡ºçš„ä»£ç ã€‚

```c++
void ScavengeOopClosure::do_oop(HiObject** oop) {
Â  Â  if (oop == NULL || *oop == NULL)
Â  Â  Â  Â  return;

Â  Â  // this oop has been handled, since it may be
Â  Â  // refered by Klass
Â  Â  if(!_from->has_obj((char*)*oop))
Â  Â  Â  Â  return;

Â  Â  (*oop) = copy_and_push(*oop);
}

HiObject* ScavengeOopClosure::copy_and_push(HiObject* obj) {
Â  Â  char* target = obj->new_address();
Â  Â  if (target) {
Â  Â  Â  Â  return (HiObject*)target;
Â  Â  }

Â  Â  // copy
Â  Â  size_t size = obj->size();
Â  Â  target = (char*)_to->allocate(size);
Â  Â  memcpy(target, obj, size);
Â  Â  obj->set_new_address(target);
Â  Â Â 
Â  Â  // push
Â  Â  _oop_stack->push((HiObject*)target);

Â  Â  return (HiObject*)target;
}
```

do\_oop çš„é€»è¾‘é™¤äº†ä¸€äº›å¿…è¦çš„æ£€æŸ¥ä¹‹å¤–ï¼Œå°±æ˜¯è°ƒç”¨äº† copy\_and\_push æ–¹æ³•ã€‚å¹¶ä¸”æŠŠè¿™æ¬¡è°ƒç”¨çš„è¿”å›å€¼æ›´æ–°åˆ° (\*oop) çš„ä½ç½®å»ã€‚

å¦‚å›¾æ‰€ç¤ºï¼Œå›¾ä¸­å±•ç¤ºäº†å¯¹è±¡ A ä» eden ç©ºé—´å¤åˆ¶åˆ° survivor ç©ºé—´ä»¥åï¼Œ(\*oop) å¤„çš„æŒ‡é’ˆå°†ä¼šæŒ‡å‘æ–°ç©ºé—´ä¸­çš„å¯¹è±¡ Aâ€™ã€‚

![å›¾ç‰‡](https://static001.geekbang.org/resource/image/84/d2/84e537f2afd291719daea44f11f8dfd2.png?wh=1918x810)

copy\_and\_push è¿™ä¸ªæ–¹æ³•ä¸»è¦åšäº†ä¸‰ä»¶äº‹æƒ…ã€‚

ç¬¬ä¸€ï¼Œæ£€æŸ¥è¯¥å¯¹è±¡æ˜¯å¦å·²ç»è¢«æ¬åˆ° to ç©ºé—´ä¸­äº†ï¼Œå¦‚æœå·²ç»è¢«æ¬çš„è¯ï¼Œé‚£ä¹ˆè€çš„ä½ç½®å°±ä¼šç•™ä¸‹ forwarding æŒ‡é’ˆã€‚å¦‚æœ forwarding ä¸ä¸ºç©ºï¼Œé‚£å°±ç›´æ¥è¿”å› forwarding æŒ‡é’ˆã€‚

ç¬¬äºŒï¼Œå¦‚æœè¯¥å¯¹è±¡æ²¡æœ‰è¢«æ¬åˆ° to ç©ºé—´ä¸­ï¼Œå°±è¿›è¡Œå¤åˆ¶æ“ä½œï¼ˆç¬¬ 20 è‡³ç¬¬ 23 è¡Œï¼‰ï¼Œå…ˆå–å¾—è¦æ¬ç§»å¯¹è±¡çš„å¤§å°ï¼Œç„¶ååœ¨ to ç©ºé—´ä¸­ç”³è¯·è¿™æ ·ä¸€å—å†…å­˜ï¼Œå†ä½¿ç”¨ memcpy æŠŠå¯¹è±¡ä» from ç©ºé—´æ¬åˆ° to ç©ºé—´ä¸­ï¼Œæœ€åæŠŠæ–°çš„åœ°å€ç•™åœ¨è€çš„å¯¹è±¡ä¸Šã€‚

ç¬¬ä¸‰ï¼Œå°±æ˜¯æŠŠè¿™ä¸ªå·²ç»æ¬ç§»å®Œçš„å¯¹è±¡æ”¾åˆ° \_oop\_stack ä¸­ã€‚åœ¨æ·±åº¦ä¼˜å…ˆæœç´¢ç®—æ³•é‡Œï¼Œäººä»¬ç»å¸¸ä½¿ç”¨ä¸‰ç§ä¸åŒçš„é¢œè‰²è¡¨ç¤ºä¸‰ç§ç±»å‹çš„ç»“ç‚¹ï¼Œå¦‚æœå®Œå…¨æœªè¢«è®¿é—®ï¼Œå°±ä½¿ç”¨ç™½è‰²è¡¨ç¤ºï¼›å¦‚æœè‡ªå·±å·²ç»è¢«å¤„ç†å®Œï¼Œä½†æ˜¯å®ƒå¯¹å…¶ä»–å¯¹è±¡çš„å¼•ç”¨è¿˜æœªè¢«å¤„ç†ï¼Œå°±ä½¿ç”¨ç°è‰²è¡¨ç¤ºï¼Œä»£è¡¨å°šæœªæ‰©å±•ï¼›å¦‚æœè‡ªå·±å·²ç»è¢«å¤åˆ¶ï¼Œå¹¶ä¸”å®ƒå¯¹å…¶ä»–å¯¹è±¡çš„æ‰€æœ‰å¼•ç”¨ä¹Ÿè¢«å¤„ç†å®Œï¼Œå°±ä½¿ç”¨é»‘è‰²è¡¨ç¤ºã€‚

æ˜¾ç„¶ï¼Œåœ¨ \_oop\_stack é‡Œçš„å¯¹è±¡å°±æ˜¯åˆšåˆšæåˆ°çš„ç°è‰²å¯¹è±¡ã€‚

è¿™æ®µä»£ç ä¸­ä½¿ç”¨äº† HiObject çš„ size å’Œ new\_address æ–¹æ³•ï¼Œæˆ‘ä»¬æ¥çœ‹ä¸‹å®ƒä»¬çš„å…·ä½“å®ç°ã€‚

```c++
class HiObject {
private:
Â  Â  longÂ  Â  _mark_word;
Â  Â  Klass*Â  _klass;
Â  Â  HiDict* _obj_dict;

public:
Â  Â  ...
Â  Â  // interfaces for GC.
Â  Â  void oops_do(OopClosure* closure);
Â  Â  size_t size();
Â  Â  char* new_address();
Â  Â  void set_new_address(char* addr);
};

char* HiObject::new_address() {
Â  Â  if ((_mark_word & 0x2) == 0x2)
Â  Â  Â  Â  return (char*)(_mark_word & ((long)-8));

Â  Â  return NULL;
}

void HiObject::set_new_address(char* addr) {
Â  Â  if (!addr)
Â  Â  Â  Â  return;

Â  Â  _mark_word = ((long)addr) | 0x2;
}

size_t HiObject::size() {
Â  Â  return klass()->size();
}
```

è¯·æ³¨æ„ï¼Œæˆ‘ä»¬åœ¨ HiObject ä¸­å¢åŠ äº†ä¸€ä¸ªåä¸º \_mark\_word çš„å±æ€§ï¼Œè€Œä¸”æŠŠå®ƒæ”¾åœ¨äº† HiObject å®šä¹‰çš„å¼€å§‹ä½ç½®ï¼Œä¹Ÿå°±æ˜¯åç§»ä¸º 0 çš„ä½ç½®ã€‚

åœ¨ HiObject ä¸­æ·»åŠ ä¸€ä¸ªåŸŸï¼Œæ„å‘³ç€å®ƒçš„æ‰€æœ‰å­ç±»å°±éƒ½æœ‰è¿™ä¸ªåŸŸäº†ï¼Œæ‰€ä»¥å¯¹äºæ•´å‹ã€å­—ç¬¦ä¸²ã€åˆ—è¡¨ã€å­—å…¸ç­‰ç±»å‹ï¼Œå®ƒä»¬ä¹Ÿå¯ä»¥ä½¿ç”¨ copy\_and\_push è¿™ä¸ªæ–¹æ³•è¿›è¡Œå¤åˆ¶å›æ”¶ã€‚

set\_new\_address æ–¹æ³•ï¼ˆç¬¬ 23 è‡³ 27 è¡Œï¼‰ä¸­ï¼Œå¹¶æ²¡æœ‰ç›´æ¥æŠŠæ–°çš„åœ°å€èµ‹å€¼ç»™ \_mark\_wordï¼Œè€Œæ˜¯æŠŠåœ°å€ä¸ 2 åšäº†äºŒè¿›åˆ¶æˆ–è¿ç®—ä»¥åï¼Œå†èµ‹å€¼ã€‚è¿™æ ·åšæ˜¯ä¸ºäº†åŒºåˆ† forwarding æŒ‡é’ˆã€‚åœ¨å®ç°å †çš„æ—¶å€™ï¼Œæˆ‘ä»¬å¼ºè°ƒäº†å¯¹é½çš„é—®é¢˜ï¼Œå½“æ—¶æåˆ°å¯¹é½å¯ä»¥ä¿è¯æ¯ä¸ªå¯¹è±¡éƒ½æ˜¯ 8 å­—èŠ‚å¯¹é½çš„ï¼Œè¿™å°±å†³å®šäº†æŒ‡å‘å®ƒä»¬çš„æŒ‡é’ˆçš„ä½ 3 ä½å°±ä¸€å®šæ˜¯ 0ï¼Œæ‰€ä»¥è¿™é‡ŒæŠŠä»ä½ä½å¼€å§‹çš„ç¬¬ 2 ä½ï¼Œç½®ä¸º 1 ç”¨æ¥è¡¨ç¤ºå½“å‰å¯¹è±¡å·²ç»è¢«æ¬ç§»åˆ°äº†æ–°åœ°å€ã€‚

åŒæ ·çš„é“ç†ï¼Œåœ¨ new\_address æ–¹æ³•ä¸­ï¼Œå¦‚æœå‘ç°äº†å½“å‰çš„ forwarding ä¸ä¸ºç©ºï¼Œå°±éœ€è¦æŠŠè¿™ä¸ªæŒ‡é’ˆçš„ä½ 3 ä½é‡æ–°ç½®ä¸º 0ï¼Œä¹Ÿå°±æ˜¯å’Œ -8 è¿›è¡Œä¸æ“ä½œã€‚åªæœ‰è¿™æ ·æ‰èƒ½æ‹¿åˆ°æ–°ç©ºé—´ä¸­ç›¸åº”å¯¹è±¡çš„æ­£ç¡®åœ°å€ã€‚

åœ¨ä»£ç çš„æœ€åï¼Œå®ç°äº† size æ–¹æ³•ï¼Œè¿™ä¸ªæ–¹æ³•å¿…é¡»å¾—æ­£ç¡®å®ç°ï¼Œç„¶åå¤åˆ¶æ‰èƒ½æ­£ç¡®æ‰§è¡Œã€‚ä¸ HiObject ä¸Šå®šä¹‰çš„ addã€subã€print ç­‰æ“ä½œç±»ä¼¼ï¼Œæˆ‘ä»¬æŠŠè¿™ä¸ªæ˜æ˜¾éœ€è¦å¤šæ€å®ç°çš„æ–¹æ³•è½¬ç§»åˆ° klass é‡Œå»äº†ã€‚ä½ å¯ä»¥çœ‹ä¸€ä¸‹ç›¸åº”çš„ä»£ç ã€‚

```c++
class Klass {
public:
Â  Â  ...
Â  Â  virtual size_t size();
};

size_t IntegerKlass::size() {
Â  Â  return sizeof(HiInteger);
}

size_t DictKlass::size() {
Â  Â  return sizeof(HiDict);
}
....
```

åœ¨ Klass é‡Œå®šä¹‰è™šæ–¹æ³• sizeï¼Œç„¶åä¸ºæ¯ä¸€ä¸ªå¯èƒ½è¢«å¤åˆ¶çš„ç±»å‹å®ç°å®ƒçš„ size æ–¹æ³•å°±å¯ä»¥äº†ã€‚è¿™ä¸ªåŠ¨ä½œå¾ˆç®€å•ï¼Œä½†æ¯”è¾ƒçƒ¦çï¼Œå› ä¸ºè¦ä¸ºæ‰€æœ‰çš„ç±»å‹æ·»åŠ  size æ–¹æ³•ã€‚ä¸€æ—¦æŸä¸ªç±»å‹æ²¡æœ‰å®ç°ï¼Œé‚£ä¹ˆåœ¨æ‰§è¡Œåƒåœ¾å›æ”¶çš„è¿‡ç¨‹ä¸­ï¼Œå®ƒå°±ä¸èƒ½è¢«æ­£ç¡®åœ°å¤åˆ¶ã€‚

åˆ°è¿™é‡Œï¼Œå¤åˆ¶ä¸€ä¸ªå¯¹è±¡ï¼Œå¹¶è®¾ç½®å®ƒçš„ forwarding æŒ‡é’ˆçš„å·¥ä½œå°±å…¨éƒ¨å®Œæˆäº†ã€‚è¿™äº›å¯¹è±¡å¯¹å…¶ä»–å¯¹è±¡çš„å¼•ç”¨è¿˜æ²¡æœ‰è¢«å¤„ç†ï¼Œæ‰€ä»¥å®ƒä»¬éƒ½åœ¨ \_oop\_stack ä¸­ç­‰å¾…è¿›ä¸€æ­¥å¤„ç†ã€‚

æˆ‘ä»¬å†å›åˆ° process\_roots æ–¹æ³•ä¸­æ¥ï¼ŒUniverse å·²ç»å¤„ç†å®Œäº†ï¼Œæ¥ç€å°±è¦å¤„ç† Interpreterã€‚æˆ‘ä»¬çœ‹ä¸€ä¸‹ Interpreter çš„ oops\_do çš„å®ç°ã€‚

```c++
void Interpreter::oops_do(OopClosure* f) {
Â  Â  f->do_oop((HiObject**)&_builtins);
Â  Â  f->do_oop((HiObject**)&_ret_value);

Â  Â  if (_frame)
Â  Â  Â  Â  _frame->oops_do(f);
}

void FrameObject::oops_do(OopClosure* f) {
Â  Â  f->do_oop((HiObject**)&_stack);
Â  Â  f->do_oop((HiObject**)&_consts);
Â  Â  f->do_oop((HiObject**)&_names);

Â  Â  f->do_oop((HiObject**)&_locals);
Â  Â  f->do_oop((HiObject**)&_globals);
Â  Â  f->do_oop((HiObject**)&_closure);
Â  Â  f->do_oop((HiObject**)&_fast_locals);

Â  Â  f->do_oop((HiObject**)&_codes);

Â  Â  if (_sender)
Â  Â  Â  Â  _sender->oops_do(f);
}

```

åœ¨ Interpreter çš„å®ä¾‹ä¸­ï¼Œåªæœ‰ä¸‰ä¸ªæŒ‡å‘å¯¹è±¡çš„å¼•ç”¨ï¼Œæ‰€ä»¥å®ƒçš„ oops\_do æ–¹æ³•é‡Œå°±å¯¹è¿™ä¸‰ä¸ªå¯¹è±¡åˆ†åˆ«è¿›è¡Œè®¿é—®ã€‚

æœ‰ä¸€ä¸ªåœ°æ–¹æ˜¯éœ€è¦ç‰¹åˆ«æ³¨æ„çš„ï¼Œå°±æ˜¯ **FrameObject**ï¼Œè™½ç„¶å‘½åä¸Šå®ƒæ˜¯ä¸€ä¸ª Objectï¼Œä½†å®é™…ä¸Šå®ƒå¹¶æ²¡æœ‰ç»§æ‰¿è‡ª HiObjectã€‚æ‰€ä»¥æˆ‘ä»¬ä¸å¿…å¤åˆ¶è¿™ä¸ªå¯¹è±¡ï¼Œä¹Ÿå°±æ˜¯æ²¡æœ‰ä½¿ç”¨ f-&gt;do\_oop è¿™ç§æ–¹å¼å»è®¿é—® \_frameã€‚

frame å¯¹è±¡çš„å¼•ç”¨æƒ…å†µä¸‹å›¾æ‰€ç¤ºï¼Œå¯ä»¥çœ‹åˆ°ï¼Œframe å¯¹è±¡çš„ sender å¹¶ä¸æŒ‡å‘å †å†…ï¼Œä½† globalsã€locals ç­‰éƒ½æ˜¯æŒ‡å‘å †å†…çš„ã€‚æ‰€ä»¥ï¼Œåªéœ€è¦ç›´æ¥è°ƒç”¨ FrameObject çš„ oops\_do æ–¹æ³•å³å¯ã€‚

![å›¾ç‰‡](https://static001.geekbang.org/resource/image/21/e8/21592b07e25ebf61c429b7a969a273e8.png?wh=2058x784)

åœ¨ FrameObject çš„ oops\_do æ–¹æ³•ä¸­ï¼ŒOopClosure å¯¹ FrameObject çš„æ‰€æœ‰å¼•ç”¨è¿›è¡Œè®¿é—®ã€‚å½“è®¿é—®åˆ° \_sender çš„æ—¶å€™ï¼Œå’Œç¬¬ä¸€æ¬¡è®¿é—® FrameObject ä¸€æ ·ï¼Œä¸å¿…å†ä½¿ç”¨ do\_oop è¿›è¡Œè®¿é—®ï¼Œè€Œæ˜¯ç›´æ¥è°ƒç”¨ \_sender çš„ oops\_do æ–¹æ³•ã€‚

å½“ process\_roots ç»“æŸä»¥åï¼Œæ ¹å¯¹è±¡å°±å…¨éƒ¨å¤åˆ¶å®Œäº†ï¼Œç”±äºå®ƒä»¬çš„å¼•ç”¨è¿˜æ²¡æœ‰å®Œå…¨è®¿é—®å®Œï¼Œæ‰€ä»¥å®ƒä»¬éƒ½ä¼šè¢«å­˜å‚¨åœ¨ \_oop\_stack ä¸­ï¼Œç­‰å¾…è¢«è¿›ä¸€æ­¥å¤„ç†ã€‚

## å¤„ç†æ™®é€šå¯¹è±¡

scavenge æ–¹æ³•çš„ç¬¬äºŒæ­¥ï¼Œå°±æ˜¯ä¸æ–­åœ°ä» \_oop\_stack ä¸­å–å‡ºå¯¹è±¡ï¼Œç„¶åè°ƒç”¨è¿™ä¸ªå¯¹è±¡çš„ \_oops\_do æ–¹æ³•ã€‚

æ³¨æ„ï¼Œç”±äºè¿™äº›å¯¹è±¡è‡ªèº«æ˜¯å·²ç»å¤åˆ¶å®Œäº†çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬å°±ä¸èƒ½å†è°ƒç”¨ OopClosure çš„ do\_oop æ–¹æ³•äº†ï¼Œè€Œæ˜¯åƒç¨‹åºä¸­å±•ç¤ºçš„é‚£æ ·ï¼Œç›´æ¥è°ƒç”¨å¯¹è±¡çš„ \_oops\_do æ–¹æ³•ã€‚

åœ¨ scavenge æ–¹æ³•ä¸­ï¼Œè°ƒç”¨ HiObject çš„ \_oops\_do æ–¹æ³•æ—¶ï¼Œæˆ‘ä»¬ä¸éœ€è¦å»ç®¡è¿™ä¸ªå¯¹è±¡çš„å®é™…ç±»å‹æ˜¯ä»€ä¹ˆï¼Œå®ƒçš„å®é™…ç±»å‹ä¼šåœ¨ \_oops\_do æ–¹æ³•æ‰§è¡Œçš„æ—¶å€™è‡ªåŠ¨å†³å®šã€‚

```c++
void HiObject::oops_do(OopClosure* closure) {
Â  Â  // object does not know who to visit, klass knows
Â  Â  closure->do_oop((HiObject**)&_obj_dict);
Â  Â  klass()->oops_do(closure, this);
}
```

HiObject çš„ oops\_do æ–¹æ³•å…ˆè®¿é—®äº† \_obj\_dictï¼Œå› ä¸ºè¿™æ˜¯æ‰€æœ‰ HiObject éƒ½å…·æœ‰çš„å±æ€§ï¼Œæ‰€ä»¥æ”¾åœ¨ HiObject çš„ oops\_do æ–¹æ³•ä¸­æ˜¯æœ€åˆé€‚çš„ã€‚

ç„¶åï¼Œå°±åƒæ³¨é‡Šæ‰€è¯´ï¼Œæˆ‘ä»¬è½¬è€Œè°ƒç”¨å¯¹è±¡æ‰€å¯¹åº”çš„ klass çš„ oops\_do æ–¹æ³•ã€‚åœ¨ä¸åŒçš„ç±»å‹ä¸­ï¼Œåˆ†åˆ«æ‰§è¡Œä¸åŒçš„é€»è¾‘ã€‚æˆ‘ä»¬ä»¥å­—ç¬¦ä¸²ç±»å‹ä¸ºä¾‹çœ‹ä¸€çœ‹ã€‚

```c++
class HiString : public HiObject {
private:
Â  Â  char* _value;
Â  Â  intÂ  Â _length;

public:
Â  Â  ...
Â  Â  char** value_address()Â  { return &_value; }
};

void StringKlass::oops_do(OopClosure* closure, HiObject* obj) {
    HiString* str_obj = obj->as<HiString>();
    closure->do_raw_mem(str_obj->value_address(), str_obj->length());
}
```

å­—ç¬¦ä¸²ç±»å‹æœ‰ä¸¤ä¸ªå±æ€§ï¼Œä¸€ä¸ªæ˜¯ä»£è¡¨é•¿åº¦çš„æ•´å‹ï¼Œè¿™ä¸ªå€¼å·²ç»éšç€å­—ç¬¦ä¸²å¯¹è±¡ä¸€èµ·å¤åˆ¶åˆ° to ç©ºé—´ä¸­äº†ã€‚ç°åœ¨æ‰€è¦åšçš„ï¼Œåªæ˜¯æŠŠä»£è¡¨å­—ç¬¦ä¸²å†…å®¹çš„ char ç±»å‹çš„æ•°ç»„ä¹Ÿå¤åˆ¶åˆ° to ç©ºé—´ä¸­ã€‚

å¯¹äºæ™®é€šçš„å­—ç¬¦ä¸²æ•°ç»„ï¼Œæˆ‘ä»¬æ˜¯ä½¿ç”¨ do\_raw\_mem æ–¹æ³•è¿›è¡Œå¤åˆ¶çš„ã€‚

```c++
void ScavengeOopClosure::do_raw_mem(char** mem, int length) {
Â  Â  if (*mem == NULL)
Â  Â  Â  Â  return;

Â  Â  char* target = (char*)_to->allocate(length);
Â  Â  memcpy(target, (*mem), length);
Â  Â  (*mem) = target;
}
```

do\_raw\_mem çš„é€»è¾‘ä»…ä»…æ˜¯åœ¨ to ç©ºé—´ä¸­åˆ†é…ä¸€å—å†…å­˜ï¼Œç„¶åæŠŠ from ç©ºé—´ä¸­çš„å†…å®¹å¤åˆ¶åˆ° to ç©ºé—´ä¸­ã€‚å†ä¿®æ”¹å¼•ç”¨çš„å†…å®¹ï¼Œè®©å®ƒæŒ‡å‘ to ç©ºé—´ä¸­çš„åœ°å€å³å¯ã€‚

å…¶å®ƒçš„è™šæ‹Ÿæœºå†…å»ºå¯¹è±¡ï¼Œå¦‚ HiIntegerã€HiTypeObjectã€HiDict ç­‰ï¼Œå®ç°æ€è·¯å’Œ HiString ååˆ†ç›¸ä¼¼ï¼Œæˆ‘ä»¬å°±ä¸å†å±•å¼€æ¼”ç¤ºäº†ï¼Œä½ å¯ä»¥è‡ªå·±å®ç°ã€‚

### å¤„ç†åˆ—è¡¨

åœ¨ ScavengeOopClosure ä¸­æ¯”è¾ƒæœ‰éš¾åº¦çš„æ˜¯ç”¨äºè®¿é—® ArrayList çš„æ–¹æ³•ï¼Œä¹Ÿå°±æ˜¯ do\_array\_list æ–¹æ³•ã€‚å®ƒçš„éš¾ç‚¹åœ¨äºï¼ŒArrayList æ˜¯ä¸€ä¸ªæ³›å‹ç±»ï¼Œæ‰€ä»¥å¯¹å®ƒçš„è®¿é—®å¿…é¡»ååˆ†å°å¿ƒã€‚æˆ‘ä»¬æ¥çœ‹ä¸€ä¸ªå…·ä½“çš„åœºæ™¯ã€‚

```c++
void ScavengeOopClosure::do_array_list(ArrayList<Klass*>** alist) {
Â  Â  do_array_list_nv<Klass*>(alist);
}

void ScavengeOopClosure::do_array_list(ArrayList<HiObject*>** alist) {
Â  Â  do_array_list_nv<HiObject*>(alist);
}

void ScavengeOopClosure::do_array_list(ArrayList<char>** alist) {
Â  Â  do_array_list_nv<char>(alist);
}

template <typename T>
void ScavengeOopClosure::do_array_list_nv(ArrayList<T>** alist) {
Â  Â  if (alist == NULL || *alist == NULL)
Â  Â  Â  Â  return;

Â  Â  assert(_from->has_obj((char*)*alist));

Â  Â  size_t size = sizeof(ArrayList<T>);
Â  Â  char* target = (char*)_to->allocate(size);
Â  Â  memcpy(target, (*alist), size);
Â  Â  (*(char**)alist) = target;
Â  Â  (*alist)->oops_do(this);
}
```

åœ¨è¿™ä¸ªåœºæ™¯ä¸‹ï¼Œ`ArrayList<Klass>` å’Œ `ArrayList<HiObject>` è¿™ä¸¤ç§ç±»å‹çš„å¤„ç†é€»è¾‘å…¶å®æ˜¯ä¸€æ ·çš„ã€‚æ‰€ä»¥æœ€å¥½åŠæ³•æ˜¯æŠŠ do\_array\_list æ–¹æ³•å®ç°ä¸ºæ³›å‹æ–¹æ³•ã€‚ä½†æ˜¯ç”±äº**C++ ä¸­çš„è™šæ–¹æ³•ä¸å¯ä»¥æ˜¯æ¨¡æ¿æ–¹æ³•**ï¼Œæ‰€ä»¥è¿™é‡Œæˆ‘é‡‡ç”¨ä¸€ç‚¹å°æŠ€å·§åšäº†ä¸€æ¬¡è½¬æ¢ã€‚

é¦–å…ˆï¼Œæˆ‘ä»¬å¼•å…¥äº† do\_array\_list\_nv è¿™ä¸ªæ³›å‹æ–¹æ³•ã€‚å®ƒæ˜¯ä¸€ä¸ªéè™šæ–¹æ³•ï¼Œç»“å°¾å¤„çš„ nv ä»£è¡¨ non-virtualï¼Œè¡¨æ˜è¿™æ˜¯ä¸€ä¸ªéè™šæ–¹æ³•ã€‚å¤„ç†å¯¹è±¡çš„å…·ä½“é€»è¾‘å°±åœ¨è¿™ä¸ªæ–¹æ³•ä¸­å®ç°ã€‚è€Œå¤„ç† HiOjbect åˆ—è¡¨å’Œ Klass åˆ—è¡¨çš„æ–¹æ³•ï¼Œåˆ™æ‰‹åŠ¨è¿›è¡Œé‡è½½ã€‚è¿™æ ·å°±å¯ä»¥è§£å†³è™šæ–¹æ³•ä¸å¯ä»¥æ˜¯æ¨¡æ¿æ–¹æ³•çš„é—®é¢˜ã€‚

do\_array\_list çš„é€»è¾‘å’Œ do\_raw\_mem çš„é€»è¾‘å¾ˆç›¸ä¼¼ï¼Œéƒ½æ˜¯åœ¨ to ç©ºé—´ä¸­ç”³è¯·ä¸€å—å†…å­˜ï¼ŒæŠŠå¯¹è±¡ä» from ç©ºé—´å¤åˆ¶åˆ° to ç©ºé—´ï¼Œå¹¶æ›´æ–°å¼•ç”¨å¤„çš„æŒ‡é’ˆã€‚

ArrayList ä¸æ˜¯ HiObjectï¼Œæ‰€ä»¥å°±æ²¡æœ‰ forwarding æœºåˆ¶ï¼Œç”±äº ArrayList åŸºæœ¬éƒ½æ˜¯ä½œä¸º HiObject å¯¹è±¡çš„å†…éƒ¨å±æ€§ï¼Œåªä¼šè¢«ä¸€ä¸ªå¯¹è±¡æ‰€å¼•ç”¨ï¼Œæ‰€ä»¥è¿™ä¹Ÿä¸ä¼šæœ‰ä»€ä¹ˆé—®é¢˜ã€‚

do\_array\_list çš„æœ€åï¼Œè¿˜è¦è°ƒç”¨ ArrayList çš„ oops\_do æ–¹æ³•ï¼ŒæŠŠ ArrayList é‡Œæ‰€å¼•ç”¨çš„å¯¹è±¡å…¨éƒ¨æ‹·è´åˆ° to ç©ºé—´ä¸­å»ã€‚

```c++
template <>
void ArrayList<Klass*>::oops_do(OopClosure* closure) {
Â  Â  closure->do_raw_mem((char**)(&_array),Â 
Â  Â  Â  Â  Â  Â  _length * sizeof(Klass*));

Â  Â  for (int i = 0; i < size(); i++) {
Â  Â  Â  Â  closure->do_klass((Klass**)&_array[i]);
Â  Â  }
Â  Â  return;
}

template <>
void ArrayList<HiObject*>::oops_do(OopClosure* closure) {
Â  Â  closure->do_raw_mem((char**)(&_array),Â 
Â  Â  Â  Â  Â  Â  _length * sizeof(HiObject*));

Â  Â  for (int i = 0; i < size(); i++) {
Â  Â  Â  Â  closure->do_oop((HiObject**)&_array[i]);
Â  Â  }
}
```

åœ¨ ArrayList ä¸­ï¼Œæˆ‘ä»¬é™¤äº†è¦æŠŠæ•°ç»„é€šè¿‡ do\_raw\_mem å¤åˆ¶åˆ° to ç©ºé—´ï¼Œè¿˜è¦å†éå†æ•°ç»„ \_arrayï¼ŒæŠŠå…¶ä¸­çš„å…ƒç´ éƒ½è®¿é—®ä¸€éã€‚

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œç”±äº ArrayList ç±»æœ¬èº«æ˜¯ä¸€ä¸ªæ¨¡æ¿ç±»ï¼Œå…ƒç´ ç±»å‹æ˜¯ Klass æŒ‡é’ˆä¸å…ƒç´ ç±»å‹æ˜¯ HiObject æŒ‡é’ˆï¼Œæ‰€ä½¿ç”¨çš„æ–¹æ³•æ˜¯ä¸ä¸€æ ·çš„ï¼ˆæ³¨æ„æ¯”è¾ƒç¬¬ 7 è¡Œå’Œç¬¬ 18 è¡Œï¼‰ã€‚æ‰€ä»¥æˆ‘ä»¬å¿…é¡»ä½¿ç”¨**æ¨¡æ¿åç‰¹åŒ–**çš„æŠ€å·§æ¥å®ç°è¿™ä¸¤ä¸ªæ–¹æ³•ã€‚è¿™å·²ç»æ˜¯æˆ‘ä»¬ç¬¬äºŒæ¬¡ä½¿ç”¨æ¨¡æ¿åç‰¹åŒ–æ¥å¤„ç†ç±»å‹ä¸ç›¸åŒçš„æ—¶å€™ä¸åŒé€»è¾‘äº†ï¼Œä¸Šä¸€æ¬¡æ˜¯åœ¨ç¬¬ 15 è¯¾å¤„ç†å­—å…¸çš„éå†é—®é¢˜æ—¶ä½¿ç”¨çš„ã€‚

é’ˆå¯¹åˆ—è¡¨çš„åƒåœ¾å›æ”¶æ”¹é€ å®Œæˆä»¥åï¼Œæˆ‘ä»¬å†æ¥çœ‹å­—å…¸çš„ã€‚

### å¤„ç†map

å­—å…¸ä¸­æ‰€ä½¿ç”¨çš„ Map ç±»å‹å’Œ ArrayList çš„é“ç†æ˜¯ä¸€æ ·çš„ï¼Œè€Œä¸”æ›´ç®€å•ï¼Œå› ä¸ºæˆ‘ä»¬åªç”¨åˆ°äº†ä¸€ç§å®ä¾‹çš„ Mapï¼Œé‚£å°±æ˜¯ `Map<HiObject*, HiObject*>`ã€‚

```c++
// [memory/oopClosure.cpp]
void ScavengeOopClosure::do_map(Map<HiObject*, HiObject*>** amap) {
Â  Â  if (amap == NULL || *amap == NULL)
Â  Â  Â  Â  return;

Â  Â  assert(_from->has_obj((char*)*amap));

Â  Â  size_t size = sizeof(Map<HiObject*, HiObject*>);
Â  Â  char* target = (char*)_to->allocate(size);
Â  Â  memcpy(target, (*amap), size);
Â  Â  (*(char**)amap) = target;
Â  Â  (*amap)->oops_do(this);
}

// [util/map.cpp]
template <typename K, typename V>
void Map<K, V>::oops_do(OopClosure* closure) {
Â  Â  closure->do_raw_mem((char**)(&_entries),Â 
Â  Â  Â  Â  Â  Â  _length * sizeof(MapEntry<K, V>));
Â  Â  for (int i = 0; i < _size; i++) {
Â  Â  Â  Â  closure->do_oop(&(_entries[i]._k));
Â  Â  Â  Â  closure->do_oop(&(_entries[i]._v));
Â  Â  }
}
```

è¿™æ®µä»£ç çš„é€»è¾‘ç›¸å¯¹æ¯”è¾ƒç®€å•ï¼Œä½ å¯ä»¥è‡ªå·±ç ”ç©¶ä¸€ä¸‹ï¼Œè¿™é‡Œå°±ä¸å†è®²è§£äº†ã€‚

é™¤æ­¤ä¹‹å¤–ï¼Œè¿˜æœ‰å¤„ç† Klass ç›¸å…³çš„å®ç°ï¼Œè¿™é‡Œç•™ç»™ä½ è‡ªå·±åŠ¨æ‰‹å®ç°ï¼Œä½ å¯ä»¥æ‹¿å®ƒæ¥ç»ƒæ‰‹ã€‚

## å¤„ç†è™šæ‹Ÿæœºæ ˆå¸§ä¸­çš„å¼•ç”¨

å¦‚æœåœ¨è™šæ‹Ÿæœºæ ˆå¸§é‡Œï¼ˆå³ C++ ä»£ç æ‰€åˆ›å»ºçš„æ ˆå¸§ï¼‰å¼•ç”¨äº†å †ä¸­çš„å¯¹è±¡ï¼Œåœ¨è¿™ä¸ªå¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸä¸­å‘ç”Ÿäº†åƒåœ¾å›æ”¶ï¼Œè¿™ä¸ªå¯¹è±¡çš„å¼•ç”¨å°±æ²¡åŠæ³•è¢«æ­£ç¡®ç»´æŠ¤ã€‚æˆ‘ä»¬æ¥çœ‹ä¸€ä¸ªä¾‹å­ã€‚

```plain
void FrameObject::initialize(FunctionObject* func,
        HiList* args, HiList* kwargs) {
    // .....
    // å¤„ç†é—­åŒ…ä¸­çš„cell vars
    HiList* cells = _codes->_cell_vars;
    if (cells && cells->length() > 0) {
        _closure = HiList::new_instance();

        for (int i = 0; i < cells->length(); i++) {
            _closure->append(nullptr);
        }
    }
    // ...
}
```

å½“ç¨‹åºæ‰§è¡Œåˆ°ç¬¬ 7 è¡Œçš„æ—¶å€™ï¼Œcells å˜é‡æ‰€å¯¹åº”çš„æŒ‡é’ˆä¼šå‡ºç°åœ¨ initialize å‡½æ•°çš„æ ˆå¸§ï¼Œå¹¶ä¸”æŒ‡å‘å †ä¸­ã€‚å¦‚æœè¿™æ—¶å †çš„ç©ºé—´ä¸è¶³ä»¥å†åˆ›å»ºä¸€ä¸ªåˆ—è¡¨ï¼Œå°±ä¼šå‘ç”Ÿåƒåœ¾å›æ”¶ã€‚

å¯æ˜¯ï¼Œç”±äºåƒåœ¾å›æ”¶å™¨å¹¶ä¸çŸ¥é“å †ä¸Šè¿˜æœ‰è¿™æ ·ä¸€ä¸ªæŒ‡é’ˆï¼Œæ‰€ä»¥åœ¨è¿›è¡Œå¯¹è±¡æ¬ç§»çš„æ—¶å€™ï¼Œå°±ä¼šé—æ¼ï¼Œè¿™å°±æ˜¯**æ´»è·ƒå¯¹è±¡çš„æ¼æ ‡**ã€‚å½“åƒåœ¾å›æ”¶ç»“æŸä»¥åï¼Œå†è®¿é—® cells å˜é‡çš„æ—¶å€™å°±ä¼šå‘ç”Ÿä¸¥é‡çš„é”™è¯¯ï¼Œå› ä¸º cells æ‰€æŒ‡å‘çš„ä½ç½®å·²ç»è¢«åƒåœ¾å›æ”¶å™¨æ¸…ç©ºäº†ã€‚

ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬å°±éœ€è¦ä½¿ç”¨ä¸€ç§æœºåˆ¶ï¼ŒæŠŠç”Ÿå‘½å‘¨æœŸä¼šè·¨è¶Šåƒåœ¾å›æ”¶çš„æŒ‡é’ˆå˜é‡è®°å½•ä¸‹æ¥ï¼Œå¹¶é€šçŸ¥åƒåœ¾å›æ”¶å™¨åŠæ—¶æ­£ç¡®åœ°ç»´æŠ¤è¿™ä¸ªæŒ‡é’ˆã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬å¼•å…¥äº† Handle ç±»å‹ï¼Œä»¥åŒå‘é“¾è¡¨çš„æ–¹å¼æŠŠæ‰€æœ‰çš„æŒ‡é’ˆå˜é‡è®°å½•ä¸‹æ¥ã€‚ä½ å¯ä»¥çœ‹ä¸€ä¸‹Handle çš„å®šä¹‰ã€‚

```c++
class LinkedList {
friend class HandleMark;
private:
    LinkedList* _next;
    LinkedList* _prev;

public:
    LinkedList();

    virtual void oops_do(OopClosure* f) = 0;
};

template <typename T>
class Handle : public LinkedList {
protected:
    T _value;

public:
    Handle(T t);
    Handle(const Handle<T>& t);
    ~Handle();

    virtual void oops_do(OopClosure* f);
    T operator ->();
    T operator ()() { return _value; }
    operator T()    { return _value; }
    void operator =(T v)  { _value = v; }
    void operator =(Handle<T>& v)  { _value = v(); }
    bool operator ==(Handle<T>& v) { return _value == v(); }
    bool operator ==(T v)         { return _value == v; }
    bool operator !=(Handle<T>& v) { return _value != v(); }
    bool operator !=(T v)         { return _value != v; }
};

class HandleMark {
private:
    static HandleMark* instance;
    LinkedList* _head;

public:
    HandleMark();

    static HandleMark* get_instance();
    void oops_do(OopClosure* f);
    LinkedList* head()           { return _head; }
    void set_head(LinkedList* x);
    void del_handle(LinkedList* x);
};
```

å…¶ä¸­ï¼ŒHandle çš„å®šä¹‰çœ‹ä¸Šå»å¾ˆåƒä¸€ä¸ªæ™ºèƒ½æŒ‡é’ˆï¼Œæ”¯æŒæ‹¬å·æ“ä½œç¬¦ã€ç®­å¤´å·æ“ä½œç¬¦ç­‰ç­‰ã€‚

åœ¨å®ƒçš„æ„é€ å‡½æ•°é‡Œï¼Œä¼šæŠŠè‡ªå·±æ·»åŠ åˆ° HandleMark çš„ \_head å˜é‡æ‰€è®°å½•çš„åŒå‘é“¾è¡¨ä¸­ã€‚ä½ å¯ä»¥çœ‹ä¸€ä¸‹å®ƒçš„å…·ä½“å®ç°ã€‚

```c++
void HandleMark::set_head(LinkedList* node) {
    if (_head) {
        _head->_prev = node;
    }
    node->_next = _head;
    _head = node;
}

void HandleMark::del_handle(LinkedList* node) {
    LinkedList* prev = node->_prev;
    LinkedList* next = node->_next;

    if (prev) {
        prev->_next = next;
    }

    if (next) {
        next->_prev = prev;
    }

    if (_head == node) {
        _head = next;
    }
}

template<typename T>
Handle<T>::Handle(T t) : LinkedList() {
    _value = t;
    HandleMark::get_instance()->set_head(this);
}

template<typename T>
Handle<T>::Handle(const Handle<T>& t) : LinkedList() {
    _value = t._value;
    HandleMark::get_instance()->set_head(this);
}

template<typename T>
Handle<T>::~Handle() {
    _value = 0x0;
    HandleMark::get_instance()->del_handle(this);
}
```

set\_head æ–¹æ³•çš„ä½œç”¨æ˜¯æŠŠä¸€ä¸ªæ–°çš„ç»“ç‚¹åŠ å…¥åˆ°é“¾è¡¨ä¸­ï¼Œè€Œä¸”æ¯æ¬¡éƒ½æ˜¯æ·»åŠ åˆ°é“¾è¡¨çš„å¤´ä¸Šã€‚del\_handle æ–¹æ³•åˆ™ç”¨äºä»åŒå‘é“¾è¡¨ä¸­åˆ é™¤ä¸€ä¸ªç»“ç‚¹ã€‚è¿™æ˜¯éå¸¸å¸¸è§çš„åŒå‘é“¾è¡¨æ“ä½œã€‚

åœ¨ Handle çš„æ„é€ å‡½æ•°ï¼ˆç¬¬ 26 è‡³ 30 è¡Œï¼‰å’Œå¤åˆ¶æ„é€ å‡½æ•°ï¼ˆç¬¬ 32 è‡³ 36 è¡Œï¼‰ä¸­ï¼Œä¼šæŠŠè‡ªå·±æ·»åŠ åˆ°åŒå‘é“¾è¡¨ã€‚è€Œææ„å‡½æ•°ï¼ˆç¬¬ 38 è‡³ 42 è¡Œï¼‰åˆ™è´Ÿè´£ä»é“¾è¡¨ä¸­åˆ é™¤ã€‚

æœ€åï¼Œå†é€šè¿‡ HandleMark éå†é“¾è¡¨é‡Œçš„æ‰€æœ‰å…ƒç´ ï¼Œè®©åƒåœ¾å›æ”¶å™¨å¯ä»¥æ­£ç¡®åœ°ç»´æŠ¤ Handle ä¸­æ‰€è®°å½•çš„æŒ‡é’ˆã€‚

```c++
void HandleMark::oops_do(OopClosure* f) {
    LinkedList* cur = _head;
    while (cur) {
        cur->oops_do(f);
        cur = cur->_next;
    }
}
```

é€šè¿‡è¿™ç§æ–¹å¼ï¼Œè™šæ‹Ÿæœºæ ˆå¸§çš„å¼•ç”¨å°±éƒ½å¯ä»¥è¢«æ­£ç¡®åœ°ç»´æŠ¤äº†ã€‚æœ€åï¼Œå¯ä»¥é€šè¿‡ä»¥ä¸‹ç”¨ä¾‹æ¥æµ‹è¯•æˆ‘ä»¬è¿™ä¸ª GC ç®—æ³•çš„å¯é æ€§ï¼Œä½ å¯ä»¥è°ƒæ•´ä¸€ä¸‹å †çš„å¤§å°ï¼Œç„¶åè§‚å¯Ÿè¿™ä¸ªç¨‹åºçš„è¾“å‡ºæƒ…å†µä»¥åŠæ€§èƒ½å˜åŒ–æƒ…å†µã€‚

```python
i = 0

while i < 2147482647:
Â  Â  i = i + 1
Â  Â  if i % 1000000 == 0:
Â  Â  Â  Â  print i
```

åˆ°è¿™é‡Œï¼Œæˆ‘ä»¬å°±ä¸ºè™šæ‹Ÿæœºå®ç°å¥½äº† GCã€‚è¿™ä¸ªå¤åˆ¶ç®—æ³•æ˜¯æ¯”è¾ƒåŸºç¡€çš„ï¼Œè‡ªåŠ¨å†…å­˜ç®¡ç†è¿˜æœ‰å¾ˆå¤šä¼˜ç§€çš„ç®—æ³•ï¼Œä½ å¯ä»¥å°½æƒ…åœ°å°è¯•å®ç°ã€‚æˆ‘ä»¬ä½¿ç”¨è®¿é—®è€…æ¨¡å¼æ„å»ºçš„è¿™ä¸€å¥— GC çš„æ¡†æ¶ï¼Œæœªæ¥æ‰©å±•éå¸¸æ–¹ä¾¿ã€‚

## æ€»ç»“

ç¬¬ 23 è¯¾æˆ‘ä»¬ä»‹ç»äº†å¤åˆ¶ç®—æ³•çš„åŸºæœ¬æ­¥éª¤ï¼Œè¿™ä¸€èŠ‚è¯¾å°±èšç„¦äºä»£ç å®ç°ã€‚å®ç°å¤åˆ¶ç®—æ³•ä¸»è¦ä¸»è¦æœ‰å››æ­¥ã€‚

1. å¤„ç†æ ¹é›†åˆã€‚æŠŠ Universeã€FrameObject ä¸­çš„å¼•ç”¨åšä¸ºæ ¹ï¼Œå¯¹å®ƒä»¬æ‰€å¼•ç”¨çš„å¯¹è±¡éƒ½è¿›è¡Œæ¬ç§»ï¼Œå¹¶ä¸”æŠŠè¿™äº›å¯¹è±¡æ”¾å…¥æ ˆä¸­ã€‚
2. å¯¹æ ˆä¸­çš„å¯¹è±¡è¿›è¡Œéé€’å½’çš„æ·±åº¦ä¼˜å…ˆéå†ï¼Œä»è€ŒæŠŠæ‰€æœ‰çš„æ´»è·ƒå¯¹è±¡éƒ½æ¬ç§»åˆ°æ–°ç©ºé—´ä¸­å»ã€‚
3. ä½¿ç”¨ forwarding æŒ‡é’ˆè§£å†³å¤šä¸ªå¯¹è±¡å¼•ç”¨åŒä¸€ä¸ªå¯¹è±¡çš„æƒ…å†µã€‚
4. ä½¿ç”¨ Handle è®°å½•è™šæ‹Ÿæœºæ ˆå¸§ä¸Šçš„å¼•ç”¨ã€‚

å®Œæˆäº†è¿™äº›æ­¥éª¤ï¼Œåƒåœ¾å›æ”¶çš„åŠŸèƒ½å°±åŸºæœ¬å®Œå¤‡äº†ã€‚

## æ€è€ƒé¢˜

è¯·ä½ ä»ä»£ç å®ç°çš„å±‚é¢æ¯”è¾ƒå¤åˆ¶ç®—æ³•å’Œå¼•ç”¨è®¡æ•°æ³•å„è‡ªçš„ä¼˜åŠ£ï¼Œæ¬¢è¿ä½ æŠŠä½ æ€»ç»“å‡ºçš„å†…å®¹åˆ†äº«åˆ°è¯„è®ºåŒºï¼Œä¹Ÿæ¬¢è¿ä½ æŠŠè¿™èŠ‚è¯¾çš„å†…å®¹åˆ†äº«ç»™éœ€è¦çš„æœ‹å‹ï¼Œæˆ‘ä»¬ä¸‹èŠ‚è¯¾å†è§ï¼
<div><strong>ç²¾é€‰ç•™è¨€ï¼ˆ4ï¼‰</strong></div><ul>
<li><span>ifelse</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>å­¦ä¹ æ‰“å¡</p>2024-11-08</li><br/><li><span>Geek_66a783</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>æˆ‘è®¤ä¸ºclass LinkedListè¿˜å¯ä»¥è¿›è¡Œè¿›ä¸€æ­¥çš„æŠ½è±¡å°è£…ï¼ˆç±»ä¼¼äºLinux kernelä¸­æä¾›çš„struct list_headï¼‰ï¼Œè¿™æ ·åç»­è™šæ‹Ÿæœºä¸­å¦‚æœè¿˜éœ€è¦æ·»åŠ å…¶ä»–åŸºäºé“¾è¡¨çš„åŠŸèƒ½ï¼Œå°±éå¸¸æ–¹ä¾¿çœäº‹äº†ã€‚

ä»¥ä¸‹æ˜¯æˆ‘çš„å®ç°ï¼š

#include &lt;iostream&gt;
#include &lt;cassert&gt;

class LinkedList {
private:
    LinkedList* _prev;
    LinkedList* _next;
public:
    LinkedList() {
        _prev = _next = this;
    }
    ~LinkedList() = default;
    void insert_between(LinkedList* prev, LinkedList* next) {
        assert(prev != nullptr);
        assert(next != nullptr);
        prev-&gt;_next = this;
        next-&gt;_prev = this;
        this-&gt;_prev = prev;
        this-&gt;_next = next;
    }
    void add_before(LinkedList* other) {
        assert(other != nullptr);
        assert(other-&gt;_prev != nullptr);
        insert_between(other-&gt;_prev, other);
    }
    void add_after(LinkedList* other) {
        assert(other != nullptr);
        assert(other-&gt;_next != nullptr);
        insert_between(other, other-&gt;_next);
    }
    void del() {
        assert(_prev != nullptr);
        assert(_next != nullptr);
        _prev-&gt;_next = this-&gt;_next;
        _next-&gt;_prev = this-&gt;_prev;
    }
    inline LinkedList* next() {
        return _next;
    }
    inline LinkedList* prev() {
        return _prev;
    }
    template&lt;class T&gt;
    inline T as() {
        return static_cast&lt;T&gt;(this);
    }
};

class MyNode : public LinkedList {
public:
    int value;
    MyNode(int v) : value(v) {}

};

int main() {
    LinkedList head;
    for (int i = 0; i &lt; 10; ++i) {
        MyNode* cur_node = new MyNode(i);
        cur_node-&gt;as&lt;LinkedList*&gt;()-&gt;add_before(&amp;head);
    }

    LinkedList* cur = &amp;head;
    while ((cur = cur-&gt;next()) != &amp;head) {
        MyNode* cur_node = cur-&gt;as&lt;MyNode*&gt;();
        std::cout &lt;&lt; cur_node-&gt;value &lt;&lt; std::endl;
    }

    cur = head.prev();
    while (cur != &amp;head) {
        MyNode* cur_node = cur-&gt;as&lt;MyNode*&gt;();
        std::cout &lt;&lt; cur_node-&gt;value &lt;&lt; std::endl;
        cur = cur-&gt;prev();
        delete cur_node;
    }
}</p>2024-09-22</li><br/><li><span>Geek_66a783</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>ç›´æ¥æŠŠUniverse ä¸­çš„ HiTrueã€HiFalseè¿˜æœ‰stringtableä¸­çš„å­—ç¬¦ä¸²å¸¸é‡åœ¨åˆ†é…å†…å­˜çš„æ—¶å€™ç›´æ¥æ”¾åˆ°metaåŒºï¼Œä¼šä¸ä¼šæ›´åˆç†ï¼Ÿ</p>2024-09-21</li><br/><li><span>Geek_66a783</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>å¦‚æœåœ¨pythonè™šæ‹Ÿæœºä¸­ä¹Ÿå¼•å…¥v8é‚£æ ·çš„small integerçš„æ¦‚å¿µï¼Œåº”è¯¥å°±èƒ½ä»æ ¹æœ¬ä¸Šé¿å…æ–‡ç« ä¸­æœ€åä¸€ä¸ªæµ‹è¯•ä»£ç é‚£æ ·çš„é¢‘ç¹gcäº†å§</p>2024-09-21</li><br/>
</ul>