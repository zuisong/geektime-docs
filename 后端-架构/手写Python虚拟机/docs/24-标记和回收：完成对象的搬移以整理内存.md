ä½ å¥½ï¼Œæˆ‘æ˜¯æµ·çº³ã€‚

ç¬¬ 22 è¯¾æˆ‘ç»™ä½ ä»‹ç»äº†åƒåœ¾å›æ”¶çš„åŸºæœ¬ç®—æ³•åŸç†ï¼Œç¬¬23è¯¾æˆ‘ä»¬é€šè¿‡ä¿®æ”¹ä»£ç å®ç°äº†åœ¨å †ä¸­åˆ†é…è™šæ‹Ÿæœºå¯¹è±¡çš„åŠŸèƒ½ï¼Œä»è€ŒæŠŠæ‰€æœ‰çš„å¯¹è±¡éƒ½æ”¾ç½®åœ¨å †é‡Œã€‚

ç„¶è€Œï¼Œè¿™äº›å·¥ä½œå®é™…ä¸Šåªå®Œæˆäº†åƒåœ¾å›æ”¶å™¨ä¸€åŠçš„å·¥ä½œã€‚é™¤äº†å¯ä»¥åˆ†é…ç©ºé—´ï¼Œåƒåœ¾å›æ”¶å™¨è¿˜æœ‰ä¸€ä¸ªé‡è¦åŠŸèƒ½æ˜¯å›æ”¶ç©ºé—´ã€‚å¤åˆ¶ç®—æ³•æ˜¯é€šè¿‡æŠŠå­˜æ´»å¯¹è±¡æ¬åˆ°å¹¸å­˜è€…ç©ºé—´ï¼ˆSurvivor Spaceï¼‰æ¥å®ç°ç©ºé—´å›æ”¶åŠŸèƒ½çš„ã€‚æ‰€ä»¥è¿™ä¸€èŠ‚è¯¾ï¼Œæˆ‘ä»¬å°±é‡ç‚¹å®ç°**æ¬ç§»å­˜æ´»å¯¹è±¡**çš„åŠŸèƒ½ã€‚

## æ¬ç§»å¯¹è±¡

æœ€é€‚åˆå®Œæˆæ¬ç§»å¯¹è±¡åŠŸèƒ½çš„ç»“æ„å°±æ˜¯**è®¿é—®è€…æ¨¡å¼**ã€‚æˆ‘ä»¬å®šä¹‰ä¸€ä¸ª ScavengeOopClosure ç±»ï¼Œå®ƒåœ¨è®¿é—®æ¯ä¸€ä¸ªå †å†…çš„å¯¹è±¡æ—¶ï¼Œå°±å¯ä»¥å®Œæˆå¯¹è±¡çš„æ¬ç§»å’ŒæŒ‡é’ˆä¿®æ”¹ã€‚

```c++
// [memory/heap.cpp]
void Heap::copy_live_objects() {
    ScavengeOopClosure(eden, survivor, metaspace).scavenge();
}

// [memory/oopClosure.hpp]
class OopClosure {
public:
    virtual void do_oop(HiObject** obj) = 0;

    virtual void do_array_list(ArrayList<Klass*>** alist) = 0;
    virtual void do_array_list(ArrayList<HiObject*>** alist) = 0;
    virtual void do_array_list(ArrayList<HiString*>** alist) = 0;

    virtual void do_map(Map<HiObject*, HiObject*>** amap) = 0;
    virtual void do_raw_mem(char** mem, int length) = 0;
    virtual void do_klass(Klass** k) = 0;
};

class ScavengeOopClosure : public OopClosure {
private:
    Space* _from;
    Space* _to;
    Space* _meta;

    Stack<HiObject*>* _oop_stack;

    HiObject* copy_and_push(HiObject* obj);

public:
    ScavengeOopClosure(Space* from, Space* to, Space* meta);
    virtual ~ScavengeOopClosure();

    virtual void do_oop(HiObject** oop);

    virtual void do_array_list(ArrayList<Klass*>** alist);
    virtual void do_array_list(ArrayList<HiObject*>** alist);
    virtual void do_array_list(ArrayList<HiString*>** alist);

    template <typename T>
    void do_array_list_nv(ArrayList<T>** alist);

    virtual void do_map(Map<HiObject*, HiObject*>** amap);
    virtual void do_raw_mem(char** mem, int length);
    // CAUTION : we do not move Klass, because they locate at MetaSpace.
    virtual void do_klass(Klass** k);

    void scavenge();
    void process_roots();
};
```
<div><strong>ç²¾é€‰ç•™è¨€ï¼ˆ4ï¼‰</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg" width="30px"><span>ifelse</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<div>å­¦ä¹ æ‰“å¡</div>2024-11-08</li><br/><li><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/pkjW8zleOmmWAbAMPkshJSFnDcN6d06DrYDeSIibmic2SW05Flv3ic5kLhzcHukia1Y1Ktm4OXdzYsicCnINiaCOeqQQ/132" width="30px"><span>Geek_66a783</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<div>æˆ‘è®¤ä¸ºclass LinkedListè¿˜å¯ä»¥è¿›è¡Œè¿›ä¸€æ­¥çš„æŠ½è±¡å°è£…ï¼ˆç±»ä¼¼äºLinux kernelä¸­æä¾›çš„struct list_headï¼‰ï¼Œè¿™æ ·åç»­è™šæ‹Ÿæœºä¸­å¦‚æœè¿˜éœ€è¦æ·»åŠ å…¶ä»–åŸºäºé“¾è¡¨çš„åŠŸèƒ½ï¼Œå°±éå¸¸æ–¹ä¾¿çœäº‹äº†ã€‚

ä»¥ä¸‹æ˜¯æˆ‘çš„å®ç°ï¼š

#include &lt;iostream&gt;
#include &lt;cassert&gt;

class LinkedList {
private:
    LinkedList* _prev;
    LinkedList* _next;
public:
    LinkedList() {
        _prev = _next = this;
    }
    ~LinkedList() = default;
    void insert_between(LinkedList* prev, LinkedList* next) {
        assert(prev != nullptr);
        assert(next != nullptr);
        prev-&gt;_next = this;
        next-&gt;_prev = this;
        this-&gt;_prev = prev;
        this-&gt;_next = next;
    }
    void add_before(LinkedList* other) {
        assert(other != nullptr);
        assert(other-&gt;_prev != nullptr);
        insert_between(other-&gt;_prev, other);
    }
    void add_after(LinkedList* other) {
        assert(other != nullptr);
        assert(other-&gt;_next != nullptr);
        insert_between(other, other-&gt;_next);
    }
    void del() {
        assert(_prev != nullptr);
        assert(_next != nullptr);
        _prev-&gt;_next = this-&gt;_next;
        _next-&gt;_prev = this-&gt;_prev;
    }
    inline LinkedList* next() {
        return _next;
    }
    inline LinkedList* prev() {
        return _prev;
    }
    template&lt;class T&gt;
    inline T as() {
        return static_cast&lt;T&gt;(this);
    }
};

class MyNode : public LinkedList {
public:
    int value;
    MyNode(int v) : value(v) {}

};

int main() {
    LinkedList head;
    for (int i = 0; i &lt; 10; ++i) {
        MyNode* cur_node = new MyNode(i);
        cur_node-&gt;as&lt;LinkedList*&gt;()-&gt;add_before(&amp;head);
    }

    LinkedList* cur = &amp;head;
    while ((cur = cur-&gt;next()) != &amp;head) {
        MyNode* cur_node = cur-&gt;as&lt;MyNode*&gt;();
        std::cout &lt;&lt; cur_node-&gt;value &lt;&lt; std::endl;
    }

    cur = head.prev();
    while (cur != &amp;head) {
        MyNode* cur_node = cur-&gt;as&lt;MyNode*&gt;();
        std::cout &lt;&lt; cur_node-&gt;value &lt;&lt; std::endl;
        cur = cur-&gt;prev();
        delete cur_node;
    }
}</div>2024-09-22</li><br/><li><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/pkjW8zleOmmWAbAMPkshJSFnDcN6d06DrYDeSIibmic2SW05Flv3ic5kLhzcHukia1Y1Ktm4OXdzYsicCnINiaCOeqQQ/132" width="30px"><span>Geek_66a783</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<div>ç›´æ¥æŠŠUniverse ä¸­çš„ HiTrueã€HiFalseè¿˜æœ‰stringtableä¸­çš„å­—ç¬¦ä¸²å¸¸é‡åœ¨åˆ†é…å†…å­˜çš„æ—¶å€™ç›´æ¥æ”¾åˆ°metaåŒºï¼Œä¼šä¸ä¼šæ›´åˆç†ï¼Ÿ</div>2024-09-21</li><br/><li><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/pkjW8zleOmmWAbAMPkshJSFnDcN6d06DrYDeSIibmic2SW05Flv3ic5kLhzcHukia1Y1Ktm4OXdzYsicCnINiaCOeqQQ/132" width="30px"><span>Geek_66a783</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<div>å¦‚æœåœ¨pythonè™šæ‹Ÿæœºä¸­ä¹Ÿå¼•å…¥v8é‚£æ ·çš„small integerçš„æ¦‚å¿µï¼Œåº”è¯¥å°±èƒ½ä»æ ¹æœ¬ä¸Šé¿å…æ–‡ç« ä¸­æœ€åä¸€ä¸ªæµ‹è¯•ä»£ç é‚£æ ·çš„é¢‘ç¹gcäº†å§</div>2024-09-21</li><br/>
</ul>