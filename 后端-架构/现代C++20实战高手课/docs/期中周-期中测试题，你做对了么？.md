ä½ å¥½ï¼Œæˆ‘æ˜¯å¢èª‰å£°ã€‚

ä¸ºäº†å¸®åŠ©ä½ å·©å›ºçŸ¥è¯†ï¼Œæå‡èƒ½åŠ›ï¼ŒæœŸä¸­å‘¨æˆ‘ç»™ä½ å‡ºäº†ä¸€é“å®æˆ˜é¢˜ç›®ï¼ŒåŸºäºè¯¾ç¨‹é‡Œçš„ä»£ç æ‰©å±•ç°æœ‰åç¨‹æ¡†æ¶ï¼Œå®ç°é«˜çº§ä»»åŠ¡è°ƒåº¦ã€‚é¢˜ç›®æè¿°ä½ å¯ä»¥é€šè¿‡[è¿™ä¸ªé“¾æ¥](https://time.geekbang.org/column/article/629373)å›é¡¾ã€‚

è¿™ä¸€è®²ï¼Œæˆ‘ä¼šæŠŠå‚è€ƒä»£ç å’Œè§£é¢˜æ€è·¯å…¬å¸ƒå‡ºæ¥ã€‚

## ç­”æ¡ˆè§£æ

æ—¢ç„¶è¦åœ¨ç°æœ‰ä»£ç ä¸Šå¢åŠ åŠŸèƒ½ï¼Œæˆ‘ä»¬å°±æœ‰å¿…è¦å…ˆç†Ÿæ‚‰åŸæœ‰æ¶æ„ï¼Œå†å†³å®šåœ¨å“ªä¸ªæ¨¡å—æˆ–å“ªä¸ªå±‚é¢ä¸Šè¿½åŠ åŠŸèƒ½ã€‚

é€šè¿‡åˆ†æï¼Œå¯ä»¥å‘ç°ä»»åŠ¡çš„æ‰§è¡Œä¸è°ƒåº¦æ˜¯é€šè¿‡asyncpp.taskæ¨¡å—å®ç°çš„ã€‚åŒæ—¶ï¼Œæˆ‘ä»¬åˆæ˜¯åœ¨ä¸ºç°æœ‰æ¡†æ¶æä¾›é«˜ä¼˜å…ˆçº§è°ƒåº¦çš„èƒ½åŠ›ã€‚å› æ­¤ï¼Œæ–°å¢çš„æ¨¡å—åº”è¯¥æ˜¯ä¾›asyncpp.taskä½¿ç”¨çš„ã€‚

åŸºäºè¿™æ ·çš„è€ƒè™‘ï¼Œæˆ‘ä»¬åœ¨åŸæœ‰çš„æ¶æ„åŸºç¡€ä¸Šï¼Œè¿½åŠ äº†ä¸€ä¸ªhigh performanceï¼ˆasyncpp.hpï¼‰æ¨¡å—ï¼Œä¾›asyncpp.taskæ¨¡å—å®ç°é«˜æ€§èƒ½çš„çº¿ç¨‹è°ƒåº¦ã€‚è¡¥å……åçš„æ¶æ„å›¾æ˜¯åé¢è¿™æ ·ã€‚

![](https://static001.geekbang.org/resource/image/4e/95/4e0fbf132067b48443fa86edc915e195.jpg?wh=2900x1980)

ä»å›¾ä¸­å¯ä»¥çœ‹åˆ°ï¼Œasyncpp.taskæ¨¡å—å¼•ç”¨äº†asyncpp.hpæ¨¡å—ã€‚æ–°çš„æ¨¡å—æä¾›äº†é«˜ä¼˜å…ˆçº§çº¿ç¨‹è°ƒåº¦å’Œç®¡ç†çš„èƒ½åŠ›ã€‚

æˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹å…·ä½“å®ç°ã€‚é¦–å…ˆæ˜¯:taskå­æ¨¡å—ã€‚

```c++
export module asyncpp.hp:task;

import asyncpp.core;
import <functional>;
import <vector>;
import <mutex>;

namespace asyncpp::hp {

export struct AsyncHpTask {
Â  Â  using ResumeHandler = std::function<void()>;
Â  Â  using TaskHandler = std::function<void()>;

Â  Â  // åç¨‹å”¤é†’å‡½æ•°
Â  Â  ResumeHandler resumeHandler;
Â  Â  // è®¡ç®—ä»»åŠ¡å‡½æ•°
Â  Â  TaskHandler taskHandler;
};

export class AsyncHpTaskQueue {
public:
Â  Â  static AsyncHpTaskQueue& getInstance();

Â  Â  void enqueue(const AsyncHpTask& item) {
Â  Â  Â  Â  std::lock_guard<std::mutex> guard(_queueMutex);

Â  Â  Â  Â  _queue.push_back(item);
Â  Â  }

Â  Â  bool dequeue(AsyncHpTask* item) {
Â  Â  Â  Â  std::lock_guard<std::mutex> guard(_queueMutex);

Â  Â  Â  Â  if (_queue.size() == 0) {
Â  Â  Â  Â  Â  Â  return false;
Â  Â  Â  Â  }

Â  Â  Â  Â  *item = _queue.back();
Â  Â  Â  Â  _queue.pop_back();

Â  Â  Â  Â  return true;
Â  Â  }

Â  Â  size_t getSize() const {
Â  Â  Â  Â  return _queue.size();
Â  Â  }

private:
Â  Â  // é«˜æ€§èƒ½è®¡ç®—ä»»åŠ¡é˜Ÿåˆ—
Â  Â  std::vector<AsyncHpTask> _queue;
Â  Â  // é«˜æ€§èƒ½è®¡ç®—ä»»åŠ¡é˜Ÿåˆ—äº’æ–¥é”ï¼Œç”¨äºå®ç°çº¿ç¨‹åŒæ­¥ï¼Œç¡®ä¿é˜Ÿåˆ—æ“ä½œçš„çº¿ç¨‹å®‰å…¨
Â  Â  std::mutex _queueMutex;
};

AsyncHpTaskQueue& AsyncHpTaskQueue::getInstance() {
Â  Â  static AsyncHpTaskQueue queue;

Â  Â  return queue;
}

}
```

è¿™éƒ¨åˆ†ä»£ç è·Ÿä¹‹å‰çš„asyncpp.io:taskåŸºæœ¬ç›¸åŒï¼Œå”¯ä¸€åŒºåˆ«æ˜¯è°ƒåº¦çš„ä»»åŠ¡ç±»å‹ä¸åŒï¼Œç”¨äºå¤„ç†é«˜æ€§èƒ½è®¡ç®—ä»»åŠ¡ã€‚

æ¥ä¸‹æ¥çš„é‡ç‚¹æ˜¯:loopçš„å®ç°ã€‚

```c++
module;

#ifndef _WINDOWS_
#include <Windows.h>
#endif // _WINDOWS_

export module asyncpp.hp:loop;

import :task;
import asyncpp.task.queue;

import <thread>;
import <chrono>;
import <thread>;
import <functional>;

namespace asyncpp::hp {
Â  Â  export class AsyncHpLoop {
Â  Â  public:
Â  Â  Â  Â  // å¸¸é‡ï¼Œå®šä¹‰äº†ä»»åŠ¡å¾ªç¯çš„ç­‰å¾…é—´éš”æ—¶é—´ï¼ˆå•ä½ä¸ºæ¯«ç§’ï¼‰
Â  Â  Â  Â  static const int32_t SLEEP_MS = 100;

Â  Â  Â  Â  static AsyncHpLoop& start();

Â  Â  private:
Â  Â  Â  Â  // æ”¯æŒå•ä¾‹æ¨¡å¼ï¼Œå°†å…¶å®šä¹‰ä¸ºprivateï¼Œé˜²æ­¢å¤–éƒ¨è°ƒç”¨æ„é€ å‡½æ•°
Â  Â  Â  Â  AsyncHpLoop() {
Â  Â  Â  Â  Â  Â  _thread = std::jthread(std::bind(&AsyncHpLoop::loopMain, this));
Â  Â  Â  Â  Â  Â  auto nativeWorkerHandle = _thread.native_handle();
Â  Â  Â  Â  Â  Â  ::SetThreadPriority(nativeWorkerHandle, THREAD_PRIORITY_HIGHEST);
Â  Â  Â  Â  }
Â  Â  Â  Â  // æ”¯æŒå•ä¾‹æ¨¡å¼ï¼Œé€šè¿‡deleteä¿®é¥°ç¬¦è¯´æ˜æ‹·è´æ„é€ å‡½æ•°ä¸å¯è°ƒç”¨
Â  Â  Â  Â  AsyncHpLoop(const AsyncHpLoop&) = delete;
Â  Â  Â  Â  // æ”¯æŒå•ä¾‹æ¨¡å¼ï¼Œé€šè¿‡deleteä¿®é¥°ç¬¦è¯´æ˜èµ‹å€¼æ“ä½œç¬¦ä¸å¯è°ƒç”¨
Â  Â  Â  Â  AsyncHpLoop& operator=(const AsyncHpLoop&) = delete;

Â  Â  Â  Â  void loopExecution() {
Â  Â  Â  Â  Â  Â  AsyncHpTask opItem;
Â  Â  Â  Â  Â  Â  if (!AsyncHpTaskQueue::getInstance().dequeue(&opItem)) {
Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  opItem.taskHandler();

Â  Â  Â  Â  Â  Â  auto& asyncEventQueue = asyncpp::task::AsyncTaskQueue::getInstance();
Â  Â  Â  Â  Â  Â  asyncEventQueue.enqueue({
Â  Â  Â  Â  Â  Â  Â  Â  .handler = opItem.resumeHandler
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  }

Â  Â  Â  Â  void loopMain() {
Â  Â  Â  Â  Â  Â  while (true) {
Â  Â  Â  Â  Â  Â  Â  Â  loopExecution();
Â  Â  Â  Â  Â  Â  Â  Â  std::this_thread::sleep_for(std::chrono::milliseconds(SLEEP_MS));
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  // jthreadå¯¹è±¡ï¼Œä¸ºé«˜æ€§èƒ½è®¡ç®—çº¿ç¨‹ï¼Œjthreadè®©è¯¥çº¿ç¨‹ç»“æŸä¹‹å‰æ•´ä¸ªè¿›ç¨‹éƒ½ä¸ä¼šç»“æŸ
Â  Â  Â  Â  std::jthread _thread;
Â  Â  };

Â  Â  AsyncHpLoop& AsyncHpLoop::start() {
Â  Â  Â  Â  static AsyncHpLoop ioLoop;

Â  Â  Â  Â  return ioLoop;
Â  Â  }
}
```

æˆ‘ä»¬åœ¨è¿™æ®µä»£ç é‡Œä¸ä»…ä½¿ç”¨jthreadï¼Œè¿˜åœ¨AsyncHpLoopæ„é€ å‡½æ•°ä¸­ä½¿ç”¨äº†native\_handleï¼Œè®¾ç½®äº†çº¿ç¨‹ä¼˜å…ˆçº§ï¼Œç”¨äºé«˜æ€§èƒ½çš„ä»»åŠ¡è°ƒåº¦ã€‚

æœ€åï¼Œæˆ‘ä»¬åœ¨asyncpp.task:asyncifyä¸­ï¼Œä½¿ç”¨äº†æ–°çš„æ¨¡å—ã€‚

```c++
export module asyncpp.task:asyncify;

export import asyncpp.task.queue;
export import :loop;
export import :coroutine;

import asyncpp.core;
import asyncpp.hp;

namespace asyncpp::task {
Â  Â  using asyncpp::core::Invocable;

Â  Â  // é»˜è®¤çš„AsyncTaskSuspenderï¼ˆå½“ä»»åŠ¡å‡½æ•°è¿”å›ç±»å‹ä¸ä¸ºvoidæ—¶ï¼‰
Â  Â  template <typename ResultType>
Â  Â  void defaultAsyncAwaitableSuspend(
Â  Â  Â  Â  Awaitable<ResultType>* awaitable,
Â  Â  Â  Â  AsyncTaskResumer resumer,
Â  Â  Â  Â  CoroutineHandle& h
Â  Â  ) {
Â  Â  Â  Â  auto& asyncTaskQueue = AsyncTaskQueue::getInstance();
Â  Â  Â  Â  asyncTaskQueue.enqueue({
Â  Â  Â  Â  Â  Â  .handler = [resumer, awaitable] {
Â  Â  Â  Â  Â  Â  Â  Â  awaitable->_taskResult = awaitable->_taskHandler();
Â  Â  Â  Â  Â  Â  Â  Â  resumer();
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  });
Â  Â  }

Â  Â  // é»˜è®¤çš„AsyncTaskSuspenderï¼ˆå½“ä»»åŠ¡å‡½æ•°è¿”å›ç±»å‹ä¸ºvoidæ—¶ï¼‰
Â  Â  template <>
Â  Â  void defaultAsyncAwaitableSuspend<void>(
Â  Â  Â  Â  Awaitable<void>* awaitable,
Â  Â  Â  Â  AsyncTaskResumer resumer,
Â  Â  Â  Â  CoroutineHandle& h
Â  Â  ) {
Â  Â  Â  Â  auto& asyncTaskQueue = AsyncTaskQueue::getInstance();
Â  Â  Â  Â  asyncTaskQueue.enqueue({
Â  Â  Â  Â  Â  Â  .handler = [resumer, awaitable] {
Â  Â  Â  Â  Â  Â  Â  Â  awaitable->_taskHandler();
Â  Â  Â  Â  Â  Â  Â  Â  resumer();
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  });
Â  Â  }

Â  Â  template <typename ResultType>
Â  Â  void hpAsyncAwaitableSuspend(
Â  Â  Â  Â  Awaitable<ResultType>* awaitable,
Â  Â  Â  Â  AsyncTaskResumer resumer,
Â  Â  Â  Â  CoroutineHandle& h
Â  Â  ) {
Â  Â  Â  Â  asyncpp::hp::AsyncHpTask operationItem{
Â  Â  Â  Â  Â  Â  .resumeHandler = [h] {
Â  Â  Â  Â  Â  Â  Â  Â  h.resume();
Â  Â  Â  Â  Â  Â  },
Â  Â  Â  Â  Â  Â  .taskHandler = [awaitable]() {
Â  Â  Â  Â  Â  Â  Â  Â  awaitable->_taskResult = awaitable->_taskHandler();
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  };

Â  Â  Â  Â  asyncpp::hp::AsyncHpTaskQueue::getInstance().enqueue(operationItem);
Â  Â  }

Â  Â  export template <Invocable T>
Â  Â  auto asyncify(
Â  Â  Â  Â  T taskHandler,
Â  Â  Â  Â  AsyncTaskSuspender<std::invoke_result_t<T>> suspender =
Â  Â  Â  Â  defaultAsyncAwaitableSuspend<std::invoke_result_t<T>>
Â  Â  ) {
Â  Â  Â  Â  return Awaitable<std::invoke_result_t<T>>{
Â  Â  Â  Â  Â  Â  ._taskHandler = taskHandler,
Â  Â  Â  Â  Â  Â  Â  Â  ._suspender = suspender
Â  Â  Â  Â  };
Â  Â  }

Â  Â  export template <Invocable T>
Â  Â  auto asyncify(
Â  Â  Â  Â  T taskHandler,
Â  Â  Â  Â  bool highPriority
Â  Â  ) {
Â  Â  Â  Â  if (highPriority) {
Â  Â  Â  Â  Â  Â  return Awaitable<std::invoke_result_t<T>>{
Â  Â  Â  Â  Â  Â  Â  Â  ._taskHandler = taskHandler,
Â  Â  Â  Â  Â  Â  Â  Â  ._suspender = hpAsyncAwaitableSuspend<std::invoke_result_t<T>>
Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  }
Â  Â  Â  Â  return Awaitable<std::invoke_result_t<T>>{
Â  Â  Â  Â  Â  Â  ._taskHandler = taskHandler,
Â  Â  Â  Â  Â  Â  ._suspender = defaultAsyncAwaitableSuspend<std::invoke_result_t<T>>
Â  Â  Â  Â  };
Â  Â  }
}
```

ä½ å¯ä»¥å…ˆå…³æ³¨ä¸€ä¸‹ç¬¬8è¡Œä»£ç ï¼Œè¿™é‡Œæˆ‘ä»¬å¯¼å…¥äº†hpæ¨¡å—çš„ç¬¦å·ã€‚æ¥ç€ï¼Œè¿˜åœ¨ç¬¬46è¡Œå®ç°äº†hpAsyncAwaitableSuspendï¼Œç”¨äºå®ç°é«˜æ€§èƒ½ç‰ˆæœ¬çš„è°ƒåº¦ã€‚

æœ€åï¼Œæˆ‘ä»¬åœ¨ç¬¬76è¡Œå®ç°äº†ç±»ä¼¼äºä¹‹å‰çš„asyncifyå·¥å…·ï¼Œç”¨äºå°†ä¸€ä¸ªæ™®é€šçš„å‡½æ•°fè½¬æ¢æˆä¸€ä¸ªè¿”å›Awaitableå¯¹è±¡çš„å‡½æ•°asyncFã€‚é€šè¿‡è¿™ä¸ªåˆ†åŒºå®ç°çš„å·¥å…·ï¼Œå¯ä»¥è®©åº“çš„ç”¨æˆ·æ›´å®¹æ˜“ä½¿ç”¨coroutineã€‚

è¿™é“é¢˜ç›®çš„æºä»£ç ï¼Œä½ å¯ä»¥ä»[è¿™é‡Œ](https://github.com/samblg/cpp20-plus-indepth/tree/main/mid_term_exam_sol)è·å–ã€‚

æœŸä¸­å‘¨å³å°†å‘Šä¸€æ®µè½ï¼Œä½ å¯ä»¥å†åˆ©ç”¨å‘¨æœ«æ—¶é—´æ¸©ä¹ ä¸€ä¸‹ä¹‹å‰æ‰€å­¦ã€‚æœ‰ä¸æ˜ç™½çš„åœ°æ–¹æ¬¢è¿å’Œæˆ‘åœ¨ç•™è¨€åŒºäº¤æµï¼Œä¸‹å‘¨æˆ‘ä»¬ç»§ç»­å›åˆ°è¯¾ç¨‹ä¸»çº¿ï¼Œç»§ç»­å­¦ä¹ C++ Rangesçš„ç”¨æ³•ï¼Œæ•¬è¯·æœŸå¾…ã€‚
<div><strong>ç²¾é€‰ç•™è¨€ï¼ˆ1ï¼‰</strong></div><ul>
<li><span>Family mission</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>æ„Ÿè§‰asyncpp.task:asyncify æ¨¡å—ä¸­36è¡Œä½¿ç”¨å•ä¾‹æ¨¡å¼æ„é€ AsyncHpTaskQueueè€Œä¸æ˜¯AsyncTaskQueue::getInstance()ï¼Œå†™é”™äº†å§</p>2023-12-12</li><br/>
</ul>