ä½ å¥½ï¼Œæˆ‘æ˜¯å¾é€¸ã€‚

ä¸ŠèŠ‚è¯¾æˆ‘ä»¬ä¸€èµ·å­¦ä¹ äº†å¹¶å‘ç­‰å¾…æŠ€æœ¯ã€‚ä¸è¿‡åœ¨å®é™…çš„ç¼–ç¨‹å®è·µä¸­ï¼Œæˆ‘ä»¬ä¼šé‡åˆ°å„ç§å„æ ·çš„å¹¶å‘åœºæ™¯ï¼Œæ‰€éœ€è¦çš„å¹¶å‘æŠ€æœ¯ä¹Ÿä¼šæœ‰æ‰€ä¸åŒã€‚ä»Šå¤©å’±ä»¬å°±æ¥èŠèŠåœ¨å¹¶å‘ç¯å¢ƒä¸‹ï¼Œå¦‚ä½•å·§å¦™åœ°è¿ç”¨é”ï¼Œå®ç°é«˜æ€§èƒ½ã€å®‰å…¨åœ°è®¿é—®å¤šåç¨‹å…±äº«çš„æ•°æ®ã€‚

æˆ‘ä»¬å…ˆä»ä¸€ä¸ªé—®é¢˜å…¥æ‰‹ã€‚å‡å¦‚æˆ‘ä»¬ç°åœ¨éœ€è¦å®ç°ä¸€ä¸ªåº•å±‚ç”¨mapç±»å‹å­˜å‚¨æ•°æ®çš„æœ¬åœ°ç¼“å­˜ï¼Œè¯¥æ€ä¹ˆè®¾è®¡ï¼Œæ‰èƒ½åœ¨å¹¶å‘ç¯å¢ƒä¸‹é«˜æ€§èƒ½ä¸”å®‰å…¨åœ°è®¿é—®è¿™ä¸ªç¼“å­˜å‘¢ï¼Ÿ

## äº’æ–¥é”

å¯¹äºå¤šåç¨‹å…±äº«æ•°æ®çš„å®‰å…¨è®¿é—®ï¼Œæœ€ç®€å•çš„æ–¹æ¡ˆå°±æ˜¯ç”¨äº’æ–¥é”ã€‚**äº’æ–¥é”èƒ½ä¿è¯åœ¨åŒä¸€æ—¶åˆ»ï¼Œåªæœ‰ä¸€ä¸ªåç¨‹èƒ½å¤Ÿè®¿é—®è¢«ä¿æŠ¤çš„å…±äº«æ•°æ®**ã€‚

åœ¨Golangä¸­ï¼Œå¹¶å‘åŒ…syncé‡Œé¢çš„Mutexç±»å‹å®ç°äº†äº’æ–¥é”åŠŸèƒ½ã€‚å®ƒçš„æ ¸å¿ƒæ˜¯ä¸‹é¢ä¸¤ä¸ªæ–¹æ³•ã€‚

- Lockæ–¹æ³•ï¼Œç”¨äºåŠ é”ï¼Œå½“é”å·²ç»è¢«å ç”¨æ—¶ï¼Œè°ƒç”¨åç¨‹ä¼šé˜»å¡ç›´åˆ°é”å¯ç”¨ã€‚
- Unlockæ–¹æ³•ï¼Œç”¨äºé‡Šæ”¾é”ã€‚

```go
func (m *Mutex) Lock()
func (m *Mutex) Unlock()
```

çŸ¥é“äº†Mutexç±»å‹çš„æ–¹æ³•ï¼Œå¦‚åŒä¸‹é¢çš„ä»£ç ä¸€æ ·ï¼Œå’±ä»¬å¯ä»¥åœ¨æœ¬åœ°ç¼“å­˜çš„è¯»å†™æ“ä½œä¸­ï¼Œè°ƒç”¨Mutexå¯¹è±¡çš„Lockå’ŒUnlockæ–¹æ³•æ¥å®ç°å¹¶å‘å®‰å…¨çš„æœ¬åœ°ç¼“å­˜è®¿é—®ã€‚

```go
import (
    "sync"
)

type MutexCache struct {
    mu   sync.Mutex        // äº’æ–¥é”
    data map[string]string // å…±äº«æ•°æ®
}

// NewMutexCacheåˆå§‹åŒ–ä¸€ä¸ªMutexCacheå®ä¾‹
func NewMutexCache() *MutexCache {
    c := &MutexCache{data: make(map[string]string)}
    return c
}

// Setæ›´æ–°ç¼“å­˜
func (c *MutexCache) Set(key, value string) {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.data[key] = value
}

// Getä»ç¼“å­˜ä¸­è·å–å€¼
func (c *MutexCache) Get(key string) (string, bool) {
    c.mu.Lock()
    defer c.mu.Unlock()
    value, ok := c.data[key]
    return value, ok
}
```

## è¯»å†™é”

**åœ¨ä¸€äº›è¯»QPSä¸é«˜çš„åœºæ™¯ï¼Œç®€å•é€šè¿‡äº’æ–¥é”å®ç°æœ¬åœ°ç¼“å­˜åŠŸèƒ½çš„ç¡®å¯è¡Œã€‚**ä½†æ˜¯åœ¨ä¸€äº›å†™æ¯”è¾ƒå°‘ï¼Œè¯»QPSç‰¹åˆ«é«˜çš„åœºæ™¯ï¼Œè¯»è¯·æ±‚ä¹‹é—´å¯¹äº’æ–¥é”çš„é¢‘ç¹ç«äº‰ï¼Œä¼šå¯¹è¯»è¯·æ±‚çš„æ€§èƒ½äº§ç”Ÿä¸åˆ©çš„å½±å“ï¼Œå¯¼è‡´è¯»è¯·æ±‚çš„å¤„ç†é€Ÿåº¦ä¸‹é™ï¼Œå“åº”æ—¶é—´å»¶é•¿ï¼Œå½±å“åˆ°æœåŠ¡æ•´ä½“çš„ååã€‚

é‚£åœ¨è¯»å¤šå†™å°‘çš„åœºæ™¯ï¼Œæˆ‘ä»¬è¯¥å¦‚ä½•æå‡å…±äº«æ•°æ®å¹¶å‘è®¿é—®çš„æ€§èƒ½å‘¢ï¼Ÿ

ä¸ºäº†æå‡å…±äº«æ•°æ®**è¯»å¤šå†™å°‘åœºæ™¯çš„è¯»æ€§èƒ½ï¼Œè¯»å†™é”å°±èƒ½æ´¾ä¸Šç”¨åœºäº†**ã€‚ä¸äº’æ–¥é”ä¸åŒï¼Œè¯»å†™é”åŒºåˆ†äº†è¯»æ“ä½œå’Œå†™æ“ä½œã€‚

è¯»å†™é”æœ‰ä¸‰ç§çŠ¶æ€ï¼šè¯»æ¨¡å¼é”å®šã€å†™æ¨¡å¼é”å®šå’Œæœªé”å®šã€‚å½“è¯»å†™é”å¤„äºè¯»æ¨¡å¼é”å®šæ—¶ï¼Œå¯ä»¥æœ‰å¤šä¸ªåç¨‹åŒæ—¶è¿›è¡Œè¯»æ“ä½œï¼›è€Œå½“è¯»å†™é”å¤„äºå†™æ¨¡å¼é”å®šæ—¶ï¼Œåªæœ‰ä¸€ä¸ªåç¨‹èƒ½è¿›è¡Œå†™æ“ä½œï¼Œå¹¶ä¸”åœ¨å†™æ¨¡å¼é”å®šæ—¶ï¼Œè¯»æ“ä½œä¼šè¢«é˜»å¡ã€‚

åœ¨ Go è¯­è¨€ä¸­ï¼Œsyncå¹¶å‘åŒ…çš„RWMutexç±»å‹å®ç°äº†è¯»å†™é”åŠŸèƒ½ã€‚å®ƒçš„æ ¸å¿ƒæ˜¯ä¸‹é¢å‡ ä¸ªæ–¹æ³•ã€‚

1. Lockæ–¹æ³•ï¼Œç”¨äºè·å–å†™é”ï¼Œå¦‚æœè¯»é”æˆ–å†™é”å·²ç»è¢«å ç”¨ï¼Œåˆ™é˜»å¡ç›´åˆ°å†™é”å¯ç”¨ã€‚
2. Unlockæ–¹æ³•ï¼Œç”¨äºé‡Šæ”¾å†™é”ã€‚
3. RLockæ–¹æ³•ï¼Œç”¨äºè·å–è¯»é”ï¼Œå½“å†™é”æ²¡è¢«å ç”¨æ—¶ï¼Œå¯ä»¥è·å–åˆ°è¯»é”ï¼Œå¦åˆ™é˜»å¡ç›´åˆ°å†™é”è¢«é‡Šæ”¾ã€‚
4. RUnlockæ–¹æ³•ï¼Œç”¨äºé‡Šæ”¾è¯»é”ã€‚

æˆ‘ç”¨RWMutexç±»å‹å®ç°äº†ä¸€ä¸ªæœ¬åœ°ç¼“å­˜ç»“æ„ï¼Œå®ƒçš„å®ç°å’Œäº’æ–¥é”ç±»ä¼¼ï¼Œä¸è¿‡éœ€è¦åœ¨ç¼“å­˜çš„è¯»æ“ä½œä¸­è°ƒç”¨è¯»é”RLockå’ŒRUnlockæ–¹æ³•ï¼Œåœ¨å†™æ“ä½œä¸­è°ƒç”¨å†™é”Lockå’ŒUnlockæ–¹æ³•ã€‚ä½ å¯ä»¥å¯¹ç…§åé¢çš„ç¤ºä¾‹ä»£ç çœ‹ä¸€çœ‹ã€‚

```go
import (
    "sync"
)

type RWMutexCache struct {
    rw   sync.RWMutex      // è¯»å†™é”
    data map[string]string // å…±äº«æ•°æ®
}

// NewRWMutexCacheåˆå§‹åŒ–ä¸€ä¸ªRWMutexCacheå®ä¾‹
func NewRWMutexCache() *RWMutexCache {
    c := &RWMutexCache{data: make(map[string]string)}
    return c
}

// Setæ›´æ–°ç¼“å­˜
func (c *RWMutexCache) Set(key, value string) {
    c.rw.Lock()
    defer c.rw.Unlock()
    c.data[key] = value
}

// Getä»ç¼“å­˜ä¸­è·å–å€¼
func (c *RWMutexCache) Get(key string) (string, bool) {
    c.rw.RLock()
    defer c.rw.RUnlock()
    value, ok := c.data[key]
    return value, ok
}
```

é‚£åœ¨è¯»å¤šå†™å°‘çš„åœºæ™¯ï¼Œè¯»å†™é”çš„æ€§èƒ½æ˜¯ä¸æ˜¯çœŸçš„æ¯”äº’æ–¥é”é«˜å‘¢ï¼Ÿå’±ä»¬å¯ä»¥ç”¨ä¸‹é¢çš„benchmarkè„šæœ¬æµ‹ä¸€æµ‹ï¼Œbenchmarkè®¾ç½®çš„è¯»å†™æ¯”ä¾‹ä¸º90æ¯”1ã€‚

```go
const (
    cost     = 1 * time.Millisecond
    readCnt  = 90
    writeCnt = 1
)

// äº’æ–¥é”ç¼“å­˜
func BenchmarkMutexReadMore(b *testing.B) {
    c := NewMutexCache() // äº’æ–¥é”å®ç°æœ¬åœ°ç¼“å­˜
    for i := 0; i < b.N; i++ {
        var wg sync.WaitGroup
        for j := 0; j < 1000; j++ {
            for k := 0; k < readCnt; k++ {
                wg.Add(1)
                go func() {
                    defer wg.Done()
                    c.Get("11")
                    time.Sleep(cost)

                }()
            }
            for k := 0; k < writeCnt; k++ {
                wg.Add(1)
                go func() {
                    defer wg.Done()
                    c.Set("11", "11")
                    time.Sleep(cost)

                }()
            }
        }
        wg.Wait()
    }
}

// è¯»å†™é”ç¼“å­˜
func BenchmarkRwReadMore(b *testing.B) {
    c := NewRWMutexCache() // äº’æ–¥é”å®ç°æœ¬åœ°ç¼“å­˜
    for i := 0; i < b.N; i++ {
        var wg sync.WaitGroup
        for j := 0; j < 1000; j++ {
            for k := 0; k < readCnt; k++ {
                wg.Add(1)
                go func() {
                    defer wg.Done()
                    c.Get("11")
                    time.Sleep(cost)

                }()
            }
            for k := 0; k < writeCnt; k++ {
                wg.Add(1)
                go func() {
                    defer wg.Done()
                    c.Set("11", "11")
                    time.Sleep(cost)

                }()
            }
        }
        wg.Wait()
    }
}
```

æµ‹è¯•ç»“æœå‡ºæ¥äº†ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°**ç”¨è¯»å†™é”å®ç°çš„ç¼“å­˜ï¼Œåœ¨è¯»å¤šå†™å°‘åœºæ™¯ï¼Œæ€§èƒ½æ¯”äº’æ–¥é”é«˜å¾ˆå¤šã€‚**å¹¶å‘è¯»å†™ç¼“å­˜ç›¸åŒçš„æ¬¡æ•°ï¼Œè¯»å†™é”è€—æ—¶ä¸º52msï¼Œè€Œäº’æ–¥é”éœ€è¦62msã€‚

```shell
killianxu@KILLIANXU-MB0 7 % go test -bench . -benchmem
goos: darwin
goarch: amd64
pkg: server-go/7
cpu: Intel(R) Core(TM) i5-7360U CPU @ 2.30GHz
BenchmarkMutexReadMore-4              19          61786436 ns/op         9646439 B/op     183424 allocs/op
BenchmarkRwReadMore-4                 20          52166710 ns/op         9676492 B/op     183801 allocs/op
```

## åˆ†æ®µé”

è™½ç„¶è¯»å†™é”èƒ½æå‡è¯»å¤šå†™å°‘åœºæ™¯çš„æ€§èƒ½ï¼Œä½†æ˜¯å½“ç¼“å­˜å†™è¯·æ±‚å ç”¨é”æ—¶ï¼Œæ‰€æœ‰çš„ç¼“å­˜è¯»è¯·æ±‚ä»ç„¶ä¼šè¢«é˜»å¡ã€‚é‚£æœ‰æ²¡æœ‰åŠæ³•å‡å°‘é˜»å¡çš„è¯·æ±‚æ•°å‘¢ï¼Ÿ

å®é™…ä¸Šï¼Œ**å¯¹äºmapç»“æ„ï¼Œå½“å¹¶å‘å¯¹mapçš„è®¿é—®ç›¸å¯¹å‡åŒ€åœ°åˆ†å¸ƒåœ¨ä¸åŒçš„é”®ä¸Šæ—¶ï¼Œå¯ä»¥ç”¨åˆ†æ®µé”æ¥æé«˜å¹¶å‘æ€§èƒ½**ã€‚

å°±åƒä¸‹é¢çš„å›¾å±•ç¤ºçš„ä¸€æ ·ï¼Œåˆ†æ®µé”çš„æ ¸å¿ƒæ€æƒ³æ˜¯å°†ä¸€ä¸ªå¤§çš„å…±äº«æ•°æ®ç»“æ„ï¼ˆå¦‚mapï¼‰åˆ’åˆ†æˆå¤šä¸ªè¾ƒå°çš„æ®µï¼ˆsegmentï¼‰ï¼Œæ¯ä¸ªæ®µéƒ½æœ‰è‡ªå·±ç‹¬ç«‹çš„é”**ã€‚**è¿™æ ·ï¼Œå½“å¤šä¸ªåç¨‹è®¿é—®å…±äº«æ•°æ®æ—¶ï¼Œåªè¦å®ƒä»¬è®¿é—®çš„æ˜¯ä¸åŒæ®µçš„æ•°æ®ï¼Œå°±å¯ä»¥å¹¶å‘åœ°è¿›è¡Œæ“ä½œï¼Œè€Œä¸ä¼šäº’ç›¸é˜»å¡ã€‚åªæœ‰å½“å¤šä¸ªæ“ä½œæ¶‰åŠåŒä¸€ä¸ªæ®µæ—¶ï¼Œæ‰ä¼šåœ¨è¿™ä¸ªæ®µçš„é”ä¸Šäº§ç”Ÿç«äº‰ã€‚

![](https://static001.geekbang.org/resource/image/95/e1/95a76d459a9b2804e47bab2e5d9ea7e1.jpg?wh=1852x991 "å›¾1 åˆ†æ®µé”")

Golangå®˜æ–¹åº“æ²¡æœ‰ç°æˆçš„åˆ†æ®µé”Mapå®ç°ï¼Œæˆ‘è¿™é‡Œç»™äº†ä¸€ä¸ªç®€å•çš„å®ç°ï¼Œæ–¹ä¾¿ä½ ä½“ä¼šåˆ†æ®µé”çš„æ€æƒ³ã€‚

```go
// ConcurrentMapç»“æ„ä½“ä»£è¡¨æ•´ä¸ªå¹¶å‘å®‰å…¨çš„mapï¼ŒåŒ…å«å¤šä¸ªæ•°æ®åˆ†æ®µ
type ConcurrentMap struct {
    segments    []*segment
    numSegments int // å®šä¹‰åˆ†æ®µé”çš„æ®µæ•°ï¼Œå¯æ ¹æ®å®é™…æƒ…å†µè°ƒæ•´
}

// segmentç»“æ„ä½“ä»£è¡¨ä¸€ä¸ªæ•°æ®åˆ†æ®µï¼ŒåŒ…å«ä¸€ä¸ªäº’æ–¥é”å’Œä¸€ä¸ªmapç”¨äºå­˜å‚¨æ•°æ®
type segment struct {
    lock sync.RWMutex
    data map[string]string
}

// NewConcurrentMapåˆå§‹åŒ–ä¸€ä¸ªConcurrentMapå®ä¾‹
func NewConcurrentMap(numSegments int) *ConcurrentMap {
    cm := &ConcurrentMap{
        segments:    make([]*segment, numSegments),
        numSegments: numSegments,
    }
    for i := range cm.segments {
        cm.segments[i] = &segment{
            data: make(map[string]string),
        }
    }
    return cm
}

// getSegmentIndexæ ¹æ®é”®è®¡ç®—å…¶æ‰€å±çš„åˆ†æ®µç´¢å¼•
func (cm *ConcurrentMap) getSegmentIndex(key string) int {
    hash := 0
    for _, char := range key {
        hash += int(char)
    }
    return hash % cm.numSegments
}

// Setæ›´æ–°ç¼“å­˜ï¼Œå°†é”®å€¼å¯¹å­˜å…¥å¯¹åº”çš„åˆ†æ®µ
func (cm *ConcurrentMap) Set(key, value string) {
    segmentIndex := cm.getSegmentIndex(key)
    cm.segments[segmentIndex].lock.Lock()
    defer cm.segments[segmentIndex].lock.Unlock()
    cm.segments[segmentIndex].data[key] = value
}

// Getä»ç¼“å­˜ä¸­è·å–å€¼ï¼Œä»å¯¹åº”çš„åˆ†æ®µä¸­æŸ¥æ‰¾é”®å¯¹åº”çš„å€¼
func (cm *ConcurrentMap) Get(key string) (string, bool) {
    segmentIndex := cm.getSegmentIndex(key)
    cm.segments[segmentIndex].lock.RLock()
    defer cm.segments[segmentIndex].lock.RUnlock()
    value, ok := cm.segments[segmentIndex].data[key]
    return value, ok
}
```

è¿™æ®µä»£ç çš„æ ¸å¿ƒæ˜¯ä¸‹é¢å‡ ä¸ªè¦ç‚¹ã€‚

- é¦–å…ˆå®šä¹‰äº†ConcurrentMapç»“æ„ä½“å’Œsegmentç»“æ„ä½“ç±»å‹ã€‚ConcurrentMapç»“æ„ä½“è¡¨ç¤ºæ•´ä¸ªå¹¶å‘å®‰å…¨çš„mapï¼Œå®ƒåŒ…å«ä¸€ä¸ªsegmentç±»å‹çš„åˆ‡ç‰‡ï¼Œè€ŒsegmentåŒ…å«ä¸€ä¸ªè¯»å†™é”lockå’Œä¸€ä¸ªç”¨äºå­˜å‚¨æ•°æ®çš„mapå¯¹è±¡ï¼Œæ¯ä¸ªsegmentä»£è¡¨äº†æ•°æ®çš„ä¸€ä¸ªåˆ†æ®µã€‚
- åœ¨ConcurrentMapç»“æ„çš„å†™å…¥æ–¹æ³•é‡Œé¢ï¼Œä¼šå…ˆæ ¹æ®Keyç®—å‡ºéœ€è¦å†™å…¥çš„åˆ†æ®µï¼Œå¹¶å°†å¯¹åº”çš„åˆ†æ®µåŠ å†™é”è¿›è¡Œå†™å…¥ã€‚
- åœ¨ConcurrentMapç»“æ„çš„è¯»å–æ–¹æ³•é‡Œé¢ï¼Œä¼šå…ˆæ ¹æ®Keyç®—å‡ºéœ€è¦è¯»å–çš„åˆ†æ®µï¼Œå¹¶å°†å¯¹åº”çš„åˆ†æ®µåŠ è¯»é”è¿›è¡Œè¯»å–ã€‚

## æ— é”ç¼–ç¨‹

é™¤äº†ä¸Šé¢çš„åˆ†æ®µé”ï¼Œå®é™…ä¸Šï¼Œåœ¨æˆ‘ä»¬çš„å®è·µä¸­ï¼Œå¦‚æœå‘ç°å†…å­˜ç¼“å­˜çš„æ•°æ®é‡ä¸å¤§æ—¶ï¼Œå®Œå…¨å¯ä»¥åˆ©ç”¨atomicåŒ…ï¼Œå»é™¤æœ¬åœ°ç¼“å­˜çš„é”ä¾èµ–ï¼Œä»è€Œæœ€å¤§é™åº¦åœ°æå‡ç¼“å­˜è¯»æ€§èƒ½ã€‚

atomicåŒ…æä¾›äº†å¯¹æ•°æ®è¿›è¡ŒåŸå­æ“ä½œçš„åŠŸèƒ½ã€‚**æ‰€è°“åŸå­æ“ä½œï¼Œæ˜¯æŒ‡å¯¹æ•°æ®çš„ä¸€ä¸ªæ“ä½œï¼Œå¦‚æœåˆ†æˆå¤šä¸ªæ­¥éª¤ï¼Œè¿™äº›æ­¥éª¤å¯¹å¤–ä¼šè¡¨ç°æˆä¸å¯åˆ†å‰²çš„æ•´ä½“ï¼Œè¦ä¹ˆå®Œæ•´åœ°æ‰§è¡Œï¼Œè¦ä¹ˆå°±æ ¹æœ¬ä¸æ‰§è¡Œï¼Œå¤–ç•Œä¸ä¼šçœ‹åˆ°å®ƒä»¬åªæ‰§è¡Œåˆ°ä¸€åŠçš„çŠ¶æ€**ã€‚

æ¯”å¦‚å¯¹int64ç±»å‹å˜é‡çš„èµ‹å€¼æ“ä½œï¼Œåœ¨32ä½æœºå™¨ä¸Šå¯èƒ½ä¼šæ‹†åˆ†æˆä¸¤æ¡CPUæŒ‡ä»¤ï¼Œæ¯æ¡æŒ‡ä»¤å†™è¿™ä¸ªå˜é‡çš„ä¸€éƒ¨åˆ†ã€‚å¦‚æœä¸€ä¸ªåç¨‹å†™å®Œä½32ä½ï¼Œè¿˜æ²¡æ¥å¾—åŠå†™é«˜32ä½æ—¶ï¼Œå¦ä¸€ä¸ªåç¨‹è¯»å–äº†è¿™ä¸ªå˜é‡ï¼Œé‚£å®ƒè¯»åˆ°çš„å°±æ˜¯ä¸€ä¸ªè„æ•°æ®ï¼Œå¾ˆå¯èƒ½ä½¿æˆ‘ä»¬çš„ç¨‹åºå‡ºç°Bugï¼Œè€ŒåŸå­æ“ä½œå°±èƒ½é¿å…å…¶å®ƒåç¨‹è¯»åˆ°è¿™ä¸ªä¸­é—´çŠ¶æ€å˜é‡ã€‚

![](https://static001.geekbang.org/resource/image/59/3a/59147b339875a34b7fd1caaa87c4fd3a.jpg?wh=1268x337 "å›¾2 int64 å˜é‡èµ‹å€¼")

è®©æˆ‘ä»¬æ¥çœ‹çœ‹atomicåŒ…æä¾›çš„å¸¸è§åŸå­æ“ä½œæ–¹æ³•å’Œç±»å‹ã€‚atomicåŒ…æä¾›äº†ä»¥ä¸‹5ç±»æ“ä½œã€‚

- Addæ“ä½œï¼Œç”¨äºå¯¹å˜é‡è¿›è¡ŒåŠ æ³•æ“ä½œã€‚å®ƒä»¬æ¥å—ä¸€ä¸ªæŒ‡å‘å˜é‡çš„æŒ‡é’ˆå’Œä¸€ä¸ªå€¼ä½œä¸ºå‚æ•°ï¼ŒåŸå­åœ°å°†å˜é‡çš„å€¼å¢åŠ ç»™å®šçš„å¢é‡ã€‚

```go
func AddInt32(addr *int32, delta int32) (new int32)
func AddInt64(addr *int64, delta int64) (new int64)
func AddUint32(addr *uint32, delta uint32) (new uint32)
func AddUint64(addr *uint64, delta uint64) (new uint64)
func AddUintptr(addr *uintptr, delta uintptr) (new uintptr)
```

- CASæ“ä½œï¼Œç”¨äºå®ç°æ¯”è¾ƒå¹¶äº¤æ¢çš„åŸå­æ“ä½œã€‚å®ƒæ¥å—ä¸‰ä¸ªå‚æ•°ï¼šä¸€ä¸ªæŒ‡å‘å˜é‡çš„æŒ‡é’ˆã€ä¸€ä¸ªé¢„æœŸçš„æ—§å€¼å’Œä¸€ä¸ªæ–°å€¼ã€‚å®ƒçš„æ“ä½œé€»è¾‘æ˜¯å…ˆæ¯”è¾ƒæŒ‡é’ˆæ‰€æŒ‡å‘å˜é‡çš„å½“å‰å€¼æ˜¯å¦ä¸é¢„æœŸçš„æ—§å€¼ç›¸ç­‰ï¼Œå¦‚æœç›¸ç­‰ï¼Œå°±å°†å˜é‡çš„å€¼åŸå­åœ°æ›¿æ¢ä¸ºæ–°å€¼ï¼Œå¹¶è¿”å› trueï¼Œè¡¨ç¤ºäº¤æ¢æˆåŠŸï¼›å¦‚æœä¸ç›¸ç­‰ï¼Œå°±ä¸è¿›è¡Œæ›¿æ¢æ“ä½œï¼Œç›´æ¥è¿”å› falseï¼Œè¡¨ç¤ºäº¤æ¢å¤±è´¥ã€‚

```go
func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)
func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool)
func CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool)
func CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool)
func CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool)
func CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool)
```

- Loadæ“ä½œï¼Œç”¨äºåŸå­åœ°è¯»å–ä¸€ä¸ªå˜é‡çš„å€¼ã€‚è¿™äº›å‡½æ•°ä»¥ä¸€ä¸ªæŒ‡å‘å˜é‡çš„æŒ‡é’ˆä½œä¸ºå‚æ•°ï¼Œè¿”å›å˜é‡çš„å½“å‰å€¼ã€‚

```go
func LoadInt32(addr *int32) (val int32)
func LoadInt64(addr *int64) (val int64)
func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer)
func LoadUint32(addr *uint32) (val uint32)
func LoadUint64(addr *uint64) (val uint64)
func LoadUintptr(addr *uintptr) (val uintptr)
```

- Storeæ“ä½œï¼Œç”¨äºè®¾ç½®å˜é‡çš„å€¼ã€‚åŒæ ·ä»¥æŒ‡é’ˆä½œä¸ºå‚æ•°ï¼Œå°†ç»™å®šçš„å€¼åŸå­åœ°å­˜å‚¨åˆ°å˜é‡ä¸­ã€‚

```typescript
func StoreInt32(addr *int32, val int32)
func StoreInt64(addr *int64, val int64)
func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer)
func StoreUint32(addr *uint32, val uint32)
func StoreUint64(addr *uint64, val uint64)
func StoreUintptr(addr *uintptr, val uintptr)
```

- Swapæ“ä½œï¼Œç”¨äºäº¤æ¢å˜é‡çš„å€¼ã€‚å®ƒæ¥å—ä¸€ä¸ªæŒ‡å‘å˜é‡çš„æŒ‡é’ˆå’Œä¸€ä¸ªæ–°å€¼ä½œä¸ºå‚æ•°ï¼ŒåŸå­åœ°å°†å˜é‡çš„å½“å‰å€¼æ›¿æ¢ä¸ºæ–°å€¼ï¼Œå¹¶**è¿”å›è¢«æ›¿æ¢çš„æ—§å€¼**ã€‚

```go
func SwapInt32(addr *int32, new int32) (old int32)
func SwapInt64(addr *int64, new int64) (old int64)
func SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer)
func SwapUint32(addr *uint32, new uint32) (old uint32)
func SwapUint64(addr *uint64, new uint64) (old uint64)
func SwapUintptr(addr *uintptr, new uintptr) (old uintptr)
```

ä¸Šé¢5ç±»æ“ä½œçš„å¯¹è±¡ï¼Œéƒ½æ˜¯å¸¸è§çš„æ•´å‹å’ŒæŒ‡é’ˆç±»å‹ï¼Œä¸ºäº†æä¾›å¯¹å¤æ‚ç±»å‹å¯¹è±¡è¿›è¡ŒåŸå­å­˜å–çš„èƒ½åŠ›ï¼ŒatomicåŒ…è¿˜æä¾›äº†Valueç±»å‹ã€‚

Valueç±»å‹æä¾›äº†ä¸‹é¢4ä¸ªæ–¹æ³•ï¼Œè¿™å‡ ä¸ªæ–¹æ³•çš„åŠŸèƒ½å’ŒatomicåŒ…çš„åŠŸèƒ½ç±»ä¼¼ï¼Œä½†æ˜¯æ“ä½œçš„æ˜¯ä»»æ„ç±»å‹çš„å¯¹è±¡ã€‚

```go
func (v *Value) CompareAndSwap(old, new any) (swapped bool)
func (v *Value) Load() (val any)
func (v *Value) Store(val any)
func (v *Value) Swap(new any) (old any)
```

åœ¨äº†è§£äº†atomicåŒ…åŠŸèƒ½ä¹‹åï¼Œç°åœ¨è®©æˆ‘ä»¬ç”¨atomicåŒ…çš„Valueç±»å‹æ¥å®ç°ä¸€ä¸ªè¯»å†™æ— éœ€åŠ é”çš„æœ¬åœ°ç¼“å­˜ç»“æ„ï¼Œç¤ºä¾‹ä»£ç å¦‚ä¸‹ã€‚

```go
import (
    "sync/atomic"
)

// LockFreeCacheç»“æ„ä½“ç”¨äºç®¡ç†æœ¬åœ°ç¼“å­˜
type LockFreeCache struct {
    cacheMap atomic.Value
}

// NewLockFreeCacheåˆå§‹åŒ–ä¸€ä¸ªLockFreeCacheå®ä¾‹ï¼ŒåŒæ—¶åˆå§‹åŒ–ç¬¬ä¸€ä¸ªmap
func NewLockFreeCache() *LockFreeCache {
    c := &LockFreeCache{}
    initialMap := make(map[string]interface{})
    c.cacheMap.Store(&initialMap)
    return c
}


// Updateæ›¿æ¢æ•´ä¸ªç¼“å­˜map
func (c *LockFreeCache) Update(newMap map[string]interface{}) {
    newMapPtr := &newMap
    c.cacheMap.Store(newMapPtr)
}

// Getä»ç¼“å­˜ä¸­è·å–å€¼
func (c *LockFreeCache) Get(key string) (interface{}, bool) {
    cacheMap := c.cacheMap.Load().(*map[string]interface{})
    value, ok := (*cacheMap)[key]
    return value, ok
}
```

è¿™æ®µä»£ç ä¹Ÿå¾ˆå¥½ç†è§£ï¼Œæ ¸å¿ƒæ˜¯ä¸‹é¢å‡ æ­¥ã€‚

é¦–å…ˆï¼Œå’±ä»¬è®¾è®¡ä¸€ä¸ªLockFreeCacheçš„ç»“æ„ï¼Œè¿™ä¸ªç»“æ„çš„æˆå‘˜å˜é‡æ˜¯atomicåŒ…çš„Valueç±»å‹ï¼Œç”¨äºå­˜å‚¨mapç±»å‹çš„å¯¹è±¡æŒ‡é’ˆã€‚

æ¥ç€ï¼Œåœ¨NewLockFreeCacheæ„é€ å‡½æ•°ä¸­åˆ›å»ºLockFreeCacheå¯¹è±¡ï¼Œå¹¶åˆå§‹åŒ–æˆå‘˜å˜é‡ã€‚

ç„¶åï¼Œæˆ‘ä»¬æä¾›äº†Updateæ–¹æ³•ï¼Œå†…éƒ¨è°ƒç”¨Valueç±»å‹çš„Storeæ–¹æ³•ï¼ŒåŸå­åœ°å°†mapå¯¹è±¡æŒ‡é’ˆå­˜å…¥Valueå¯¹è±¡é‡Œï¼Œä»è€Œå®ç°å…¨é‡ç¼“å­˜æ•°æ®æ›´æ–°ã€‚

æœ€åï¼Œæˆ‘ä»¬æä¾›äº†Getæ–¹æ³•ï¼Œå®ƒçš„å†…éƒ¨è°ƒç”¨Valueç±»å‹çš„Loadæ–¹æ³•ï¼ŒåŸå­åœ°è·å–mapå¯¹è±¡æŒ‡é’ˆï¼Œä»mapå¯¹è±¡é‡Œè·å–ç¼“å­˜Keyå¯¹åº”çš„valueã€‚

## å°ç»“

ä»Šå¤©è¿™èŠ‚è¯¾ï¼Œæˆ‘ä»¥ä¸€ä¸ªæœ¬åœ°ç¼“å­˜æ•°æ®ç»“æ„çš„è®¾è®¡ä¸ºä¾‹ï¼Œåœ¨é€æ­¥å¯¹å…¶è¿›è¡Œè®¾è®¡ä¼˜åŒ–çš„è¿‡ç¨‹ä¸­ï¼Œå¸¦ä½ å­¦ä¹ äº†Golangé”å’ŒatomicåŒ…çš„çŸ¥è¯†ã€‚ç°åœ¨è®©æˆ‘ä»¬å›é¡¾ä¸€ä¸‹é”å’ŒatomicåŒ…çš„åº”ç”¨åœºæ™¯ã€‚

- å½“å¯¹æ•°æ®çš„å†™æ“ä½œè¾ƒå¤šæˆ–è€…è¯»æ“ä½œä¸é¢‘ç¹æ—¶ï¼Œå¯ä»¥ä½¿ç”¨äº’æ–¥é”ä¿è¯å¹¶å‘è®¿é—®çš„å®‰å…¨æ€§ï¼›
- å½“è¯»æ“ä½œè¿œè¿œå¤šäºå†™æ“ä½œæ—¶ï¼Œå¯ä»¥ä½¿ç”¨è¯»å†™é”ï¼Œå…è®¸å¤šä¸ªåç¨‹åŒæ—¶è¿›è¡Œè¯»æ“ä½œï¼Œè€Œåœ¨å†™æ“ä½œæ—¶è¿›è¡Œç‹¬å å¼è®¿é—®ï¼Œè¿™æ ·å¯ä»¥æé«˜å¹¶å‘è¯»å–çš„æ€§èƒ½ï¼›
- å½“å¤§é‡æ•°æ®å­˜å‚¨åœ¨mapä¸­ï¼Œå¹¶ä¸”åç¨‹å¯¹mapçš„è®¿é—®ç›¸å¯¹å‡åŒ€åœ°åˆ†å¸ƒåœ¨ä¸åŒçš„é”®ä¸Šæ—¶ï¼Œå¯ä»¥è€ƒè™‘ä½¿ç”¨åˆ†æ®µé”æé«˜æ€§èƒ½ã€‚å…·ä½“æ˜¯é€šè¿‡å°†mapåˆ†æˆå¤šä¸ªæ®µï¼Œæ¯ä¸ªæ®µæœ‰è‡ªå·±çš„é”ï¼Œé™ä½é”ç²’åº¦ï¼Œä»è€Œæå‡å¹¶å‘æ€§èƒ½ã€‚
- å½“éœ€è¦å¯¹å…±äº«å¯¹è±¡è¿›è¡ŒåŸå­æ“ä½œæ—¶ï¼Œå¯ä»¥åˆ©ç”¨atomicåŒ…æ— é”ç¼–ç¨‹ï¼Œé¿å…åŠ é”æ“ä½œï¼Œä»è€Œæå‡æ€§èƒ½ã€‚

å¸Œæœ›ä½ èƒ½å¤Ÿç”¨å¿ƒå»ä½“ä¼šå„ç§é”å’ŒatomicåŒ…çš„åº”ç”¨ã€‚åœ¨ä»Šåé‡åˆ°éœ€è¦å¯¹æ•°æ®è¿›è¡Œå¹¶å‘æ“ä½œçš„åœºæ™¯æ—¶ï¼Œåˆ«å¿˜äº†é€‰æ‹©åˆé€‚çš„å¹¶å‘å®‰å…¨è®¿é—®æ–¹å¼ã€‚

## æ€è€ƒé¢˜

åœ¨ä¼—å¤šçš„æ•°æ®ç»“æ„ä¸­ï¼Œæ ˆæ˜¯æ¯”è¾ƒé‡è¦çš„ä¸€ä¸ªæ•°æ®ç»“æ„ï¼Œè¯·ä½ ä½¿ç”¨è¿™èŠ‚è¯¾å­¦åˆ°çš„atomicåŒ…çŸ¥è¯†ï¼Œå®ç°ä¸€ä¸ªå¹¶å‘å®‰å…¨çš„æ— é”æ ˆã€‚

æ¬¢è¿ä½ æŠŠä½ çš„ç­”æ¡ˆåˆ†äº«åœ¨è¯„è®ºåŒºï¼Œä¹Ÿæ¬¢è¿ä½ æŠŠè¿™èŠ‚è¯¾çš„å†…å®¹åˆ†äº«ç»™éœ€è¦çš„æœ‹å‹ï¼Œæˆ‘ä»¬ä¸‹èŠ‚è¯¾å†è§ï¼
<div><strong>ç²¾é€‰ç•™è¨€ï¼ˆ3ï¼‰</strong></div><ul>
<li><span>lJ</span> ğŸ‘ï¼ˆ1ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>1. LockFreeCacheè™½ç„¶ atomic.Value å¯ä»¥ç¡®ä¿å¯¹æ•´ä¸ª map çš„åŸå­æ€§æ›´æ–°ï¼Œä½†å¥½åƒä¾ç„¶å­˜åœ¨è¯»å†™å†²çªé—®é¢˜ã€‚ä¾‹å¦‚ï¼Œåœ¨ Get æ–¹æ³•ä¸­è¯»å–äº† map çš„æŒ‡é’ˆåï¼Œå¯¹ map çš„å†…å®¹æ“ä½œæ˜¯éåŸå­çš„ã€‚å¦‚æœæ­¤æ—¶å¦ä¸€ä¸ªåç¨‹è°ƒç”¨ Update æ›¿æ¢äº†æ•´ä¸ª mapï¼Œé‚£ä¹ˆè¯»å–å°±å¯èƒ½æ˜¯è¿‡æ—¶çš„æ•°æ®äº†å§ã€‚å¦‚æœå†åŠ äº’æ–¥é”ï¼Œé‚£ä¹ˆè¿˜ä¸å¦‚åŸºäºRWMutexCacheå®ç°å‘¢ã€‚å¦å¤–ï¼Œè°ƒç”¨ Update æ–¹æ³•æ—¶ï¼Œæ–°çš„ map è¢«å­˜å‚¨åœ¨ atomic.Value ä¸­ï¼Œè€Œæ—§çš„ map ä»ç„¶åœ¨å†…å­˜ä¸­ï¼Œä¼šå¯¼è‡´å†…å­˜æ³„æ¼çš„å§ã€‚
2. è¿™ç§æ— æ‰€ç¼–ç¨‹å®ç°çš„mapå…¶å¯¹åº”çš„benchmarkæµ‹è¯•ï¼Œæ€§èƒ½å¦‚ä½•
3. é¢è¯•ä¸­é‡åˆ°è¿‡é—®åŸºäºchannelå®ç°çš„å¹¶å‘å®‰å…¨mapï¼Œè¿™ä¸ªå®ç°é€‚ç”¨çš„åœºæ™¯æ˜¯å•¥ï¼Œæ˜¯å¦æœ‰å¯æ›¿æ¢çš„æ–¹æ³•å‘¢ï¼Ÿ
4. æ€è€ƒé¢˜

type StackNode struct {
	value interface{}
	next  *StackNode
}


type LockFreeStack struct {
	head unsafe.Pointer &#47;&#47; æ ˆé¡¶èŠ‚ç‚¹
}


func NewLockFreeStack() *LockFreeStack {
	return &amp;LockFreeStack{}
}


func (s *LockFreeStack) Push(value interface{}) {
	newNode := &amp;StackNode{value: value}
	for {
		currentHead := (*StackNode)(atomic.LoadPointer(&amp;s.head))
		newNode.next = currentHead
		if atomic.CompareAndSwapPointer(&amp;s.head, unsafe.Pointer(currentHead), unsafe.Pointer(newNode)) {
			return
		}
	}
}

func (s *LockFreeStack) Pop() (interface{}, bool) {
	for {
		currentHead := (*StackNode)(atomic.LoadPointer(&amp;s.head))
		if currentHead == nil {
			return nil, false
		}
		if atomic.CompareAndSwapPointer(&amp;s.head, unsafe.Pointer(currentHead), unsafe.Pointer(currentHead.next)) {
			return currentHead.value, true
		}
	}
}

</p>2024-12-23</li><br/><li><span>Geek_f39c45</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>è¯·é—®å¾è€å¸ˆåœ¨æ— é”ç¼–ç¨‹çš„æ—¶å€™å¦‚æœä¸€æ–¹åœ¨updateï¼Œå¦å¤–ä¸€æ–¹åœ¨getæ“ä½œçš„æ—¶å€™ï¼ŒåŸå­æ“ä½œæ²¡æœ‰ä¸­é—´ç»“æœé‚£ä¹ˆgetçœ‹åˆ°çš„ä¼šæ˜¯æ—§çš„å€¼å—ï¼Ÿ</p>2025-01-03</li><br/><li><span>æ ‘å¿ƒ</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>å¾è€å¸ˆï¼Œäº¤ä½œä¸šå•¦ï¼Œæ±‚æ‰¹æ”¹
package main

import (
	&quot;fmt&quot;
	&quot;sync&#47;atomic&quot;
)

type Node struct {
	value interface{}
	next  *Node
}

type LockFreeStack struct {
	top atomic.Pointer[Node]
}

func NewLockFreeStack() *LockFreeStack {
	return &amp;LockFreeStack{}
}

func (s *LockFreeStack) Push(value interface{}) {
	node := &amp;Node{
		value: value,
	}

	for {
		oldTop := s.top.Load()

		node.next = oldTop

		if s.top.CompareAndSwap(oldTop, node) {
			return
		}
	}
}

func (s *LockFreeStack) Pop() (interface{}, bool) {
	for {
		oldTop := s.top.Load()

		if oldTop == nil {
			return nil, false
		}

		newTop := oldTop.next

		if s.top.CompareAndSwap(oldTop, newTop) {
			return oldTop.value, true
		}
	}
}

func main() {
	stack := NewLockFreeStack()

	stack.Push(1)
	stack.Push(2)
	stack.Push(3)

	value, ok := stack.Pop()
	fmt.Println(value, ok)

	value, ok = stack.Pop()
	fmt.Println(value, ok)

	value, ok = stack.Pop()
	fmt.Println(value, ok)

	value, ok = stack.Pop()
	fmt.Println(value, ok)
}
</p>2024-12-26</li><br/>
</ul>