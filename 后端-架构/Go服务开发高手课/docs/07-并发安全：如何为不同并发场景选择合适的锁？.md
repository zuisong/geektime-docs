ä½ å¥½ï¼Œæˆ‘æ˜¯å¾é€¸ã€‚

ä¸ŠèŠ‚è¯¾æˆ‘ä»¬ä¸€èµ·å­¦ä¹ äº†å¹¶å‘ç­‰å¾…æŠ€æœ¯ã€‚ä¸è¿‡åœ¨å®é™…çš„ç¼–ç¨‹å®è·µä¸­ï¼Œæˆ‘ä»¬ä¼šé‡åˆ°å„ç§å„æ ·çš„å¹¶å‘åœºæ™¯ï¼Œæ‰€éœ€è¦çš„å¹¶å‘æŠ€æœ¯ä¹Ÿä¼šæœ‰æ‰€ä¸åŒã€‚ä»Šå¤©å’±ä»¬å°±æ¥èŠèŠåœ¨å¹¶å‘ç¯å¢ƒä¸‹ï¼Œå¦‚ä½•å·§å¦™åœ°è¿ç”¨é”ï¼Œå®ç°é«˜æ€§èƒ½ã€å®‰å…¨åœ°è®¿é—®å¤šåç¨‹å…±äº«çš„æ•°æ®ã€‚

æˆ‘ä»¬å…ˆä»ä¸€ä¸ªé—®é¢˜å…¥æ‰‹ã€‚å‡å¦‚æˆ‘ä»¬ç°åœ¨éœ€è¦å®ç°ä¸€ä¸ªåº•å±‚ç”¨mapç±»å‹å­˜å‚¨æ•°æ®çš„æœ¬åœ°ç¼“å­˜ï¼Œè¯¥æ€ä¹ˆè®¾è®¡ï¼Œæ‰èƒ½åœ¨å¹¶å‘ç¯å¢ƒä¸‹é«˜æ€§èƒ½ä¸”å®‰å…¨åœ°è®¿é—®è¿™ä¸ªç¼“å­˜å‘¢ï¼Ÿ

## äº’æ–¥é”

å¯¹äºå¤šåç¨‹å…±äº«æ•°æ®çš„å®‰å…¨è®¿é—®ï¼Œæœ€ç®€å•çš„æ–¹æ¡ˆå°±æ˜¯ç”¨äº’æ–¥é”ã€‚**äº’æ–¥é”èƒ½ä¿è¯åœ¨åŒä¸€æ—¶åˆ»ï¼Œåªæœ‰ä¸€ä¸ªåç¨‹èƒ½å¤Ÿè®¿é—®è¢«ä¿æŠ¤çš„å…±äº«æ•°æ®**ã€‚

åœ¨Golangä¸­ï¼Œå¹¶å‘åŒ…syncé‡Œé¢çš„Mutexç±»å‹å®ç°äº†äº’æ–¥é”åŠŸèƒ½ã€‚å®ƒçš„æ ¸å¿ƒæ˜¯ä¸‹é¢ä¸¤ä¸ªæ–¹æ³•ã€‚

- Lockæ–¹æ³•ï¼Œç”¨äºåŠ é”ï¼Œå½“é”å·²ç»è¢«å ç”¨æ—¶ï¼Œè°ƒç”¨åç¨‹ä¼šé˜»å¡ç›´åˆ°é”å¯ç”¨ã€‚
- Unlockæ–¹æ³•ï¼Œç”¨äºé‡Šæ”¾é”ã€‚

```go
func (m *Mutex) Lock()
func (m *Mutex) Unlock()
```

çŸ¥é“äº†Mutexç±»å‹çš„æ–¹æ³•ï¼Œå¦‚åŒä¸‹é¢çš„ä»£ç ä¸€æ ·ï¼Œå’±ä»¬å¯ä»¥åœ¨æœ¬åœ°ç¼“å­˜çš„è¯»å†™æ“ä½œä¸­ï¼Œè°ƒç”¨Mutexå¯¹è±¡çš„Lockå’ŒUnlockæ–¹æ³•æ¥å®ç°å¹¶å‘å®‰å…¨çš„æœ¬åœ°ç¼“å­˜è®¿é—®ã€‚

```go
import (
    "sync"
)

type MutexCache struct {
    mu   sync.Mutex        // äº’æ–¥é”
    data map[string]string // å…±äº«æ•°æ®
}

// NewMutexCacheåˆå§‹åŒ–ä¸€ä¸ªMutexCacheå®ä¾‹
func NewMutexCache() *MutexCache {
    c := &MutexCache{data: make(map[string]string)}
    return c
}

// Setæ›´æ–°ç¼“å­˜
func (c *MutexCache) Set(key, value string) {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.data[key] = value
}

// Getä»ç¼“å­˜ä¸­è·å–å€¼
func (c *MutexCache) Get(key string) (string, bool) {
    c.mu.Lock()
    defer c.mu.Unlock()
    value, ok := c.data[key]
    return value, ok
}
```
<div><strong>ç²¾é€‰ç•™è¨€ï¼ˆ3ï¼‰</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/27/19/fe/d31344db.jpg" width="30px"><span>lJ</span> ğŸ‘ï¼ˆ1ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<div>1. LockFreeCacheè™½ç„¶ atomic.Value å¯ä»¥ç¡®ä¿å¯¹æ•´ä¸ª map çš„åŸå­æ€§æ›´æ–°ï¼Œä½†å¥½åƒä¾ç„¶å­˜åœ¨è¯»å†™å†²çªé—®é¢˜ã€‚ä¾‹å¦‚ï¼Œåœ¨ Get æ–¹æ³•ä¸­è¯»å–äº† map çš„æŒ‡é’ˆåï¼Œå¯¹ map çš„å†…å®¹æ“ä½œæ˜¯éåŸå­çš„ã€‚å¦‚æœæ­¤æ—¶å¦ä¸€ä¸ªåç¨‹è°ƒç”¨ Update æ›¿æ¢äº†æ•´ä¸ª mapï¼Œé‚£ä¹ˆè¯»å–å°±å¯èƒ½æ˜¯è¿‡æ—¶çš„æ•°æ®äº†å§ã€‚å¦‚æœå†åŠ äº’æ–¥é”ï¼Œé‚£ä¹ˆè¿˜ä¸å¦‚åŸºäºRWMutexCacheå®ç°å‘¢ã€‚å¦å¤–ï¼Œè°ƒç”¨ Update æ–¹æ³•æ—¶ï¼Œæ–°çš„ map è¢«å­˜å‚¨åœ¨ atomic.Value ä¸­ï¼Œè€Œæ—§çš„ map ä»ç„¶åœ¨å†…å­˜ä¸­ï¼Œä¼šå¯¼è‡´å†…å­˜æ³„æ¼çš„å§ã€‚
2. è¿™ç§æ— æ‰€ç¼–ç¨‹å®ç°çš„mapå…¶å¯¹åº”çš„benchmarkæµ‹è¯•ï¼Œæ€§èƒ½å¦‚ä½•
3. é¢è¯•ä¸­é‡åˆ°è¿‡é—®åŸºäºchannelå®ç°çš„å¹¶å‘å®‰å…¨mapï¼Œè¿™ä¸ªå®ç°é€‚ç”¨çš„åœºæ™¯æ˜¯å•¥ï¼Œæ˜¯å¦æœ‰å¯æ›¿æ¢çš„æ–¹æ³•å‘¢ï¼Ÿ
4. æ€è€ƒé¢˜

type StackNode struct {
	value interface{}
	next  *StackNode
}


type LockFreeStack struct {
	head unsafe.Pointer &#47;&#47; æ ˆé¡¶èŠ‚ç‚¹
}


func NewLockFreeStack() *LockFreeStack {
	return &amp;LockFreeStack{}
}


func (s *LockFreeStack) Push(value interface{}) {
	newNode := &amp;StackNode{value: value}
	for {
		currentHead := (*StackNode)(atomic.LoadPointer(&amp;s.head))
		newNode.next = currentHead
		if atomic.CompareAndSwapPointer(&amp;s.head, unsafe.Pointer(currentHead), unsafe.Pointer(newNode)) {
			return
		}
	}
}

func (s *LockFreeStack) Pop() (interface{}, bool) {
	for {
		currentHead := (*StackNode)(atomic.LoadPointer(&amp;s.head))
		if currentHead == nil {
			return nil, false
		}
		if atomic.CompareAndSwapPointer(&amp;s.head, unsafe.Pointer(currentHead), unsafe.Pointer(currentHead.next)) {
			return currentHead.value, true
		}
	}
}

</div>2024-12-23</li><br/><li><img src="" width="30px"><span>Geek_f39c45</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<div>è¯·é—®å¾è€å¸ˆåœ¨æ— é”ç¼–ç¨‹çš„æ—¶å€™å¦‚æœä¸€æ–¹åœ¨updateï¼Œå¦å¤–ä¸€æ–¹åœ¨getæ“ä½œçš„æ—¶å€™ï¼ŒåŸå­æ“ä½œæ²¡æœ‰ä¸­é—´ç»“æœé‚£ä¹ˆgetçœ‹åˆ°çš„ä¼šæ˜¯æ—§çš„å€¼å—ï¼Ÿ</div>2025-01-03</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/18/41/13/bf8e85cc.jpg" width="30px"><span>æ ‘å¿ƒ</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<div>å¾è€å¸ˆï¼Œäº¤ä½œä¸šå•¦ï¼Œæ±‚æ‰¹æ”¹
package main

import (
	&quot;fmt&quot;
	&quot;sync&#47;atomic&quot;
)

type Node struct {
	value interface{}
	next  *Node
}

type LockFreeStack struct {
	top atomic.Pointer[Node]
}

func NewLockFreeStack() *LockFreeStack {
	return &amp;LockFreeStack{}
}

func (s *LockFreeStack) Push(value interface{}) {
	node := &amp;Node{
		value: value,
	}

	for {
		oldTop := s.top.Load()

		node.next = oldTop

		if s.top.CompareAndSwap(oldTop, node) {
			return
		}
	}
}

func (s *LockFreeStack) Pop() (interface{}, bool) {
	for {
		oldTop := s.top.Load()

		if oldTop == nil {
			return nil, false
		}

		newTop := oldTop.next

		if s.top.CompareAndSwap(oldTop, newTop) {
			return oldTop.value, true
		}
	}
}

func main() {
	stack := NewLockFreeStack()

	stack.Push(1)
	stack.Push(2)
	stack.Push(3)

	value, ok := stack.Pop()
	fmt.Println(value, ok)

	value, ok = stack.Pop()
	fmt.Println(value, ok)

	value, ok = stack.Pop()
	fmt.Println(value, ok)

	value, ok = stack.Pop()
	fmt.Println(value, ok)
}
</div>2024-12-26</li><br/>
</ul>