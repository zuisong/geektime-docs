ä½ å¥½ï¼Œæˆ‘æ˜¯å´å’ç‚œã€‚

ä¸Šä¸€è®²æˆ‘ä»¬åˆæ­¥ä»‹ç»äº†å‡½æ•°å¯¹è±¡å’Œ lambda è¡¨è¾¾å¼ï¼Œä»Šå¤©æˆ‘ä»¬æ¥è®²è®²å®ƒä»¬çš„ä¸»è¦ç”¨é€”â€”â€”å‡½æ•°å¼ç¼–ç¨‹ã€‚

## ä¸€ä¸ªå°ä¾‹å­

æŒ‰æƒ¯ä¾‹ï¼Œæˆ‘ä»¬è¿˜æ˜¯ä»ä¸€ä¸ªä¾‹å­å¼€å§‹ã€‚æƒ³ä¸€ä¸‹ï¼Œå¦‚æœç»™å®šä¸€ç»„æ–‡ä»¶åï¼Œè¦æ±‚æ•°ä¸€ä¸‹æ–‡ä»¶é‡Œçš„æ€»æ–‡æœ¬è¡Œæ•°ï¼Œä½ ä¼šæ€ä¹ˆåšï¼Ÿ

æˆ‘ä»¬å…ˆè§„å®šä¸€ä¸‹å‡½æ•°çš„åŸå‹ï¼š

```c++
int count_lines(const char** begin,
                const char** end);
```

ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬æœŸå¾…æ¥å—ä¸¤ä¸ª C å­—ç¬¦ä¸²çš„è¿­ä»£å™¨ï¼Œç”¨æ¥éå†æ‰€æœ‰çš„æ–‡ä»¶åï¼›è¿”å›å€¼ä»£è¡¨æ–‡ä»¶ä¸­çš„æ€»è¡Œæ•°ã€‚

è¦æµ‹è¯•è¡Œä¸ºæ˜¯å¦æ­£å¸¸ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªå¾ˆå°çš„ `main` å‡½æ•°ï¼š

```c++
int main(int argc,
         const char** argv)
{
  int total_lines = count_lines(
    argv + 1, argv + argc);
  cout << "Total lines: "
       << total_lines << endl;
}
```

æœ€ä¼ ç»Ÿçš„å‘½ä»¤å¼ç¼–ç¨‹å¤§æ¦‚ä¼šè¿™æ ·å†™ä»£ç ï¼š

```c++
int count_file(const char* name)
{
  int count = 0;
  ifstream ifs(name);
  string line;
  for (;;) {
    getline(ifs, line);
    if (!ifs) {
      break;
    }
    ++count;
  }
  return count;
}

int count_lines(const char** begin,
                const char** end)
{
  int count = 0;
  for (; begin != end; ++begin) {
    count += count_file(*begin);
  }
  return count;
}
```

æˆ‘ä»¬é©¬ä¸Šå¯ä»¥åšä¸€ä¸ªç®€å•çš„â€œè¯´æ˜å¼â€æ”¹é€ ã€‚ç”¨ `istream_line_reader` å¯ä»¥ç®€åŒ– `count_file` æˆï¼š

```c++
int count_file(const char* name)
{
  int count = 0;
  ifstream ifs(name);
  for (auto&& line :
       istream_line_reader(ifs)) {
    ++count;
  }
  return count;
}
```

åœ¨è¿™å„¿ï¼Œè¦è¯·ä½ åœä¸€ä¸‹ï¼Œæƒ³ä¸€æƒ³å¦‚ä½•è¿›ä¸€æ­¥ä¼˜åŒ–è¿™ä¸ªä»£ç ã€‚ç„¶åå†ç»§ç»­è¿›è¡Œå¾€ä¸‹çœ‹ã€‚

* * *

å¦‚æœæˆ‘ä»¬ä½¿ç”¨ä¹‹å‰å·²ç»å‡ºåœºè¿‡çš„ä¸¤ä¸ªå‡½æ•°ï¼Œ`transform` \[1] å’Œ `accumulate` \[2]ï¼Œä»£ç å¯ä»¥è¿›ä¸€æ­¥ç®€åŒ–ä¸ºï¼š

```c++
int count_file(const char* name)
{
  ifstream ifs(name);
  istream_line_reader reader(ifs);
  return distance(reader.begin(),
                  reader.end());
}

int count_lines(const char** begin,
                const char** end)
{
  vector<int> count(end - begin);
  transform(begin, end,
            count.begin(),
            count_file);
  return accumulate(
    count.begin(), count.end(),
    0);
}
```

è¿™ä¸ªå°±æ˜¯ä¸€ä¸ªéå¸¸å‡½æ•°å¼é£æ ¼çš„ç»“æœäº†ã€‚ä¸Šé¢è¿™ä¸ªå¤„ç†æ–¹å¼æ°æ°å°±æ˜¯ map-reduceã€‚`transform` å¯¹åº” mapï¼Œ`accumulate` å¯¹åº” reduceã€‚è€Œæ£€æŸ¥æœ‰å¤šå°‘è¡Œæ–‡æœ¬ï¼Œä¹Ÿæˆäº†ä»£è¡¨æ–‡ä»¶å¤´å°¾ä¸¤ä¸ªè¿­ä»£å™¨ä¹‹é—´çš„â€œè·ç¦»â€ï¼ˆdistanceï¼‰ã€‚

## å‡½æ•°å¼ç¼–ç¨‹çš„ç‰¹ç‚¹

åœ¨æˆ‘ä»¬çš„ä»£ç é‡Œä¸é‚£ä¹ˆæ˜æ˜¾çš„ä¸€ç‚¹æ˜¯ï¼Œå‡½æ•°å¼ç¼–ç¨‹æœŸæœ›å‡½æ•°çš„è¡Œä¸ºåƒæ•°å­¦ä¸Šçš„å‡½æ•°ï¼Œè€Œéä¸€ä¸ªè®¡ç®—æœºä¸Šçš„å­ç¨‹åºã€‚è¿™æ ·çš„å‡½æ•°ä¸€èˆ¬è¢«ç§°ä¸ºçº¯å‡½æ•°ï¼ˆpure functionï¼‰ï¼Œè¦ç‚¹åœ¨äºï¼š

- ä¼šå½±å“å‡½æ•°ç»“æœçš„åªæ˜¯å‡½æ•°çš„å‚æ•°ï¼Œæ²¡æœ‰å¯¹ç¯å¢ƒçš„ä¾èµ–
- è¿”å›çš„ç»“æœå°±æ˜¯å‡½æ•°æ‰§è¡Œçš„å”¯ä¸€åæœï¼Œä¸äº§ç”Ÿå¯¹ç¯å¢ƒçš„å…¶ä»–å½±å“

è¿™æ ·çš„ä»£ç çš„æœ€å¤§å¥½å¤„æ˜¯æ˜“äºç†è§£å’Œæ˜“äºæ¨ç†ï¼Œåœ¨å¾ˆå¤šæƒ…å†µä¸‹ä¹Ÿä¼šä½¿ä»£ç æ›´ç®€å•ã€‚åœ¨æˆ‘ä»¬ä¸Šé¢çš„ä»£ç é‡Œï¼Œ`count_file` å’Œ `accumulate` åŸºæœ¬ä¸Šå¯ä»¥çœ‹åšæ˜¯çº¯å‡½æ•°ï¼ˆè™½ç„¶å‰è€…å®é™…ä¸Šæœ‰ç€å¯¹æ–‡ä»¶ç³»ç»Ÿçš„ä¾èµ–ï¼‰ï¼Œä½† `transform` ä¸è¡Œï¼Œå› ä¸ºå®ƒæ”¹å˜äº†æŸä¸ªå‚æ•°ï¼Œè€Œä¸æ˜¯è¿”å›ä¸€ä¸ªç»“æœã€‚ä¸‹ä¸€è®²æˆ‘ä»¬ä¼šçœ‹åˆ°ï¼Œè¿™ä¼šå½±å“ä»£ç çš„ç»„åˆæ€§ã€‚

æˆ‘ä»¬çš„ä»£ç ä¸­ä¹Ÿä½“ç°äº†å…¶ä»–ä¸€äº›å‡½æ•°å¼ç¼–ç¨‹çš„ç‰¹ç‚¹ï¼š

- å‡½æ•°å°±åƒæ™®é€šçš„å¯¹è±¡ä¸€æ ·è¢«ä¼ é€’ã€ä½¿ç”¨å’Œè¿”å›ã€‚
- ä»£ç ä¸ºè¯´æ˜å¼è€Œéå‘½ä»¤å¼ã€‚åœ¨ç†Ÿæ‚‰å‡½æ•°å¼ç¼–ç¨‹çš„åŸºæœ¬èŒƒå¼åï¼Œä½ ä¼šå‘ç°è¯´æ˜å¼ä»£ç çš„å¯è¯»æ€§é€šå¸¸æ¯”å‘½ä»¤å¼è¦é«˜ï¼Œä»£ç è¿˜çŸ­ã€‚
- ä¸€èˆ¬ä¸é¼“åŠ±ï¼ˆç”šè‡³å®Œå…¨ä¸ä½¿ç”¨ï¼‰å¯å˜é‡ã€‚ä¸Šé¢ä»£ç é‡Œåªæœ‰ `count` çš„å†…å®¹åœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­è¢«ä¿®æ”¹äº†ï¼Œè€Œä¸”è¿™ç§ä¿®æ”¹å®é™…æ˜¯ `transform` æ¥å£å¸¦æ¥çš„ã€‚å¦‚æœæ¥å£åƒ[\[ç¬¬ 13 è®²\]](https://time.geekbang.org/column/article/181608) å±•ç¤ºçš„ `fmap` å‡½æ•°ä¸€æ ·è¿”å›ä¸€ä¸ªå®¹å™¨çš„è¯ï¼Œå°±å¯ä»¥è¿è¿™ä¸ªé—®é¢˜éƒ½æ¶ˆé™¤äº†ã€‚ï¼ˆC++ æ¯•ç«Ÿä¸æ˜¯ä¸€é—¨å‡½æ•°å¼ç¼–ç¨‹è¯­è¨€ï¼Œå¯¹çµæ´»æ€§çš„è¿½æ±‚å‹å€’äº†å…¶ä»–è€ƒè™‘ã€‚ï¼‰

### é«˜é˜¶å‡½æ•°

æ—¢ç„¶å‡½æ•°ï¼ˆå¯¹è±¡ï¼‰å¯ä»¥è¢«ä¼ é€’ã€ä½¿ç”¨å’Œè¿”å›ï¼Œè‡ªç„¶å°±æœ‰å‡½æ•°ä¼šæ¥å—å‡½æ•°ä½œä¸ºå‚æ•°æˆ–è€…æŠŠå‡½æ•°ä½œä¸ºè¿”å›å€¼ï¼Œè¿™æ ·çš„å‡½æ•°å°±è¢«ç§°ä¸ºé«˜é˜¶å‡½æ•°ã€‚æˆ‘ä»¬ç°åœ¨å·²ç»è§è¿‡ä¸å°‘é«˜é˜¶å‡½æ•°äº†ï¼Œå¦‚ï¼š

- `sort`
- `transform`
- `accumulate`
- `fmap`
- `adder`

äº‹å®ä¸Šï¼ŒC++ é‡Œä»¥ algorithmï¼ˆç®—æ³•ï¼‰\[3] åä¹‰æä¾›çš„å¾ˆå¤šå‡½æ•°éƒ½æ˜¯é«˜é˜¶å‡½æ•°ã€‚

è®¸å¤šé«˜é˜¶å‡½æ•°åœ¨å‡½æ•°å¼ç¼–ç¨‹ä¸­å·²æˆä¸ºåŸºæœ¬çš„æƒ¯ç”¨æ³•ï¼Œåœ¨ä¸åŒè¯­è¨€ä¸­éƒ½ä¼šå‡ºç°ï¼Œè™½ç„¶å¯èƒ½æ˜¯ä»¥ä¸åŒçš„åå­—ã€‚æˆ‘ä»¬åœ¨æ­¤ä»‹ç»éå¸¸å¸¸è§çš„ä¸‰ä¸ªï¼Œmapï¼ˆæ˜ å°„ï¼‰ã€reduceï¼ˆå½’å¹¶ï¼‰å’Œ filterï¼ˆè¿‡æ»¤ï¼‰ã€‚

Map åœ¨ C++ ä¸­çš„ç›´æ¥æ˜ å°„æ˜¯ `transform`ï¼ˆåœ¨ &lt;algorithm&gt; å¤´æ–‡ä»¶ä¸­æä¾›ï¼‰ã€‚å®ƒæ‰€åšçš„äº‹æƒ…ä¹Ÿæ˜¯æ•°å­¦ä¸Šçš„æ˜ å°„ï¼ŒæŠŠä¸€ä¸ªèŒƒå›´é‡Œçš„å¯¹è±¡è½¬æ¢æˆç›¸åŒæ•°é‡çš„å¦å¤–ä¸€äº›å¯¹è±¡ã€‚è¿™ä¸ªå‡½æ•°çš„åŸºæœ¬å®ç°éå¸¸ç®€å•ï¼Œä½†è¿™æ˜¯ä¸€ç§å¼ºå¤§çš„æŠ½è±¡ï¼Œåœ¨å¾ˆå¤šåœºåˆéƒ½ç”¨å¾—ä¸Šã€‚

Reduce åœ¨ C++ ä¸­çš„ç›´æ¥æ˜ å°„æ˜¯ `accumulate`ï¼ˆåœ¨ &lt;numeric&gt; å¤´æ–‡ä»¶ä¸­æä¾›ï¼‰ã€‚å®ƒçš„åŠŸèƒ½æ˜¯åœ¨æŒ‡å®šçš„èŒƒå›´é‡Œï¼Œä½¿ç”¨ç»™å®šçš„åˆå€¼å’Œå‡½æ•°å¯¹è±¡ï¼Œä»å·¦åˆ°å³å¯¹æ•°å€¼è¿›è¡Œå½’å¹¶ã€‚åœ¨ä¸æä¾›å‡½æ•°å¯¹è±¡ä½œä¸ºç¬¬å››ä¸ªå‚æ•°æ—¶ï¼ŒåŠŸèƒ½ä¸Šç›¸å½“äºé»˜è®¤æä¾›äº†åŠ æ³•å‡½æ•°å¯¹è±¡ï¼Œè¿™æ—¶ç›¸å½“äºåšç´¯åŠ ï¼›æä¾›äº†å…¶ä»–å‡½æ•°å¯¹è±¡æ—¶ï¼Œé‚£å½“ç„¶å°±æ˜¯ä½¿ç”¨è¯¥å‡½æ•°å¯¹è±¡è¿›è¡Œå½’å¹¶äº†ã€‚

Filter çš„åŠŸèƒ½æ˜¯è¿›è¡Œè¿‡æ»¤ï¼Œç­›é€‰å‡ºç¬¦åˆæ¡ä»¶çš„æˆå‘˜ã€‚å®ƒåœ¨å½“å‰ C++ï¼ˆC++20 ä¹‹å‰ï¼‰é‡Œçš„æ˜ å°„å¯ä»¥è®¤ä¸ºæœ‰ä¸¤ä¸ªï¼š`copy_if` å’Œ `partition`ã€‚è¿™æ˜¯å› ä¸ºåœ¨ C++20 å¸¦æ¥ ranges ä¹‹å‰ï¼Œåœ¨ C++ é‡Œå®ç°æƒ°æ€§æ±‚å€¼ä¸å¤ªæ–¹ä¾¿ã€‚ä¸Šé¢è¯´çš„ä¸¤ä¸ªå‡½æ•°é‡Œï¼Œ`copy_if` æ˜¯æŠŠæ»¡è¶³æ¡ä»¶çš„å…ƒç´ æ‹·è´åˆ°å¦å¤–ä¸€ä¸ªè¿­ä»£å™¨é‡Œï¼›`partition` åˆ™æ˜¯æ ¹æ®è¿‡æ»¤æ¡ä»¶æ¥å¯¹èŒƒå›´é‡Œçš„å…ƒç´ è¿›è¡Œåˆ†ç»„ï¼ŒæŠŠæ»¡è¶³æ¡ä»¶çš„æ”¾åœ¨è¿”å›å€¼è¿­ä»£å™¨çš„å‰é¢ã€‚å¦å¤–ï¼Œ`remove_if` ä¹Ÿæœ‰ç‚¹ç›¸è¿‘ï¼Œé€šå¸¸ç”¨äºåˆ é™¤æ»¡è¶³æ¡ä»¶çš„å…ƒç´ ã€‚å®ƒç¡®ä¿æŠŠä¸æ»¡è¶³æ¡ä»¶çš„å…ƒç´ æ”¾åœ¨è¿”å›å€¼è¿­ä»£å™¨çš„å‰é¢ï¼ˆä½†ä¸ä¿è¯æ»¡è¶³æ¡ä»¶çš„å…ƒç´ åœ¨å‡½æ•°è¿”å›åä¸€å®šå­˜åœ¨ï¼‰ï¼Œç„¶åä½ ä¸€èˆ¬éœ€è¦ä½¿ç”¨å®¹å™¨çš„ `erase` æˆå‘˜å‡½æ•°æ¥å°†å¾…åˆ é™¤çš„å…ƒç´ çœŸæ­£åˆ é™¤ã€‚

### å‘½ä»¤å¼ç¼–ç¨‹å’Œè¯´æ˜å¼ç¼–ç¨‹

ä¼ ç»Ÿä¸Š C++ å±äºå‘½ä»¤å¼ç¼–ç¨‹ã€‚å‘½ä»¤å¼ç¼–ç¨‹é‡Œï¼Œä»£ç ä¼šæè¿°ç¨‹åºçš„å…·ä½“æ‰§è¡Œæ­¥éª¤ã€‚å¥½å¤„æ˜¯ä»£ç æ˜¾å¾—æ¯”è¾ƒç›´æˆªäº†å½“ï¼›ç¼ºç‚¹å°±æ˜¯å®¹æ˜“è®©äººåªè§æ ‘æœ¨ã€ä¸è§æ£®æ—ï¼Œåªèƒ½çœ‹åˆ°ä»£ç å•°å—¦åœ°æ€ä¹ˆåšï¼ˆhowï¼‰ï¼Œè€Œä¸æ˜¯åšä»€ä¹ˆï¼ˆwhatï¼‰ï¼Œæ›´ä¸ç”¨è¯´ä¸ºä»€ä¹ˆï¼ˆwhyï¼‰äº†ã€‚

è¯´æ˜å¼ç¼–ç¨‹åˆ™ç›¸åã€‚ä»¥æ•°æ®åº“æŸ¥è¯¢è¯­è¨€ SQL ä¸ºä¾‹ï¼ŒSQL æè¿°çš„æ˜¯ç±»ä¼¼äºä¸‹é¢çš„æ“ä½œï¼šä½ æƒ³ä»ä»€ä¹ˆåœ°æ–¹ï¼ˆfromï¼‰é€‰æ‹©ï¼ˆselectï¼‰æ»¡è¶³ä»€ä¹ˆæ¡ä»¶ï¼ˆwhereï¼‰çš„ä»€ä¹ˆæ•°æ®ï¼Œå¹¶å¯é€‰æŒ‡å®šæ’åºï¼ˆorder byï¼‰æˆ–åˆ†ç»„ï¼ˆgroup byï¼‰æ¡ä»¶ã€‚ä½ ä¸éœ€è¦å‘Šè¯‰æ•°æ®åº“å¼•æ“å…·ä½“è¯¥å¦‚ä½•å»æ‰§è¡Œè¿™ä¸ªæ“ä½œã€‚äº‹å®ä¸Šï¼Œåœ¨é€‰æ‹©æŸ¥è¯¢ç­–ç•¥ä¸Šï¼Œå¤§éƒ¨åˆ†æ•°æ®åº“ç”¨æˆ·éƒ½ä¸åŠæ•°æ®åº“å¼•æ“â€œèªæ˜â€ï¼›æ­£å¦‚å¤§éƒ¨åˆ†å¼€å‘è€…åœ¨å†™å‡ºä¼˜åŒ–æ±‡ç¼–ä»£ç ä¸Šä¹Ÿä¸åŠç¼–è¯‘å™¨èªæ˜ä¸€æ ·ã€‚

è¿™å¹¶ä¸æ˜¯è¯´è¯´æ˜å¼ç¼–ç¨‹ä¸€å®šå°±ä¼˜äºå‘½ä»¤å¼ç¼–ç¨‹ã€‚äº‹å®ä¸Šï¼Œå¯¹äºå¾ˆå¤šç®—æ³•ï¼Œå‘½ä»¤å¼æ‰æ˜¯æœ€è‡ªç„¶çš„å®ç°ã€‚ä»¥å¿«é€Ÿæ’åºä¸ºä¾‹ï¼Œå¾ˆå¤šåœ°æ–¹åœ¨è®²åˆ°å‡½æ•°å¼ç¼–ç¨‹æ—¶ä¼šç»™å‡ºä¸‹é¢è¿™ä¸ª Haskellï¼ˆä¸€ç§çº¯å‡½æ•°å¼çš„ç¼–ç¨‹è¯­è¨€ï¼‰çš„ä¾‹å­æ¥è¯´æ˜å‡½æ•°å¼ç¼–ç¨‹çš„ç®€æ´æ€§ï¼š

```haskell
quicksort []     = []
quicksort (p:xs) = (quicksort left)
         ++ [p] ++ (quicksort right)
  where
    left  = filter (< p) xs
    right = filter (>= p) xs
```

è¿™æ®µä»£ç ç®€æ´æ€§ç¡®å®æ²¡è¯è¯´ï¼Œä½†é—®é¢˜æ˜¯ï¼Œä¸Šé¢çš„ä»£ç çš„æ€§èƒ½å…¶å®éå¸¸ç³Ÿç³•ã€‚çœŸæ­£æ¥è¿‘ C++ æ€§èƒ½çš„å¿«é€Ÿæ’åºï¼Œåœ¨ Haskell é‡Œå†™å‡ºæ¥ä¸€ç‚¹ä¸ä¼˜é›…ï¼Œåè€Œæ›´ä¸‘é™‹ \[4]ã€‚

æ‰€ä»¥ï¼Œæˆ‘ä¸ªäººè®¤ä¸ºï¼Œè¯´æ˜å¼ç¼–ç¨‹è·Ÿå‘½ä»¤å¼ç¼–ç¨‹å¯ä»¥ç»“åˆèµ·æ¥äº§ç”Ÿæ—¢ä¼˜é›…åˆé«˜æ•ˆçš„ä»£ç ã€‚å¯¹äºä»å‘½ä»¤å¼ç¼–ç¨‹æˆé•¿èµ·æ¥çš„å¤§éƒ¨åˆ†ç¨‹åºå‘˜ï¼Œæˆ‘çš„å»ºè®®æ˜¯ï¼š

- å†™è¡¨æ„çš„ä»£ç ï¼Œä¸è¦è¿‡äºä¸“æ³¨æ€§èƒ½è€Œè®©ä»£ç éš¾ä»¥ç»´æŠ¤â€”â€”è®°ä½é«˜å¾·çº³çš„åè¨€ï¼šâ€œè¿‡æ—©ä¼˜åŒ–æ˜¯ä¸‡æ¶ä¹‹æºã€‚â€
- ä½¿ç”¨æœ‰æ„ä¹‰çš„å˜é‡ï¼Œä½†å°½é‡ä¸è¦å»ä¿®æ”¹å˜é‡å†…å®¹â€”â€”å˜é‡çš„ä¿®æ”¹éå¸¸å®¹æ˜“å¯¼è‡´ç¨‹åºå‘˜çš„æ€ç»´é”™è¯¯ã€‚
- ç±»ä¼¼åœ°ï¼Œå°½é‡ä½¿ç”¨æ²¡æœ‰å‰¯ä½œç”¨çš„å‡½æ•°ï¼Œå¹¶è®©ä½ å†™çš„ä»£ç ä¹Ÿå°½é‡æ²¡æœ‰å‰¯ä½œç”¨ï¼Œç”¨è¿”å›å€¼æ¥ä»£è¡¨çŠ¶æ€çš„å˜åŒ–â€”â€”æ²¡æœ‰å‰¯ä½œç”¨çš„ä»£ç æ›´å®¹æ˜“æ¨ç†ï¼Œæ›´ä¸å®¹æ˜“å‡ºé”™ã€‚
- ä»£ç çš„éšå¼ä¾èµ–è¶Šå°‘è¶Šå¥½ï¼Œå°¤å…¶æ˜¯ä¸è¦ä½¿ç”¨å…¨å±€å˜é‡â€”â€”éšå¼ä¾èµ–ä¼šè®©ä»£ç é‡Œçš„é”™è¯¯éš¾ä»¥æ’æŸ¥ï¼Œä¹Ÿä¼šè®©ä»£ç æ›´éš¾ä»¥æµ‹è¯•ã€‚
- ä½¿ç”¨çŸ¥åçš„é«˜çº§ç¼–ç¨‹ç»“æ„ï¼Œå¦‚åŸºäºèŒƒå›´çš„ for å¾ªç¯ã€æ˜ å°„ã€å½’å¹¶ã€è¿‡æ»¤â€”â€”è¿™å¯ä»¥è®©ä½ çš„ä»£ç æ›´ç®€æ´ï¼Œæ›´æ˜“äºæ¨ç†ï¼Œå¹¶å‡å°‘ç±»ä¼¼ä¸‹æ ‡è¶Šç•Œè¿™ç§ä½çº§é”™è¯¯çš„å¯èƒ½æ€§ã€‚

è¿™äº›è·Ÿå‡½æ•°å¼ç¼–ç¨‹æœ‰ä»€ä¹ˆå…³ç³»å‘¢ï¼Ÿâ€”â€”è¿™äº›å·®ä¸å¤šéƒ½æ˜¯æ¥è‡ªå‡½æ•°å¼ç¼–ç¨‹çš„æœ€ä½³å®è·µã€‚å­¦ä¹ å‡½æ•°å¼ç¼–ç¨‹ï¼Œä¹Ÿæ˜¯ä¸ºäº†æ›´å¥½åœ°ä½“ä¼šå¦‚ä½•ä»è¿™äº›åœ°æ–¹å…¥æ‰‹ï¼Œå†™å‡ºæ˜“è¯»è€Œåˆé«˜æ€§èƒ½çš„ä»£ç ã€‚

### ä¸å¯å˜æ€§å’Œå¹¶å‘

åœ¨å¤šæ ¸çš„æ—¶ä»£é‡Œï¼Œå‡½æ•°å¼ç¼–ç¨‹æ¯”ä»¥å‰æ›´å—é’çï¼Œä¸€ä¸ªé‡è¦çš„åŸå› æ˜¯å‡½æ•°å¼ç¼–ç¨‹å¯¹å¹¶è¡Œå¹¶å‘å¤©ç„¶å‹å¥½ã€‚å½±å“å¤šæ ¸æ€§èƒ½çš„ä¸€ä¸ªé‡è¦å› ç´ æ˜¯æ•°æ®çš„ç«äº‰æ¡ä»¶â€”â€”ç”±äºå…±äº«å†…å­˜æ•°æ®éœ€è¦åŠ é”å¸¦æ¥çš„å»¶è¿Ÿã€‚å‡½æ•°å¼ç¼–ç¨‹å¼ºè°ƒä¸å¯å˜æ€§ï¼ˆimmutabilityï¼‰ã€æ— å‰¯ä½œç”¨ï¼Œå¤©ç„¶å°±é€‚åˆå¹¶å‘ã€‚æ›´å¦™çš„æ˜¯ï¼Œå¦‚æœä½ ä½¿ç”¨é«˜å±‚æŠ½è±¡çš„è¯ï¼Œæœ‰æ—¶å¯ä»¥è½»è½»æ¾æ¾â€œå…è´¹â€å¾—åˆ°æ€§èƒ½æå‡ã€‚

æ‹¿æˆ‘ä»¬è¿™ä¸€è®²å¼€å¤´çš„ä¾‹å­æ¥è¯´ï¼Œå¯¹ä»£ç åšä¸‹é¢çš„æ”¹é€ ï¼Œå¯ç”¨ C++17 çš„å¹¶è¡Œæ‰§è¡Œç­–ç•¥ \[5]ï¼Œå°±èƒ½è‡ªåŠ¨è·å¾—åœ¨å¤šæ ¸ç¯å¢ƒä¸‹çš„æ€§èƒ½æå‡ï¼š

```c++
int count_lines(const char** begin,
                const char** end)
{
  vector<int> count(end - begin);
  transform(execution::par,
            begin, end,
            count.begin(),
            count_file);
  return reduce(
    execution::par,
    count.begin(), count.end());
}
```

æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œä¸¤ä¸ªé«˜é˜¶å‡½æ•°çš„è°ƒç”¨ä¸­éƒ½åŠ å…¥äº† `execution::par`ï¼Œæ¥å¯åŠ¨è‡ªåŠ¨å¹¶è¡Œè®¡ç®—ã€‚è¦æ³¨æ„çš„æ˜¯ï¼Œæˆ‘æŠŠ `accumulate` æ¢æˆäº† `reduce` \[6]ï¼ŒåŸå› æ˜¯å‰è€…å·²ç»å®šä¹‰æˆä»å·¦åˆ°å³çš„å½’å¹¶ï¼Œæ— æ³•å¹¶è¡Œã€‚`reduce` åˆ™ä¸åŒï¼Œåˆå§‹å€¼å¯ä»¥çœç•¥ï¼Œæ“ä½œä¸Šæ²¡æœ‰è§„å®šé¡ºåºï¼Œå¹¶åè¿‡æ¥è¦æ±‚å¯¹å…ƒç´ çš„å½’å¹¶æ“ä½œæ»¡è¶³äº¤æ¢å¾‹å’Œç»“åˆç‡ï¼ˆåŠ æ³•å½“ç„¶æ˜¯æ»¡è¶³çš„ï¼‰ï¼Œå³ï¼š

$$  
\\begin{aligned}  
A\\ \\otimes\\ B &amp;= B\\ \\otimes\\ A\\\\\\  
(A\\ \\otimes\\ B)\\ \\otimes\\ C &amp;= A\\ \\otimes\\ (B\\ \\otimes\\ C)  
\\end{aligned}  
$$

å½“ç„¶ï¼Œåœ¨è¿™ä¸ªä¾‹å­é‡Œï¼Œä¸€èˆ¬æˆ‘ä»¬ä¸ä¼šæœ‰æµ·é‡æ–‡ä»¶ï¼Œå³ä½¿æœ‰æµ·é‡æ–‡ä»¶ï¼Œå¹¶è¡Œè¯»å–æ€§èƒ½ä¸€èˆ¬ä¹Ÿä¸ä¼šå¿«äºé¡ºåºè¯»å–ï¼Œæ‰€ä»¥æ„ä¹‰å¹¶ä¸æ˜¯å¾ˆå¤§ã€‚ä¸‹é¢è¿™ä¸ªç®€å•çš„ä¾‹å­å±•ç¤ºäº†å¹¶è¡Œ `reduce` çš„å¨åŠ›ï¼š

```c++
#include <chrono>
#include <execution>
#include <iostream>
#include <numeric>
#include <vector>

using namespace std;

int main()
{
  vector<double> v(10000000, 0.0625);

  {
    auto t1 = chrono::
      high_resolution_clock::now();
    double result = accumulate(
      v.begin(), v.end(), 0.0);
    auto t2 = chrono::
      high_resolution_clock::now();
    chrono::duration<double, milli>
      ms = t2 - t1;
    cout << "accumulate: result "
         << result << " took "
         << ms.count() << " ms\n";
  }

  {
    auto t1 = chrono::
      high_resolution_clock::now();
    double result =
      reduce(execution::par,
             v.begin(), v.end());
    auto t2 = chrono::
      high_resolution_clock::now();
    chrono::duration<double, milli>
      ms = t2 - t1;
    cout << "reduce:     result "
         << result << " took "
         << ms.count() << " ms\n";
  }
}
```

åœ¨æˆ‘çš„ç”µè„‘ï¼ˆCore i7 å››æ ¸å…«çº¿ç¨‹ï¼‰ä¸Šçš„æŸæ¬¡æ‰§è¡Œç»“æœæ˜¯ï¼š

> `accumulate: result 625000 took 26.122 ms`  
> `reduce: result 625000 took 4.485 ms`

æ‰§è¡Œç­–ç•¥è¿˜æ¯”è¾ƒæ–°ï¼Œè¿˜æ²¡æœ‰è¢«æ‰€æœ‰ç¼–è¯‘å™¨æ”¯æŒã€‚æˆ‘ç›®å‰æµ‹è¯•ä¸‹æ¥ï¼ŒMSVC æ²¡æœ‰é—®é¢˜ï¼ŒClang ä¸è¡Œï¼ŒGCC éœ€è¦å¤–éƒ¨åº“ TBBï¼ˆThreading Building Blocksï¼‰\[7] çš„å¸®åŠ©ã€‚æˆ‘ä¸Šé¢æ˜¯ç”¨ GCC ç¼–è¯‘çš„ï¼Œå‘½ä»¤è¡Œæ˜¯ï¼š

> `g++-9 -std=c++17 -O3 test.cpp -ltbb`

## Y ç»„åˆå­

é™äºç¯‡å¹…ï¼Œè¿™ä¸€è®²æˆ‘ä»¬åªæ˜¯å¾ˆåˆæµ…åœ°æ¢è®¨äº†å‡½æ•°å¼ç¼–ç¨‹ã€‚å¯¹äº C++ çš„å‡½æ•°å¼ç¼–ç¨‹çš„æ·±å…¥æ¢è®¨æ˜¯æœ‰æ•´æœ¬ä¹¦çš„ï¼ˆè§å‚è€ƒèµ„æ–™ \[8]ï¼‰ï¼Œè€Œä»Šå¤©è®²çš„å†…å®¹åœ¨ä¹¦çš„æœ€å‰é¢å‡ ç« å°±è¦†ç›–å®Œäº†ã€‚åœ¨åé¢ï¼Œæˆ‘ä»¬è¿˜ä¼šæ¢è®¨éƒ¨åˆ†çš„å‡½æ•°å¼ç¼–ç¨‹è¯é¢˜ï¼›ä»Šå¤©æˆ‘ä»¬åªå†è®¨è®ºä¸€ä¸ªæœ‰ç‚¹æœ‰è¶£ã€ä¹Ÿæœ‰ç‚¹çƒ§è„‘çš„è¯é¢˜ï¼ŒY ç»„åˆå­ \[9]ã€‚ç¬¬ä¸€æ¬¡é˜…è¯»çš„æ—¶å€™ï¼Œå¦‚æœè§‰å¾—å›°éš¾ï¼Œå¯ä»¥è·³è¿‡è¿™ä¸€éƒ¨åˆ†ã€‚

ä¸è¿‡ï¼Œæˆ‘å¹¶ä¸æ‰“ç®—è®¨è®º Haskell Curry ä½¿ç”¨çš„ Y ç»„åˆå­å®šä¹‰â€”â€”è¿™ä¸ªæ¯”è¾ƒå¤æ‚ï¼Œéœ€è¦å†™ä¸€ç¯‡å®Œæ•´çš„æ–‡ç« æ¥è®¨è®ºï¼ˆ\[10]ï¼‰ï¼Œè€Œä¸”åœ¨ C++ ä¸­çš„å®ç”¨æ€§éå¸¸å¼±ã€‚æˆ‘ä»¬åªçœ‹å®ƒè§£å†³çš„é—®é¢˜ï¼šå¦‚ä½•åœ¨ lambda è¡¨è¾¾å¼ä¸­è¡¨ç°é€’å½’ã€‚

å›æƒ³ä¸€ä¸‹æˆ‘ä»¬ç”¨è¿‡çš„é˜¶ä¹˜çš„é€’å½’å®šä¹‰ï¼š

```c++
int factorial(int n)
{
  if (n == 0) {
    return 1;
  } else {
    return n * factorial(n - 1);
  }
}
```

æ³¨æ„é‡Œé¢ç”¨åˆ°äº†é€’å½’ï¼Œæ‰€ä»¥ä½ è¦æŠŠå®ƒå†™æˆ lambda è¡¨è¾¾å¼æ˜¯æœ‰ç‚¹å›°éš¾çš„ï¼š

```c++
auto factorial = [](int n) {
  if (n == 0) {
    return 1;
  } else {
    return n * ???(n - 1);
  }
}
```

ä¸‹é¢æˆ‘ä»¬è®¨è®ºä½¿ç”¨ Y ç»„åˆå­çš„è§£å†³æ–¹æ¡ˆã€‚

æˆ‘ä»¬é¦–å…ˆéœ€è¦ä¸€ä¸ªç‰¹æ®Šçš„é«˜é˜¶å‡½æ•°ï¼Œå®šä¹‰ä¸ºï¼š

$$  
y(f) = f(y(f))  
$$

æ˜¾ç„¶ï¼Œè¿™ä¸ªå®šä¹‰æœ‰ç‚¹å¥‡æ€ªã€‚äº‹å®ä¸Šï¼Œå®ƒæ˜¯ä¼šå¯¼è‡´æ— é™å±•å¼€çš„â€”â€”è€Œå®ƒçš„å¨åŠ›ä¹Ÿåœ¨äºæ— é™å±•å¼€ã€‚æˆ‘ä»¬ä¹Ÿå› æ­¤å¿…é¡»ä½¿ç”¨æƒ°æ€§æ±‚å€¼çš„æ–¹å¼æ‰èƒ½ä½¿ç”¨è¿™ä¸ªå®šä¹‰ã€‚

ç„¶åï¼Œæˆ‘ä»¬å®šä¹‰é˜¶ä¹˜ä¸ºï¼š

$$  
\\mathrm{fact}(n) = \\mathrm{If\\ IsZero}(n)\\ \\mathrm{then}\\ 1\\ \\mathrm{else}\\ n \\times \\mathrm{fact}(n âˆ’ 1)  
$$

å‡è®¾ $\\mathrm{fact}$ å¯ä»¥è¡¨ç¤ºæˆ $y(F)$ï¼Œé‚£æˆ‘ä»¬å¯ä»¥åšä¸‹é¢çš„å˜å½¢ï¼š

$$  
\\begin{aligned}  
y(F)(n) &amp;= \\mathrm{If\\ IsZero}(n)\\ \\mathrm{then}\\ 1\\ \\mathrm{else}\\ n \\times y(F)(n âˆ’ 1)\\\\\\  
F(y(F))(n) &amp;= \\mathrm{If\\ IsZero}(n)\\ \\mathrm{then}\\ 1\\ \\mathrm{else}\\ n \\times y(F)(n âˆ’ 1)  
\\end{aligned}  
$$

å†æŠŠ $y(F)$ æ›¿æ¢æˆ $f$ï¼Œæˆ‘ä»¬ä»ä¸Šé¢çš„ç¬¬äºŒä¸ªå¼å­å¾—åˆ°ï¼š

$$  
F(f)(n) = \\mathrm{If\\ IsZero}(n)\\ \\mathrm{then}\\ 1\\ \\mathrm{else}\\ n \\times f(n âˆ’ 1)  
$$

æˆ‘ä»¬å¾—åˆ°äº† $F$ çš„å®šä¹‰ï¼Œä¹Ÿå°±è‡ªç„¶å¾—åˆ°äº† $\\mathrm{fact}$ çš„å®šä¹‰ã€‚è€Œä¸”ï¼Œè¿™ä¸ªå®šä¹‰æ˜¯å¯ä»¥ç”¨ C++ è¡¨è¾¾å‡ºæ¥çš„ã€‚ä¸‹é¢æ˜¯å®Œæ•´çš„ä»£ç å®ç°ï¼š

```c++
#include <functional>
#include <iostream>
#include <type_traits>
#include <utility>

using namespace std;

// Y combinator as presented by Yegor Derevenets in P0200R0
// <url:http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0200r0.html>
template <class Fun>
class y_combinator_result {
  Fun fun_;
public:
  template <class T>
  explicit y_combinator_result(
    T&& fun)
    : fun_(std::forward<T>(fun))
  {
  }

  template <class... Args>
  decltype(auto)
  operator()(Args&&... args)
  {
    // y(f) = f(y(f))
    return fun_(
      std::ref(*this),
      std::forward<Args>(args)...);
  }
};

template <class Fun>
decltype(auto)
y_combinator(Fun&& fun)
{
  return y_combinator_result<
    std::decay_t<Fun>>(
    std::forward<Fun>(fun));
}

int main()
{
  // ä¸Šé¢çš„é‚£ä¸ª F
  auto almost_fact =
    [](auto f, int n) -> int {
    if (n == 0)
      return 1;
    else
      return n * f(n - 1);
  };
  // fact = y(F)
  auto fact =
    y_combinator(almost_fact);
  cout << fact(10) << endl;
}
```

è¿™ä¸€èŠ‚ä¸å½±å“åé¢çš„å†…å®¹ï¼Œçœ‹ä¸æ‡‚çš„å¯ä»¥æš‚æ—¶ç•¥è¿‡ã€‚ğŸ˜

## å†…å®¹å°ç»“

æœ¬è®²æˆ‘ä»¬å¯¹å‡½æ•°å¼ç¼–ç¨‹è¿›è¡Œäº†ä¸€ä¸ªå…¥é—¨å¼çš„ä»‹ç»ï¼Œå¸Œæœ›ä½ å¯¹å‡½æ•°å¼ç¼–ç¨‹çš„ç‰¹ç‚¹ã€ä¼˜ç¼ºç‚¹æœ‰äº†ä¸€ä¸ªåˆæ­¥çš„äº†è§£ã€‚ç„¶åï¼Œæˆ‘å¿«é€Ÿè®¨è®ºäº†ä¸€ä¸ªä¼šçƒ§è„‘çš„è¯é¢˜ï¼ŒY ç»„åˆå­ï¼Œè®©ä½ å¯¹å‡½æ•°å¼ç¼–ç¨‹çš„å¨åŠ›å’Œéš¾åº¦ä¹Ÿæœ‰æ‰€äº†è§£ã€‚

## è¯¾åæ€è€ƒ

æƒ³ä¸€æƒ³ï¼Œä½ å¦‚ä½•å¯ä»¥å®ç°ä¸€ä¸ªæƒ°æ€§çš„è¿‡æ»¤å™¨ï¼Ÿä¸€ä¸ªæƒ°æ€§çš„è¿‡æ»¤å™¨åº”å½“è®©ä¸‹é¢çš„ä»£ç é€šè¿‡ç¼–è¯‘ï¼Œå¹¶ä¸”ä¸ä¼šå ç”¨è·Ÿæ•°æ®é›†å¤§å°ç›¸å…³çš„é¢å¤–ç©ºé—´ï¼š

```c++
#include <iostream>
#include <numeric>
#include <vector>

using namespace std;

// filter_view çš„å®šä¹‰

int main()
{
  vector v{1, 2, 3, 4, 5};
  auto&& fv = filter_view(
    v.begin(), v.end(), [](int x) {
      return x % 2 == 0;
    });
  cout << accumulate(fv.begin(),
                     fv.end(), 0)
       << endl;
}
```

ç»“æœè¾“å‡ºåº”è¯¥æ˜¯ `6`ã€‚

**æç¤ºï¼š**å‚è€ƒ `istream_line_reader` çš„å®ç°ã€‚

å‘Šè¯‰æˆ‘ä½ æ˜¯å¦æˆåŠŸäº†ï¼Œæˆ–è€…ä½ é‡åˆ°äº†ä»€ä¹ˆæ ·çš„ç‰¹åˆ«å›°éš¾ã€‚

## å‚è€ƒèµ„æ–™

\[1] cppreference.com, â€œstd::transformâ€. [https://en.cppreference.com/w/cpp/algorithm/transform](https://en.cppreference.com/w/cpp/algorithm/transform)

\[1a] cppreference.com, â€œstd::transformâ€. [https://zh.cppreference.com/w/cpp/algorithm/transform](https://zh.cppreference.com/w/cpp/algorithm/transform)

\[2] cppreference.com, â€œstd::accumulateâ€. [https://en.cppreference.com/w/cpp/algorithm/accumulate](https://en.cppreference.com/w/cpp/algorithm/accumulate)

\[2a] cppreference.com, â€œstd::accumulateâ€. [https://zh.cppreference.com/w/cpp/algorithm/accumulate](https://zh.cppreference.com/w/cpp/algorithm/accumulate)

\[3] cppreference.com, â€œStandard library header &lt;algorithm&gt;â€. [https://en.cppreference.com/w/cpp/header/algorithm](https://en.cppreference.com/w/cpp/header/algorithm)

\[3a] cppreference.com, â€œæ ‡å‡†åº“å¤´æ–‡ä»¶ &lt;algorithm&gt;â€. [https://zh.cppreference.com/w/cpp/header/algorithm](https://zh.cppreference.com/w/cpp/header/algorithm)

\[4] è¢è‹±æ°, â€œImmutability: The Dark Sideâ€. [https://www.jianshu.com/p/13cd4c650125](https://www.jianshu.com/p/13cd4c650125)

\[5] cppreference.com, â€œStandard library header &lt;execution&gt;â€. [https://en.cppreference.com/w/cpp/header/execution](https://en.cppreference.com/w/cpp/header/execution)

\[5a] cppreference.com, â€œæ ‡å‡†åº“å¤´æ–‡ä»¶ &lt;execution&gt;â€. [https://zh.cppreference.com/w/cpp/header/execution](https://zh.cppreference.com/w/cpp/header/execution)

\[6] cppreference.com, â€œstd::reduceâ€. [https://en.cppreference.com/w/cpp/algorithm/reduce](https://en.cppreference.com/w/cpp/algorithm/reduce)

\[6a] cppreference.com, â€œstd::reduceâ€. [https://zh.cppreference.com/w/cpp/algorithm/reduce](https://zh.cppreference.com/w/cpp/algorithm/reduce)

\[7] Intel, tbb. [https://github.com/intel/tbb](https://github.com/intel/tbb)

\[8] Ivan ÄŒukiÄ‡, *Functional Programming in C++*. Manning, 2019, [https://www.manning.com/books/functional-programming-in-c-plus-plus](https://www.manning.com/books/functional-programming-in-c-plus-plus)

\[9] Wikipedia, â€œFixed-point combinatorâ€. [https://en.wikipedia.org/wiki/Fixed-point\_combinator](https://en.wikipedia.org/wiki/Fixed-point_combinator)

\[10] å´å’ç‚œ, â€œ*Y* Combinator and C++â€. [https://yongweiwu.wordpress.com/2014/12/14/y-combinator-and-cplusplus/](https://yongweiwu.wordpress.com/2014/12/14/y-combinator-and-cplusplus/)
<div><strong>ç²¾é€‰ç•™è¨€ï¼ˆ15ï¼‰</strong></div><ul>
<li><span>é©°éª‹</span> ğŸ‘ï¼ˆ57ï¼‰ ğŸ’¬ï¼ˆ2ï¼‰<p>Y-Combinatorè¢«ä½ è¯´é«˜æ·±äº†ã€‚é€’å½’å°±æ˜¯è‡ªå·±è°ƒç”¨è‡ªå·±ã€‚lamdaè¡¨è¾¾å¼æƒ³é€’å½’ï¼Œå›°éš¾åœ¨äºä¸çŸ¥é“è‡ªå·±çš„å‡½æ•°åï¼Œæ€ä¹ˆåŠï¼Ÿè°ƒç”¨ä¸äº†è‡ªå·±ï¼Œéš¾é“è¿˜è°ƒç”¨ä¸äº†åˆ«äººã€‚æ‰€ä»¥lamdaè¡¨è¾¾å¼è°ƒç”¨äº†Y-Combinatorå»é—´æ¥è°ƒç”¨è‡ªå·±ï¼Œè€ŒY-Combinatoråªä¸è¿‡ï¼šä¸€ï¼Œè®°å½•lamdaè¡¨è¾¾å¼ï¼›äºŒï¼Œè½¬è°ƒlamdaè¡¨è¾¾å¼ã€‚è¿™å°±å¥½æ¯”æ™®äº¬å—åˆ¶äºè¿ä»»æ—¶é—´é™åˆ¶ï¼Œå¦‚æœæƒ³ç»§ç»­è¿ä»»ï¼Œåˆ™æ‰¾ä¸ªä»£è¨€äººY-Combinatorç»§ä»»ã€‚ä»£è¨€äººçš„å”¯ä¸€ä½œç”¨å°±æ˜¯åˆ°æœŸä¼ ä½æ™®äº¬ã€‚</p>2020-01-07</li><br/><li><span>ç½— ä¹¾ æ—</span> ğŸ‘ï¼ˆ5ï¼‰ ğŸ’¬ï¼ˆ4ï¼‰<p>å‚è€ƒ istream_line_reader å®ç°çš„ï¼Œæœ›è€å¸ˆæ–§æ­£

template&lt;typename _InIt, typename _Fun&gt;
class filter_view {
public:
	class iterator {  &#47;&#47;  å®ç°  InputIterator  
	public:

		using iterator_category = input_iterator_tag;
		using value_type = typename _InIt::value_type;
		using difference_type = typename _InIt::difference_type;
		using pointer = typename _InIt::pointer;
		using reference = value_type&amp;;

		iterator(_InIt  _First, _InIt _Last, _Fun f)
			:_First(_First), _Last(_Last), _fun(f) {
			++(*this);
		}

		reference operator*() const noexcept { return *_Cur; }
		
		pointer operator-&gt;() const noexcept { return &amp;(*_Cur); }

		iterator&amp; operator++() {
			while (_First != _Last &amp;&amp; !_fun(*_First)) {
				_First++;
			}
			_Cur = _First;
			if (_First != _Last) {
				_First++;
			}
			return *this;
		}

		iterator operator++(int) {
			iterator temp(*this);
			++(*this);
			return temp;
		}

		bool operator==(const iterator&amp; rhs)
			const noexcept
		{
			return _Cur == rhs._Cur;
		}
		bool operator!=(const iterator&amp; rhs)
			const noexcept
		{
			return !operator==(rhs);
		}
	private:
		_InIt _First;
		_InIt _Last;
		_InIt _Cur;
		_Fun _fun;

	};

	filter_view(_InIt _First, _InIt _Last, _Fun f)
		:_First(_First), _Last(_Last), _fun(f) {

	}

	iterator begin() const noexcept {
		return iterator(_First, _Last, _fun);
	}

	iterator end() const  noexcept {
		return iterator(_Last, _Last, _fun);
	}
private:
	_InIt _First;
	_InIt _Last;
	_Fun _fun;
};</p>2020-01-03</li><br/><li><span>Resolution</span> ğŸ‘ï¼ˆ2ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>  è°ƒä¸äº†è‡ªå·±, å°±è°ƒåˆ«äºº
auto factorial = [](int n)
    {
        auto F = [](auto f, int n) -&gt; int
        { if (n == 0) return 1; else return n * f(f,n - 1); };
        return F(F, n);
    };</p>2023-10-04</li><br/><li><span>Frank</span> ğŸ‘ï¼ˆ2ï¼‰ ğŸ’¬ï¼ˆ6ï¼‰<p>å´è€å¸ˆï¼Œä¸ºä»€ä¹ˆc++ä¸èƒ½åœ¨è¿”å›å€¼ä¼˜åŒ–ï¼Œæ”¯æŒæŠŠrvalueé€šè¿‡moveæ„é€ ç»™ä¸€ä¸ªlvalueå¼•ç”¨ã€‚æˆ‘æƒ³å®ç°æ¨¡æ¿ä¸­çš„åå˜ï¼Œå‡½æ•°è¿”å›local variableï¼Œåªèƒ½é€šè¿‡å£°æ˜è¿”å›å€¼ç±»å‹ä¸ºå¼•ç”¨å’ŒæŒ‡é’ˆæ‰èƒ½åå˜æ”¯æŒè¿”å›å€¼å¤šæ€ã€‚æŠŠä¸€ä¸ªç”Ÿå‘½å‘¨æœŸçŸ­çš„variableè‡ªåŠ¨moveç»™è¿”å›å€¼ä¸æ˜¯åº”è¯¥çš„å—ï¼Ÿè¿™ä¸ªåœºæ™¯åœ¨å·¥å‚åœºæ™¯ä¸‹åº”è¯¥å¾ˆå¸¸è§å§ã€‚
class Base{
}
class Derive : public Base {}

class Factory {
 Bae &amp; create(){
 return Base();
}
class SubFactory : public Factory{
 Base &amp; create (){
    return Derive();
}
}
è¿™é‡Œçš„è¿”å›å€¼ç±»å‹ä¹Ÿæœ‰å¯èƒ½æ˜¯æ³›å‹å‚æ•°ï¼Œç°åœ¨çœ‹æ¥åªèƒ½ç”¨æ™ºèƒ½æŒ‡é’ˆåŒ…ä¸€å±‚ï¼Œé€šè¿‡moveæ„é€ è¿”å›ï¼Œè¿™çœ‹èµ·æ¥ä¸å¤ªæ–¹ä¾¿ã€‚
}</p>2021-03-31</li><br/><li><span>æ³°ä¼¦å¢</span> ğŸ‘ï¼ˆ2ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>è¯·é—®è€å¸ˆï¼Œmapå’Œreduce.é‚£æ˜¯æœ€æ–°çš„è¯­å¥å—ï¼Ÿè¿˜æ˜¯æœ‰ç¬¬ä¸‰æ–¹åº“ï¼Ÿé‚£ä¸ªTBBï¼Ÿ</p>2020-01-03</li><br/><li><span>geek</span> ğŸ‘ï¼ˆ1ï¼‰ ğŸ’¬ï¼ˆ2ï¼‰<p>è¯¾åæ€è€ƒçš„ä¸€ç§å®ç°ï¼Œè¯·è€å¸ˆæŒ‡æ­£ä¸€ä¸‹å…¶ä¸­å­˜åœ¨çš„é—®é¢˜ã€‚
template &lt;typename T = std::vector&lt;int&gt;&gt;
    class filter_view {
    public:
        filter_view(){}
        filter_view(typename T::iterator begin, typename T::iterator end, std::function&lt;bool(int)&gt; func):begin_(begin),end_(end),func_(func){}

        class iterator {
        public:
            iterator(typename T::iterator end):end_(end){}
            iterator(typename T::iterator begin, std::function&lt;bool(int)&gt; func):begin_(begin), func_(func) {}

            int operator*() {
                if (!func_(*begin_)) return 0;
                return *begin_;
            }

            int operator-&gt;() {
                if (!func_(*begin_)) return 0;
                return *begin_;
            }

            iterator operator++(int n) {
                ++begin_;
                return *this;
            }

            iterator operator++() {
                iterator t = *this;
                operator++(0);
                return t;
            }

            bool operator==(const iterator&amp; o) const {
                return begin_ == o.begin_;
            }

            bool operator!=(const iterator&amp; o) const {
                return !(begin_ == o.end_);
            }
        private:
            typename T::iterator begin_;
            typename T::iterator end_;
            std::function&lt;bool(int)&gt; func_;
        };

        iterator begin() {
            if (!func_) {
                throw std::logic_error(&quot;func_ is null&quot;);
            }
            return iterator(begin_,func_);
        }

        iterator end() {
            if (!func_) {
                throw std::logic_error(&quot;func_ is null&quot;);
            }
            return iterator(end_);
        }

    private:
        typename T::iterator begin_;
        typename T::iterator end_;
        std::function&lt;bool(int)&gt; func_;
    };</p>2021-03-17</li><br/><li><span>æ·¡æ¼ è½å¯</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ2ï¼‰<p>ä½œä¸šï¼šè¯·è€å¸ˆæŒ‡æ­£ï¼
#include &lt;iostream&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;

using namespace std;

template &lt;typename Iter, typename F&gt;
class filter_view {
 public:
  class iterator {
   public:
    typedef ptrdiff_t difference_type;
    typedef typename Iter::value_type value_type;
    typedef const value_type* pointer;
    typedef const value_type&amp; reference;
    typedef input_iterator_tag iterator_category;

    template &lt;typename IterT, typename FT&gt;
    iterator(IterT&amp;&amp; itr, FT&amp;&amp; f)
        : itr_(std::forward&lt;IterT&gt;(itr)),
          fun_(std::forward&lt;FT&gt;(f)) {
      while (!fun_(*itr_)) {
        ++itr_;
      }
    }

    bool operator==(const iterator&amp; other) noexcept {
      return itr_ == other.itr_;
    }
    bool operator!=(const iterator&amp; other) noexcept {
      return !operator==(other);
    }
    pointer operator-&gt;() noexcept {
      return itr_;
    }
    reference operator*() noexcept {
      return *itr_;
    }
    iterator&amp; operator++() {
      ++itr_;
      while (!fun_(*itr_)) {
        ++itr_;
      }
      return *this;
    }
    iterator operator++(int) {
      iterator tmp(itr_, fun_);
      operator++();
      return tmp;
    }

   private:
    Iter itr_;
    F fun_;
  };
  filter_view(Iter&amp;&amp; begin, Iter&amp;&amp; end, F&amp;&amp; f)
      : begin_(std::forward&lt;Iter&gt;(begin)),
        end_(std::forward&lt;Iter&gt;(end)),
        fun_(std::forward&lt;F&gt;(f)) {}

  iterator begin() {
    return {begin_, fun_};

  }

  iterator end() {
    return {end_, fun_};

  }

 private:
  Iter begin_;
  Iter end_;
  F fun_;
};

int main()
{
  vector v{1, 2, 3, 4, 5};
  auto&amp;&amp; fv = filter_view(
    v.begin(), v.end(), [](int x) {
      return x % 2 == 0;
    });
  cout &lt;&lt; accumulate(fv.begin(),
                     fv.end(), 0)
       &lt;&lt; endl;
}</p>2024-09-16</li><br/><li><span>Geek_595be5</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>è¯·é—®æ¼”ç¤ºå¹¶è¡Œè¯»å–æ–‡ä»¶çš„ä»£ç ä¾‹å­ä¸­ï¼Œæœ€åæœ‰è¡¥å……è¯´â€œå¹¶è¡Œè¯»å–æ€§èƒ½ä¸€èˆ¬ä¹Ÿä¸ä¼šå¿«äºé¡ºåºè¯»å–â€ï¼Œä¸ºä»€ä¹ˆå¹¶è¡Œå’Œé¡ºåºè¯»å–æ€§èƒ½å·®ä¸å¤šå‘¢ï¼Ÿ</p>2023-08-23</li><br/><li><span>å¸¸æŒ¯å</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>å‡½æ•°å¼ç¼–ç¨‹åœ¨å¹¶å‘åœºåˆä¸‹çš„ç¡®æœ‰ä¼˜åŠ¿ï¼Œä½†æ˜¯æ™®é€šåº”ç”¨ï¼Œæ¯”å¦‚é€’å½’ï¼Œå®ç°èµ·æ¥æ¯”å‘½ä»¤å¼å¤æ‚é‚£ä¹ˆå¤šï¼Œå¯è¯»æ€§æ›´å·®ï¼Œæ„ä¹‰ä½•åœ¨ã€‚è€Œä¸”å‡½æ•°å¼ç¼–ç¨‹çš„ä»£ç ç®€æ´æ€§ä¸å¦‚ç›´æ¥å‘½ä»¤å¼+æ³¨é‡Š</p>2021-10-15</li><br/><li><span>chang</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>æˆ‘ä¹Ÿè´´ä¸‹æˆ‘çš„å®ç°ï¼Œå‚è€ƒäº†å‰é¢ä¸€äº›åŒå­¦çš„ï¼Œæœ›è€å¸ˆæŒ‡æ­£ä¸è¶³ä¹‹å¤„ï¼š

template&lt;typename It, typename Comp&gt;
class filter_view {
public:
    class iterator {
    public:
        &#47;&#47;æ”¯æŒå†…ç½®æŒ‡é’ˆ
        using value_type = typename std::iterator_traits&lt;It&gt;::value_type;
        using difference_type = typename std::iterator_traits&lt;It&gt;::difference_type;
        using pointer = value_type*;
        using reference = value_type&amp;;
        using iterator_category = std::input_iterator_tag;

        iterator(It it, It e, Comp cmp) : it_(it), e_(e), cmp_(cmp) {
            skipNoMatch();
        }

        iterator&amp; operator++() {
            ++it_;
            skipNoMatch();
            return *this;
        }

        auto operator*() {
            return *it_;
        }

        bool operator==(const iterator &amp;rhs) const {
            return it_ == rhs.it_;
        }

        bool operator!=(const iterator &amp;rhs) const {
            return !(*this == rhs);
        }

    private:
        void skipNoMatch() {
            while (it_ != e_ &amp;&amp; !cmp_(*it_)) {
                ++it_;
            }
        }

    private:
        It it_;
        It e_;
        Comp cmp_;
    };

    filter_view(It b, It e, Comp cmp) : b_(b), e_(e), cmp_(cmp) {}

    iterator begin() const {
        return iterator(b_, e_, cmp_);
    }

    iterator end() const {
        return iterator(e_, e_, cmp_);
    }

private:
    It b_;
    It e_;
    Comp cmp_;
};</p>2021-06-09</li><br/><li><span>Frank</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ2ï¼‰<p>å´è€å¸ˆï¼Œæˆ‘é‡å†™äº†map-reduceé€»è¾‘(lazy evaluation)ï¼Œä½†æ˜¯ç›®å‰çš„flattenåŠŸèƒ½è¾“å‡ºæœ‰ç‚¹æ··ä¹±ï¼Œæˆ‘æš‚æ—¶æ²¡æ’æŸ¥å‡ºç»“æœã€‚èƒ½å¸®æˆ‘çœ‹ä¸‹å—ï¼Ÿhttps:&#47;&#47;github.com&#47;franklucky001&#47;fp-map-reduce&#47;blob&#47;master&#47;main.cpp</p>2021-04-06</li><br/><li><span>Frank</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>å´è€å¸ˆï¼Œ æˆ‘æƒ³å®ç°ç±»ä¼¼rustçš„lazy evaluationç‰¹å¾çš„map reduce,ä»£ç https:&#47;&#47;github.com&#47;franklucky001&#47;template_programming&#47;blob&#47;master&#47;collection&#47;iterator.hpp
ä½†æ˜¯æ¨¡æ¿ä¸­ï¼Œä¸æ–¹ä¾¿å®ç°åå˜ï¼Œå£°æ˜æˆå¼•ç”¨å±€éƒ¨å˜é‡ä¼šææ„ï¼Œbeginå’Œendè™šå‡½æ•°å¿…é¡»å£°æ˜æˆæ™ºèƒ½æŒ‡é’ˆæ‰èƒ½é€šè¿‡moveæ„é€ è¿”å›å±€éƒ¨å˜é‡,æœ‰æ²¡æœ‰æ›´å¥½çš„æ–¹å¼ã€‚</p>2021-03-31</li><br/><li><span>Geek_845be1</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>ç”¨ std::function ä¿å­˜ lambdaï¼Œé€šè¿‡å¼•ç”¨æ•è·ï¼Œå¯ä»¥å¾ˆæ–¹ä¾¿çš„å®ç°äº†lambda é€’å½’ã€‚</p>2020-12-23</li><br/><li><span>zhengfan</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>å´è€å¸ˆï¼Œæ‚¨å¥½ã€‚
æ­¤è®²å†…å®¹å’Œä¹‹å‰å†…å®¹æ¯”è¾ƒï¼Œé¢‡æœ‰äº›é“ä¸æœ¯çš„åˆ†åˆ«ã€‚
ä¸ªäººæ„Ÿè§‰å‡½æ•°å¼ç¼–ç¨‹å’ŒADTèŒƒå¼å¼ºè°ƒçš„isolationæœ‰å‡ ä»½ç¥ä¼¼ã€‚
æ‚¨åœ¨æ–‡ä¸­çš„å‡ æ¡å»ºè®®ï¼Œæˆ‘æœ‰äº›å›°æƒ‘åœ°æ–¹ï¼Œå‘æ‚¨è¯·æ•™ï¼š
ç¬¬äºŒæ¡å»ºè®®ï¼šâ€ä½¿ç”¨æœ‰æ„ä¹‰çš„å˜é‡ï¼Œä½†å°½é‡ä¸è¦å»ä¿®æ”¹å˜é‡å†…å®¹â€”â€”å˜é‡çš„ä¿®æ”¹éå¸¸å®¹æ˜“å¯¼è‡´ç¨‹åºå‘˜çš„æ€ç»´é”™è¯¯â€œï¼›è¯·é—®æ‚¨æŒ‡çš„æ˜¯æŠ½è±¡å±‚é¢ä¸Šâ€ä¸è¦æ”¹å˜å˜é‡çš„å«ä¹‰&#47;æ„ä¹‰â€œï¼Ÿäº¦æˆ–æ˜¯å…·ä½“å±‚é¢ä¸Šâ€ä¸è¦æ”¹å˜ä¼ å…¥å‚æ•°ä»¥åŠç¯å¢ƒå˜é‡çš„å†…å®¹â€œï¼Ÿä»ä¸Šä¸‹æ–‡æ¥çœ‹ä¼¼ä¹æ˜¯åè€…ï¼Œä½†è¿™æ ·ä¸€æ¥å¥½åƒå’Œç¬¬ä¸‰æ¡å»ºè®®æœ‰äº›é‡å¤äº†ã€‚
è¯·æ‚¨æŒ‡æ•™ï¼Œå¤šè°¢ã€‚</p>2020-07-01</li><br/><li><span>æ˜“è½»å°˜</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>æ²¡æœ‰çœ‹istream_line_readerå‰ï¼Œä¸ªäººçš„å®ç°ï¼Œæœ‰ç‚¹ä¸‘é™‹ï¼š

template&lt;typename InputIt, typename Pred&gt;
auto filter_view(InputIt a, InputIt b, Pred pred) {
    struct {
        InputIt _begin, _end;
        function&lt;bool(decltype(*_begin))&gt; _pred;
        struct iterator {
            InputIt _it, _end;
            function&lt;bool(decltype(*_it))&gt; _pred;
            iterator(InputIt it, InputIt e, decltype(_pred) p):_it(it), _end(e), _pred(p){}
            bool operator != (const iterator&amp; other) {return _it != other._it;}
            bool operator == (const iterator&amp; other) {return _it == other._it;}

            auto operator*() {return *_it;}
            auto operator-&gt;() {return &amp;(*_it);}

            iterator&amp; operator ++ () {
                do {
                    if(_it == _end) break;
                    ++ _it;
                    if(_it == _end || _pred(*_it)) break;
                } while(true);
                return *this;
            }
        };
        
        iterator begin() {
            while(_begin != _end &amp;&amp; !_pred(*_begin))
                ++ _begin;
            return iterator(_begin, _end, _pred);
        }
        iterator end() {
            return iterator(_end, _end, _pred);
        }
    } object;
    object._begin = a;
    object._end = b;
    object._pred = [pred](decltype(*a) x){return pred(x);};
    return object;
}</p>2020-06-13</li><br/>
</ul>