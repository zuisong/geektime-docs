ä½ å¥½ï¼Œæˆ‘æ˜¯å´å’ç‚œã€‚

ä¸Šä¸€è®²æˆ‘ä»¬ç®€å•ä»‹ç»äº†æ¨¡æ¿çš„åŸºæœ¬ç”¨æ³•åŠå…¶åœ¨æ³›å‹ç¼–ç¨‹ä¸­çš„åº”ç”¨ã€‚è¿™ä¸€è®²æˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹æ¨¡æ¿çš„å¦å¤–ä¸€ç§é‡è¦ç”¨é€”â€”â€”ç¼–è¯‘æœŸè®¡ç®—ï¼Œä¹Ÿç§°ä½œâ€œæ¨¡æ¿å…ƒç¼–ç¨‹â€ã€‚

## ç¼–è¯‘æœŸè®¡ç®—

é¦–å…ˆï¼Œæˆ‘ä»¬ç»™å‡ºä¸€ä¸ªå·²ç»è¢«è¯æ˜çš„ç»“è®ºï¼šC++ æ¨¡æ¿æ˜¯å›¾çµå®Œå…¨çš„ \[1]ã€‚è¿™å¥è¯çš„æ„æ€æ˜¯ï¼Œä½¿ç”¨ C++ æ¨¡æ¿ï¼Œä½ å¯ä»¥åœ¨ç¼–è¯‘æœŸé—´æ¨¡æ‹Ÿä¸€ä¸ªå®Œæ•´çš„å›¾çµæœºï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå¯ä»¥å®Œæˆä»»ä½•çš„è®¡ç®—ä»»åŠ¡ã€‚

å½“ç„¶ï¼Œè¿™åªæ˜¯ç†è®ºä¸Šçš„ç»“è®ºã€‚ä»å®é™…çš„è§’åº¦ï¼Œæˆ‘ä»¬å¹¶ä¸**æƒ³**ã€ä¹Ÿä¸å¯èƒ½åœ¨ç¼–è¯‘æœŸå®Œæˆæ‰€æœ‰çš„è®¡ç®—ï¼Œæ›´ä¸ç”¨è¯´ç¼–è¯‘æœŸçš„ç¼–ç¨‹æ˜¯å¾ˆå®¹æ˜“è®©äººçœ‹ä¸æ‡‚çš„â€”â€”å› ä¸ºè¿™å¹¶ä¸æ˜¯è¯­è¨€è®¾è®¡çš„åˆè¡·ã€‚å³ä¾¿å¦‚æ­¤ï¼Œæˆ‘ä»¬ä¹Ÿè¿˜æ˜¯éœ€è¦äº†è§£ä¸€ä¸‹æ¨¡æ¿å…ƒç¼–ç¨‹çš„åŸºæœ¬æ¦‚å¿µï¼šå®ƒä»ç„¶æœ‰ä¸€äº›å®ç”¨çš„åœºæ™¯ï¼Œå¹¶ä¸”åœ¨å®é™…çš„å·¥ç¨‹ä¸­ä½ ä¹Ÿå¯èƒ½ä¼šé‡åˆ°è¿™æ ·çš„ä»£ç ã€‚è™½ç„¶æˆ‘ä»¬åœ¨å¼€ç¯‡å°±è¯´è¿‡ä¸è¦ç‚«æŠ€ï¼Œä½†ä½¿ç”¨æ¨¡æ¿å…ƒç¼–ç¨‹å†™å‡ºçš„ä»£ç ä»ç„¶æ˜¯å¯ç†è§£çš„ï¼Œå°¤å…¶æ˜¯å¦‚æœä½ å¯¹é€’å½’ä¸å‘æ€µçš„è¯ã€‚

å¥½ï¼Œé—²è¯å°‘å™ï¼Œæˆ‘ä»¬ä»ç„¶æ‹¿ä»£ç è¯´è¯ï¼š

```c++
template <int n>
struct factorial {
  static const int value =
    n * factorial<n - 1>::value;
};

template <>
struct factorial<0> {
  static const int value = 1;
};
```

ä¸Šé¢å®šä¹‰äº†ä¸€ä¸ªé€’å½’çš„é˜¶ä¹˜å‡½æ•°ã€‚å¯ä»¥çœ‹å‡ºï¼Œå®ƒå®Œå…¨ç¬¦åˆé˜¶ä¹˜çš„é€’å½’å®šä¹‰ï¼š

$$  
\\begin{aligned}  
0! &amp;= 1 \\\\\\  
n! &amp;= n \\times (n - 1)!  
\\end{aligned}  
$$

é™¤äº†é¡ºåºæœ‰ç‰¹å®šçš„è¦æ±‚â€”â€”å…ˆå®šä¹‰ï¼Œæ‰èƒ½ç‰¹åŒ–â€”â€”å†åŠ è¯­æ³•æœ‰ç‚¹ç‰¹åˆ«ï¼Œä»£ç åŸºæœ¬ä¸Šå°±æ˜¯è¿™ä¸ªæ•°å­¦å®šä¹‰çš„ç®€å•æ˜ å°„äº†ã€‚

é‚£æˆ‘ä»¬æ€ä¹ˆçŸ¥é“è¿™ä¸ªè®¡ç®—æ˜¯ä¸æ˜¯åœ¨ç¼–è¯‘æ—¶åšçš„å‘¢ï¼Ÿæˆ‘ä»¬å¯ä»¥ç›´æ¥çœ‹ç¼–è¯‘è¾“å‡ºã€‚ä¸‹é¢ç›´æ¥è´´å‡ºå¯¹ä¸Šé¢è¿™æ ·çš„ä»£ç åŠ è¾“å‡ºï¼ˆ`printf("%d\n", factorial<10>::value);`ï¼‰åœ¨ x86-64 ä¸‹çš„ç¼–è¯‘ç»“æœï¼š

```assembly
.LC0:
        .string "%d\n"
main:
        push    rbp
        mov     rbp, rsp
        mov     esi, 3628800
        mov     edi, OFFSET FLAT:.LC0
        mov     eax, 0
        call    printf
        mov     eax, 0
        pop     rbp
        ret
```

æˆ‘ä»¬å¯ä»¥æ˜ç¡®çœ‹åˆ°ï¼Œç¼–è¯‘ç»“æœé‡Œæ˜æ˜ç™½ç™½ç›´æ¥å‡ºç°äº†å¸¸é‡ 3628800ã€‚ä¸Šé¢é‚£äº›é€’å½’ä»€ä¹ˆçš„ï¼Œå®Œå…¨éƒ½æ²¡æœ‰äº†è¸ªå½±ã€‚

å¦‚æœæˆ‘ä»¬ä¼ é€’ä¸€ä¸ªè´Ÿæ•°ç»™ `factorial` å‘¢ï¼Ÿè¿™æ—¶çš„ç»“æœå°±åº”è¯¥æ˜¯ç¼–è¯‘æœŸé—´çš„é€’å½’æº¢å‡ºã€‚å¦‚ GCC ä¼šæŠ¥å‘Šï¼š

> fatal error: template instantiation depth exceeds maximum of 900 (use -ftemplate-depth= to increase the maximum)

å¦‚æœæŠŠ `int` æ”¹æˆ `unsigned`ï¼Œä¸åŒçš„ç¼–è¯‘å™¨å’Œä¸åŒçš„æ ‡å‡†é€‰é¡¹ä¼šå¯¼è‡´ä¸åŒçš„ç»“æœã€‚æœ‰äº›æƒ…å†µä¸‹é”™è¯¯ä¿¡æ¯å®Œå…¨ä¸å˜ï¼Œæœ‰äº›æƒ…å†µä¸‹åˆ™ä¼šæŠ¥è´Ÿæ•°ä¸èƒ½è½¬æ¢åˆ° `unsigned`ã€‚é€šç”¨çš„è§£å†³æ–¹æ¡ˆæ˜¯ä½¿ç”¨ `static_assert`ï¼Œç¡®ä¿å‚æ•°æ°¸è¿œä¸ä¼šæ˜¯è´Ÿæ•°ã€‚

```c++
template <int n>
struct factorial {
  static_assert(
    n >= 0,
    "Arg must be non-negative");
  static const int value =
    n * factorial<n - 1>::value;
};
```

è¿™æ ·ï¼Œå½“ `factorial` æ¥æ”¶åˆ°ä¸€ä¸ªè´Ÿæ•°ä½œä¸ºå‚æ•°æ—¶ï¼Œå°±ä¼šå¾—åˆ°ä¸€ä¸ªå¹²è„†çš„é”™è¯¯ä¿¡æ¯ï¼š

> error: static assertion failed: Arg must be non-negative

ä¸‹é¢æˆ‘ä»¬çœ‹ä¸€äº›æ›´å¤æ‚çš„ä¾‹å­ã€‚è¿™äº›ä¾‹å­ä¸æ˜¯ä¸ºäº†è®©ä½ çœŸçš„å»å†™è¿™æ ·çš„ä»£ç ï¼Œè€Œæ˜¯å¸®åŠ©ä½ å……åˆ†ç†è§£ç¼–è¯‘æœŸç¼–ç¨‹çš„å¼ºå¤§å¨åŠ›ã€‚å¦‚æœè¿™äº›ä¾‹å­ä½ éƒ½å®Œå…¨æŒæ¡äº†ï¼Œé‚£ä»¥åç¢°åˆ°å°çš„æ¨¡æ¿é—®é¢˜ï¼Œä½ ä¸€å®šå¯ä»¥è½»æ¾è§£å†³ï¼Œå®Œå…¨ä¸åœ¨è¯ä¸‹ã€‚

å›æƒ³ä¸Šé¢çš„ä¾‹å­ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œè¦è¿›è¡Œç¼–è¯‘æœŸç¼–ç¨‹ï¼Œæœ€ä¸»è¦çš„ä¸€ç‚¹ï¼Œæ˜¯éœ€è¦æŠŠè®¡ç®—è½¬å˜æˆç±»å‹æ¨å¯¼ã€‚æ¯”å¦‚ï¼Œä¸‹é¢çš„æ¨¡æ¿å¯ä»¥ä»£è¡¨æ¡ä»¶è¯­å¥ï¼š

```c++
template <bool cond,
          typename Then,
          typename Else>
struct If;

template <typename Then,
          typename Else>
struct If<true, Then, Else> {
  typedef Then type;
};

template <typename Then,
          typename Else>
struct If<false, Then, Else> {
  typedef Else type;
};
```

`If` æ¨¡æ¿æœ‰ä¸‰ä¸ªå‚æ•°ï¼Œç¬¬ä¸€ä¸ªæ˜¯å¸ƒå°”å€¼ï¼Œåé¢ä¸¤ä¸ªåˆ™æ˜¯ä»£è¡¨ä¸åŒåˆ†æ”¯è®¡ç®—çš„ç±»å‹ï¼Œè¿™ä¸ªç±»å‹å¯ä»¥æ˜¯æˆ‘ä»¬ä¸Šé¢å®šä¹‰çš„ä»»ä½•ä¸€ä¸ªæ¨¡æ¿å®ä¾‹ï¼ŒåŒ…æ‹¬ `If` å’Œ `factorial`ã€‚ç¬¬ä¸€ä¸ª struct å£°æ˜è§„å®šäº†æ¨¡æ¿çš„å½¢å¼ï¼Œç„¶åæˆ‘ä»¬ä¸æä¾›é€šç”¨å®šä¹‰ï¼Œè€Œæ˜¯æä¾›äº†ä¸¤ä¸ªç‰¹åŒ–ã€‚ç¬¬ä¸€ä¸ªç‰¹åŒ–æ˜¯çœŸçš„æƒ…å†µï¼Œå®šä¹‰ç»“æœ `type` ä¸º `Then` åˆ†æ”¯ï¼›ç¬¬äºŒä¸ªç‰¹åŒ–æ˜¯å‡çš„æƒ…å†µï¼Œå®šä¹‰ç»“æœ `type` ä¸º `Else` åˆ†æ”¯ã€‚

æˆ‘ä»¬ä¸€èˆ¬ä¹Ÿéœ€è¦å¾ªç¯ï¼š

```c++
template <bool condition,
          typename Body>
struct WhileLoop;

template <typename Body>
struct WhileLoop<true, Body> {
  typedef typename WhileLoop<
    Body::cond_value,
    typename Body::next_type>::type
    type;
};

template <typename Body>
struct WhileLoop<false, Body> {
  typedef
    typename Body::res_type type;
};

template <typename Body>
struct While {
  typedef typename WhileLoop<
    Body::cond_value, Body>::type
    type;
};
```

è¿™ä¸ªå¾ªç¯çš„æ¨¡æ¿å®šä¹‰ç¨å¤æ‚ç‚¹ã€‚é¦–å…ˆï¼Œæˆ‘ä»¬å¯¹å¾ªç¯ä½“ç±»å‹æœ‰ä¸€ä¸ªçº¦å®šï¼Œå®ƒå¿…é¡»æä¾›ä¸€ä¸ªé™æ€æ•°æ®æˆå‘˜ï¼Œ`cond_value`ï¼ŒåŠä¸¤ä¸ªå­ç±»å‹å®šä¹‰ï¼Œ`res_type` å’Œ `next_type`ï¼š

- `cond_value` ä»£è¡¨å¾ªç¯çš„æ¡ä»¶ï¼ˆçœŸæˆ–å‡ï¼‰
- `res_type` ä»£è¡¨é€€å‡ºå¾ªç¯æ—¶çš„çŠ¶æ€
- `next_type` ä»£è¡¨ä¸‹é¢å¾ªç¯æ‰§è¡Œä¸€æ¬¡æ—¶çš„çŠ¶æ€

è¿™é‡Œé¢æ¯”è¾ƒç»•çš„åœ°æ–¹æ˜¯ç”¨ç±»å‹æ¥ä»£è¡¨æ‰§è¡ŒçŠ¶æ€ã€‚å¦‚æœä¹‹å‰ä½ æ²¡æœ‰æ¥è§¦è¿‡å‡½æ•°å¼ç¼–ç¨‹çš„è¯ï¼Œè¿™ä¸ªåœ¨åˆå­¦æ—¶æœ‰å›°éš¾æ˜¯æ­£å¸¸çš„ã€‚æŠŠä¾‹å­å¤šçœ‹ä¸¤éï¼Œè‡ªå·±ç¼–è¯‘ã€ä¿®æ”¹ã€æŠŠç©ä¸€ä¸‹ï¼Œå°±ä¼šæ¸æ¸ç†è§£çš„ã€‚

æ’é™¤è¿™ä¸ªæŠ½è±¡æ€§ï¼Œæ¨¡æ¿çš„å®šä¹‰å’Œ `If` æ˜¯ç±»ä¼¼çš„ï¼Œè™½ç„¶æˆ‘ä»¬ä¸ºæ–¹ä¾¿ä½¿ç”¨ï¼Œå®šä¹‰äº†ä¸¤ä¸ªæ¨¡æ¿ã€‚`WhileLoop` æ¨¡æ¿æœ‰ä¸¤ä¸ªæ¨¡æ¿å‚æ•°ï¼ŒåŒæ ·ç”¨ç‰¹åŒ–æ¥å†³å®šèµ°é€’å½’åˆ†æ”¯è¿˜æ˜¯é€€å‡ºå¾ªç¯åˆ†æ”¯ã€‚`While` æ¨¡æ¿åˆ™åªéœ€è¦å¾ªç¯ä½“ä¸€ä¸ªå‚æ•°ï¼Œæ–¹ä¾¿ä½¿ç”¨ã€‚

å¦‚æœä½ ä¹‹å‰æ¨¡æ¿ç”¨å¾—ä¸å¤šçš„è¯ï¼Œè¿˜æœ‰ä¸€ä¸ªéœ€è¦äº†è§£çš„ç»†èŠ‚ï¼Œå°±æ˜¯ç”¨ `::` å–ä¸€ä¸ªæˆå‘˜ç±»å‹ã€å¹¶ä¸” `::` å·¦è¾¹æœ‰æ¨¡æ¿å‚æ•°çš„è¯ï¼Œå¾—é¢å¤–åŠ ä¸Š `typename` å…³é”®å­—æ¥æ ‡æ˜ç»“æœæ˜¯ä¸€ä¸ªç±»å‹ã€‚ä¸Šé¢å¾ªç¯æ¨¡æ¿çš„å®šä¹‰é‡Œå°±å‡ºç°äº†å¤šæ¬¡è¿™æ ·çš„è¯­æ³•ã€‚MSVC åœ¨è¿™æ–¹é¢å¾€å¾€æ¯”è¾ƒå®½æ¾ï¼Œä¸å†™ `typename` ä¹Ÿä¸ä¼šæŠ¥é”™ï¼Œä½†è¿™æ˜¯ä¸ç¬¦åˆ C++ æ ‡å‡†çš„ç”¨æ³•ã€‚

ä¸ºäº†è¿›è¡Œè®¡ç®—ï¼Œæˆ‘ä»¬è¿˜éœ€è¦é€šç”¨çš„ä»£è¡¨æ•°å€¼çš„ç±»å‹ã€‚ä¸‹é¢è¿™ä¸ªæ¨¡æ¿å¯ä»¥é€šç”¨åœ°ä»£è¡¨ä¸€ä¸ªæ•´æ•°å¸¸æ•°ï¼š

```c++
template <class T, T v>
struct integral_constant {
  static const T value = v;
  typedef T value_type;
  typedef integral_constant type;
};
```

`integral_constant` æ¨¡æ¿åŒæ—¶åŒ…å«äº†æ•´æ•°çš„ç±»å‹å’Œæ•°å€¼ï¼Œè€Œé€šè¿‡è¿™ä¸ªç±»å‹çš„ `value` æˆå‘˜æˆ‘ä»¬åˆå¯ä»¥é‡æ–°å–å›è¿™ä¸ªæ•°å€¼ã€‚æœ‰äº†è¿™ä¸ªæ¨¡æ¿çš„å¸®å¿™ï¼Œæˆ‘ä»¬å°±å¯ä»¥è¿›è¡Œä¸€äº›æ›´é€šç”¨çš„è®¡ç®—äº†ã€‚ä¸‹é¢è¿™ä¸ªæ¨¡æ¿å±•ç¤ºäº†å¦‚ä½•ä½¿ç”¨å¾ªç¯æ¨¡æ¿æ¥å®Œæˆä» 1 åŠ åˆ° n çš„è®¡ç®—ï¼š

```c++
template <int result, int n>
struct SumLoop {
  static const bool cond_value =
    n != 0;
  static const int res_value =
    result;
  typedef integral_constant<
    int, res_value>
    res_type;
  typedef SumLoop<result + n, n - 1>
    next_type;
};

template <int n>
struct Sum {
  typedef SumLoop<0, n> type;
};
```

ç„¶åä½ ä½¿ç”¨ `While<Sum<10>::type>::type::value` å°±å¯ä»¥å¾—åˆ° 1 åŠ åˆ° 10 çš„ç»“æœã€‚è™½ç„¶æœ‰ç‚¹ç»•ï¼Œä½†ä»£ç å®è´¨å°±æ˜¯åœ¨ç¼–è¯‘æœŸé—´è¿›è¡Œäº†ä»¥ä¸‹çš„è®¡ç®—ï¼š

```c++
int result = 0;
while (n != 0) {
  result = result + n;
  n = n - 1;
}
```

ä¼°è®¡ç°åœ¨ä½ çš„å¤´å·²ç»å¾ˆæ™•äº†ã€‚ä½†æˆ‘ä¿è¯ï¼Œè¿™ä¸€è®²æœ€éš¾çš„éƒ¨åˆ†å·²ç»è¿‡å»äº†ã€‚å®é™…ä¸Šï¼Œåˆ°ç°åœ¨ä¸ºæ­¢ï¼Œæˆ‘ä»¬è®²çš„ä¸œè¥¿è¿˜æ²¡æœ‰ç¦»å¼€ C++98ã€‚è€Œæˆ‘ä»¬ä¸‹é¢å‡ è®²é‡Œå¾ˆå¿«å°±ä¼šè®²åˆ°ï¼Œå¦‚ä½•åœ¨ç°ä»£ C++ é‡Œä¸ä½¿ç”¨è¿™ç§éº»çƒ¦çš„æ–¹å¼ä¹Ÿèƒ½è¾¾åˆ°åŒæ ·çš„æ•ˆæœã€‚

## ç¼–è¯‘æœŸç±»å‹æ¨å¯¼

C++ æ ‡å‡†åº“åœ¨ &lt;type\_traits&gt; å¤´æ–‡ä»¶é‡Œå®šä¹‰äº†å¾ˆå¤šå·¥å…·ç±»æ¨¡æ¿ï¼Œç”¨æ¥æå–æŸä¸ªç±»å‹ï¼ˆtypeï¼‰åœ¨æŸæ–¹é¢çš„ç‰¹ç‚¹ï¼ˆtraitï¼‰\[2]ã€‚å’Œä¸Šä¸€èŠ‚ç»™å‡ºçš„ä¾‹å­ç›¸ä¼¼ï¼Œè¿™äº›ç‰¹ç‚¹æ—¢æ˜¯ç±»å‹ï¼Œåˆæ˜¯å¸¸å€¼ã€‚

ä¸ºäº†æ–¹ä¾¿åœ°åœ¨å€¼å’Œç±»å‹ä¹‹é—´è½¬æ¢ï¼Œæ ‡å‡†åº“å®šä¹‰äº†ä¸€äº›ç»å¸¸éœ€è¦ç”¨åˆ°çš„å·¥å…·ç±»ã€‚ä¸Šé¢æè¿°çš„ `integral_constant` å°±æ˜¯å…¶ä¸­ä¸€ä¸ªï¼ˆæˆ‘çš„å®šä¹‰æœ‰æ‰€ç®€åŒ–ï¼‰ã€‚ä¸ºäº†æ–¹ä¾¿ä½¿ç”¨ï¼Œé’ˆå¯¹å¸ƒå°”å€¼æœ‰ä¸¤ä¸ªé¢å¤–çš„ç±»å‹å®šä¹‰ï¼š

```c++
typedef std::integral_constant<
  bool, true> true_type;
typedef std::integral_constant<
  bool, false> false_type;
```

è¿™ä¸¤ä¸ªæ ‡å‡†ç±»å‹ `true_type` å’Œ `false_type` ç»å¸¸å¯ä»¥åœ¨å‡½æ•°é‡è½½ä¸­è§åˆ°ã€‚æœ‰ä¸€ä¸ªå·¥å…·å‡½æ•°å¸¸å¸¸ä¼šå†™æˆä¸‹é¢è¿™ä¸ªæ ·å­ï¼š

```c++
template <typename T>
class SomeContainer {
public:
  â€¦
  static void destroy(T* ptr)
  {
    _destroy(ptr,
      is_trivially_destructible<
        T>());
  }

private:
  static void _destroy(T* ptr,
                       true_type)
  {}
  static void _destroy(T* ptr,
                       false_type)
  {
    ptr->~T();
  }
};
```

ç±»ä¼¼ä¸Šé¢ï¼Œå¾ˆå¤šå®¹å™¨ç±»é‡Œä¼šæœ‰ä¸€ä¸ª `destroy` å‡½æ•°ï¼Œé€šè¿‡æŒ‡é’ˆæ¥ææ„æŸä¸ªå¯¹è±¡ã€‚ä¸ºäº†ç¡®ä¿æœ€å¤§ç¨‹åº¦çš„ä¼˜åŒ–ï¼Œå¸¸ç”¨çš„ä¸€ä¸ªæŠ€å·§å°±æ˜¯ç”¨ `is_trivially_destructible` æ¨¡æ¿æ¥åˆ¤æ–­ç±»æ˜¯å¦æ˜¯å¯å¹³å‡¡ææ„çš„â€”â€”ä¹Ÿå°±æ˜¯è¯´ï¼Œä¸è°ƒç”¨ææ„å‡½æ•°ï¼Œä¸ä¼šé€ æˆä»»ä½•èµ„æºæ³„æ¼é—®é¢˜ã€‚æ¨¡æ¿è¿”å›çš„ç»“æœè¿˜æ˜¯ä¸€ä¸ªç±»ï¼Œè¦ä¹ˆæ˜¯ `true_type`ï¼Œè¦ä¹ˆæ˜¯ `false_type`ã€‚å¦‚æœè¦å¾—åˆ°å¸ƒå°”å€¼çš„è¯ï¼Œå½“ç„¶ä½¿ç”¨ `is_trivially_destructible<T>::value` å°±å¯ä»¥ï¼Œä½†æ­¤å¤„ä¸éœ€è¦ã€‚æˆ‘ä»¬éœ€è¦çš„æ˜¯ï¼Œä½¿ç”¨ `()` è°ƒç”¨è¯¥ç±»å‹çš„æ„é€ å‡½æ•°ï¼Œè®©ç¼–è¯‘å™¨æ ¹æ®æ•°å€¼ç±»å‹æ¥é€‰æ‹©åˆé€‚çš„é‡è½½ã€‚è¿™æ ·ï¼Œåœ¨ä¼˜åŒ–ç¼–è¯‘çš„æƒ…å†µä¸‹ï¼Œç¼–è¯‘å™¨å¯ä»¥æŠŠä¸éœ€è¦çš„ææ„æ“ä½œå½»åº•å…¨éƒ¨åˆ é™¤ã€‚

åƒ `is_trivially_destructible` è¿™æ ·çš„ trait ç±»æœ‰å¾ˆå¤šï¼Œå¯ä»¥ç”¨æ¥åœ¨æ¨¡æ¿é‡Œå†³å®šæ‰€éœ€çš„ç‰¹æ®Šè¡Œä¸ºï¼š

- `is_array`
- `is_enum`
- `is_function`
- `is_pointer`
- `is_reference`
- `is_const`
- `has_virtual_destructor`
- â€¦

è¿™äº›ç‰¹æ®Šè¡Œä¸ºåˆ¤æ–­å¯ä»¥æ˜¯åƒä¸Šé¢è¿™æ ·ç”¨äºå†³å®šä¸åŒçš„é‡è½½ï¼Œä¹Ÿå¯ä»¥æ˜¯ç›´æ¥ç”¨åœ¨æ¨¡æ¿å‚æ•°ç”šè‡³ä»£ç é‡Œï¼ˆè®°å¾—æˆ‘ä»¬æ˜¯å¯ä»¥ç›´æ¥å¾—åˆ°å¸ƒå°”å€¼çš„ï¼‰ã€‚

é™¤äº†å¾—åˆ°å¸ƒå°”å€¼å’Œç›¸å¯¹åº”çš„ç±»å‹çš„ trait æ¨¡æ¿ï¼Œæˆ‘ä»¬è¿˜æœ‰å¦å¤–ä¸€äº›æ¨¡æ¿ï¼Œå¯ä»¥ç”¨æ¥åšä¸€äº›ç±»å‹çš„è½¬æ¢ã€‚ä»¥ä¸€ä¸ªå¸¸è§çš„æ¨¡æ¿ `remove_const` ä¸ºä¾‹ï¼ˆç”¨æ¥å»é™¤ç±»å‹é‡Œçš„ const ä¿®é¥°ï¼‰ï¼Œå®ƒçš„å®šä¹‰å¤§è‡´å¦‚ä¸‹ï¼š

```c++
template <class T>
struct remove_const {
  typedef T type;
};
template <class T>
struct remove_const<const T> {
  typedef T type;
};
```

åŒæ ·ï¼Œå®ƒä¹Ÿæ˜¯åˆ©ç”¨æ¨¡æ¿çš„ç‰¹åŒ–ï¼Œé’ˆå¯¹ const ç±»å‹å»æ‰ç›¸åº”çš„ä¿®é¥°ã€‚æ¯”å¦‚ï¼Œå¦‚æœæˆ‘ä»¬å¯¹ `const string` åº”ç”¨ `remove_const`ï¼Œå°±ä¼šå¾—åˆ° `string`ï¼Œå³ï¼Œ`remove_const<const string>::type` ç­‰ä»·äº `string`ã€‚

è¿™é‡Œæœ‰ä¸€ä¸ªç»†èŠ‚ä½ è¦æ³¨æ„ä¸€ä¸‹ï¼Œå¦‚æœå¯¹ `const char*` åº”ç”¨ `remove_const` çš„è¯ï¼Œç»“æœè¿˜æ˜¯ `const char*`ã€‚åŸå› æ˜¯ï¼Œ`const char*` æ˜¯æŒ‡å‘ `const char` çš„æŒ‡é’ˆï¼Œè€Œä¸æ˜¯æŒ‡å‘ `char` çš„ const æŒ‡é’ˆã€‚å¦‚æœæˆ‘ä»¬å¯¹ `char * const` åº”ç”¨ `remove_const` çš„è¯ï¼Œè¿˜æ˜¯å¯ä»¥å¾—åˆ° `char*` çš„ã€‚

### ç®€æ˜“å†™æ³•

å¦‚æœä½ è§‰å¾—å†™ `is_trivially_destructible<T>::value` å’Œ `remove_const<T>::type` éå¸¸å•°å—¦çš„è¯ï¼Œé‚£ä½ ç»ä¸æ˜¯ä¸€ä¸ªäººã€‚åœ¨å½“å‰çš„ C++ æ ‡å‡†é‡Œï¼Œå‰è€…æœ‰å¢åŠ  `_v` çš„ç¼–è¯‘æ—¶å¸¸é‡ï¼Œåè€…æœ‰å¢åŠ  `_t` çš„ç±»å‹åˆ«åï¼š

```c++
template <class T>
inline constexpr bool
  is_trivially_destructible_v =
    is_trivially_destructible<
      T>::value;
```

```c++
template <class T>
using remove_const_t =
  typename remove_const<T>::type;
```

è‡³äºä»€ä¹ˆæ˜¯ `constexpr`ï¼Œæˆ‘ä»¬ä¼šå•ç‹¬è®²ã€‚`using` æ˜¯ç°ä»£ C++ çš„æ–°è¯­æ³•ï¼ŒåŠŸèƒ½å¤§è‡´ä¸ `typedef` ç›¸ä¼¼ï¼Œä½† `typedef` åªèƒ½é’ˆå¯¹æŸä¸ªç‰¹å®šçš„ç±»å‹ï¼Œè€Œ `using` å¯ä»¥ç”Ÿæˆåˆ«åæ¨¡æ¿ã€‚ç›®å‰æˆ‘ä»¬åªéœ€è¦çŸ¥é“ï¼Œåœ¨ä½ éœ€è¦ trait æ¨¡æ¿çš„ç»“æœæ•°å€¼å’Œç±»å‹æ—¶ï¼Œä½¿ç”¨å¸¦ `_v` å’Œ `_t` åç¼€çš„æ¨¡æ¿å¯èƒ½ä¼šæ›´æ–¹ä¾¿ï¼Œå°¤å…¶æ˜¯å¸¦ `_t` åç¼€çš„ç±»å‹è½¬æ¢æ¨¡æ¿ã€‚

## é€šç”¨çš„ fmap å‡½æ•°æ¨¡æ¿

ä½ åº”å½“å¤šå¤šå°‘å°‘å¬åˆ°è¿‡ map-reduceã€‚æŠ›å¼€å…¶ç›®å‰åœ¨å¤§æ•°æ®åº”ç”¨ä¸­çš„å…·ä½“æ–¹å¼ä¸è°ˆï¼Œä»æ¦‚å¿µæœ¬æºæ¥çœ‹ï¼Œmap \[3] å’Œ reduce \[4] éƒ½æ¥è‡ªå‡½æ•°å¼ç¼–ç¨‹ã€‚ä¸‹é¢æˆ‘ä»¬æ¼”ç¤ºä¸€ä¸ª map å‡½æ•°ï¼ˆå½“ç„¶ï¼Œåœ¨ C++ é‡Œå®ƒçš„åå­—å°±ä¸èƒ½å« `map` äº†ï¼‰ï¼Œå…¶ä¸­ç”¨åˆ°äº†ç›®å‰ä¸ºæ­¢æˆ‘ä»¬å­¦åˆ°çš„å¤šä¸ªçŸ¥è¯†ç‚¹ï¼š

```c++
template <
  template <typename, typename>
  class OutContainer = vector,
  typename F, class R>
auto fmap(F&& f, R&& inputs)
{
  typedef decay_t<decltype(
    f(*inputs.begin()))>
    result_type;
  OutContainer<
    result_type,
    allocator<result_type>>
    result;
  for (auto&& item : inputs) {
    result.push_back(f(item));
  }
  return result;
}
```

æˆ‘ä»¬ï¼š

- ç”¨ `decltype` æ¥è·å¾—ç”¨ `f` æ¥è°ƒç”¨ `inputs` å…ƒç´ çš„ç±»å‹ï¼ˆå‚è€ƒ[\[ç¬¬ 8 è®²\]](https://time.geekbang.org/column/article/176850)ï¼‰ï¼›
- ç”¨ `decay_t` æ¥æŠŠè·å¾—çš„ç±»å‹å˜æˆä¸€ä¸ªæ™®é€šçš„å€¼ç±»å‹ï¼›
- ç¼ºçœä½¿ç”¨ `vector` ä½œä¸ºè¿”å›å€¼çš„å®¹å™¨ï¼Œä½†å¯ä»¥é€šè¿‡æ¨¡æ¿å‚æ•°æ”¹ä¸ºå…¶ä»–å®¹å™¨ï¼›
- ä½¿ç”¨åŸºäºèŒƒå›´çš„ for å¾ªç¯æ¥éå† `inputs`ï¼Œå¯¹å…¶ç±»å‹ä¸ä½œå…¶ä»–è¦æ±‚ï¼ˆå‚è€ƒ[\[ç¬¬ 7 è®²\]](https://time.geekbang.org/column/article/176842)ï¼‰ï¼›
- å­˜æ”¾ç»“æœçš„å®¹å™¨éœ€è¦æ”¯æŒ `push_back` æˆå‘˜å‡½æ•°ï¼ˆå‚è€ƒ[\[ç¬¬ 4 è®²\]](https://time.geekbang.org/column/article/173167)ï¼‰ã€‚

ä¸‹é¢çš„ä»£ç å¯ä»¥éªŒè¯å…¶åŠŸèƒ½ï¼š

```c++
vector<int> v{1, 2, 3, 4, 5};
int add_1(int x)
{
    return x + 1;
}

auto result = fmap(add_1, v);
```

åœ¨ `fmap` æ‰§è¡Œä¹‹åï¼Œæˆ‘ä»¬ä¼šåœ¨ `result` é‡Œå¾—åˆ°ä¸€ä¸ªæ–°å®¹å™¨ï¼Œå…¶å†…å®¹æ˜¯ 2, 3, 4, 5, 6ã€‚

## å†…å®¹å°ç»“

æœ¬è®²æˆ‘ä»¬ä»‹ç»äº†æ¨¡æ¿å…ƒç¼–ç¨‹çš„åŸºæœ¬æ¦‚å¿µå’Œä¾‹å­ï¼Œå…¶æœ¬è´¨æ˜¯**æŠŠè®¡ç®—è¿‡ç¨‹ç”¨ç¼–è¯‘æœŸçš„ç±»å‹æ¨å¯¼å’Œç±»å‹åŒ¹é…è¡¨è¾¾å‡ºæ¥**ï¼›ç„¶åä»‹ç» type traits åŠå…¶åŸºæœ¬ç”¨æ³•ï¼›æœ€åæˆ‘ä»¬æ¼”ç¤ºäº†ä¸€ä¸ªç®€å•çš„é«˜é˜¶å‡½æ•° mapï¼Œå…¶å®ç°ä¸­ç”¨åˆ°äº†æˆ‘ä»¬ç›®å‰å·²ç»è®¨è®ºè¿‡çš„ä¸€äº›çŸ¥è¯†ç‚¹ã€‚

## è¯¾åæ€è€ƒ

è¿™ä¸€è®²çš„å†…å®¹å¯èƒ½æœ‰ç‚¹çƒ§è„‘ï¼Œè¯·ä½ è‡ªè¡Œå®éªŒä¸€ä¸‹ä¾‹å­ï¼Œå¹¶æ‰¾ä¸€ä¸¤ä¸ªç®€å•çš„ç®—æ³•ç”¨æ¨¡æ¿å…ƒç¼–ç¨‹çš„æ–¹æ³•å®ç°ä¸€ä¸‹ï¼Œçœ‹çœ‹èƒ½ä¸èƒ½å†™å‡ºæ¥ã€‚

å¦‚æœæœ‰ä»€ä¹ˆç‰¹åˆ«æƒ³æ³•çš„è¯ï¼Œæ¬¢è¿ç•™è¨€å’Œæˆ‘åˆ†äº«äº¤æµã€‚

## å‚è€ƒèµ„æ–™

\[1] Todd L. Veldhuizen, â€œC++ templates are Turing completeâ€. [http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.14.3670](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.14.3670)

\[2] cppreference.com, â€œStandard library header &lt;type\_traits&gt;â€. [https://en.cppreference.com/w/cpp/header/type\_traits](https://en.cppreference.com/w/cpp/header/type_traits)

\[2a] cppreference.com, â€œæ ‡å‡†åº“å¤´æ–‡ä»¶ &lt;type\_traits&gt;â€. [https://zh.cppreference.com/w/cpp/header/type\_traits](https://zh.cppreference.com/w/cpp/header/type_traits)

\[3] Wikipedia, â€œMap (higher-order function)â€. [https://en.wikipedia.org/wiki/Map\_(higher-order\_function)](https://en.wikipedia.org/wiki/Map_%28higher-order_function%29)

\[4] Wikipedia, â€œFold (higher-order function)â€. [https://en.wikipedia.org/wiki/Fold\_(higher-order\_function)](https://en.wikipedia.org/wiki/Fold_%28higher-order_function%29)
<div><strong>ç²¾é€‰ç•™è¨€ï¼ˆ15ï¼‰</strong></div><ul>
<li><span>ç¦¾æ¡ƒ</span> ğŸ‘ï¼ˆ22ï¼‰ ğŸ’¬ï¼ˆ3ï¼‰<p>è„‘å£³å„¿ç–¼çš„å…„å¼Ÿå§å¦¹ä»¬ï¼Œæˆ‘è¿™æœ‰ä¸ªå°åæ–¹ï¼Œ å“ˆå“ˆ

While&lt; Sum&lt;2&gt;::type &gt;::type::value å®ä¾‹åŒ–(instantiation)è¿‡ç¨‹
--&gt; While&lt; SumLoop&lt;0, 2&gt; &gt;::type::value
--&gt; WhileLoop&lt;SumLoop&lt;0, 2&gt;::cond_value, SumLoop&lt;0, 2&gt;&gt;::type::value
--&gt; WhileLoop&lt;true, SumLoop&lt;0, 2&gt;&gt;::type::value

--&gt; WhileLoop&lt;SumLoop&lt;0, 2&gt;::cond_value, SumLoop&lt;0, 2&gt;::next_type&gt;::type::value
--&gt; WhileLoop&lt;true, SumLoop&lt;2, 1&gt;&gt;::type::value

--&gt; WhileLoop&lt;SumLoop&lt;2, 1&gt;::cond_value, SumLoop&lt;2, 1&gt;::next_type&gt;::type::value
--&gt; WhileLoop&lt;true, SumLoop&lt;3, 0&gt;&gt;::type::value

--&gt; WhileLoop&lt;SumLoop&lt;3, 0&gt;::cond_value, SumLoop&lt;3, 0&gt;::next_type&gt;::type::value
--&gt; WhileLoop&lt;false, SumLoop&lt;3, -1&gt;&gt;::type::value

--&gt; SumLoop&lt;3, -1&gt;::res_type::value

--&gt;integral_constant&lt;int, 3&gt;::value
--&gt;3</p>2019-12-25</li><br/><li><span>æ€»ç»Ÿè€å”</span> ğŸ‘ï¼ˆ10ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>è®°å¾—å´è€å¸ˆä¹‹å‰é¢„å‘Šè¿‡ï¼Œè¿™ä¸€èŠ‚å¯èƒ½ä¼šæ¯”è¾ƒéš¾ï¼Œç¡®å®è¢«éš¾ä½äº†ã€‚åœ¨ç¬¬ä¸€ä¸ª If æ¨¡æ¿è¿™é‡Œå°±è¢«å¡ä½äº†ï¼Œè€å¸ˆèƒ½ç»™ä¸ªç®€å•çš„ä¾‹å­æ¥è¯´æ˜è¿™ä¸ª If æ¨¡æ¿è¯¥å¦‚ä½•ä½¿ç”¨ä¹ˆï¼Ÿ</p>2019-12-25</li><br/><li><span>chang</span> ğŸ‘ï¼ˆ4ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>æ¯”å¦‚ï¼Œå¦‚æœæˆ‘ä»¬å¯¹ const string&amp; åº”ç”¨ remove_constï¼Œå°±ä¼šå¾—åˆ° string&amp;ï¼Œå³ï¼Œremove_const::type ç­‰ä»·äº string&amp;ã€‚

remove_conståªèƒ½å»é¡¶å±‚constã€‚const string&amp;åº”ç”¨remove_conståè¿˜æ˜¯const string&amp;ï¼Œconst stringåº”ç”¨remove_conståæ˜¯stringã€‚</p>2021-06-03</li><br/><li><span>YouCompleteMe</span> ğŸ‘ï¼ˆ3ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>template &lt;typename Body&gt;
struct whileLoop&lt;true, Body&gt;
éƒ¨åˆ†ä¼¼ä¹æ”¹æˆä¸‹é¢è¿™æ ·ï¼Œæ›´ç›´è§‚ï¼Œ
ç¼–è¯‘æ—¶è®¡ç®—æ›´å°‘å‘¢

template &lt;typename Body&gt;
struct whileLoop&lt;true, Body&gt; {
    typedef typename whileLoop&lt;
      Body::next_type::cond_value, 
      typename Body::next_type&gt;::type 
      type;
};</p>2020-01-16</li><br/><li><span>è«è¨€</span> ğŸ‘ï¼ˆ2ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>template &lt;  template &lt;typename, typename&gt;  class OutContainer = vector,  typename F, class R&gt;
è¯·é—®è€å¸ˆï¼Œè¿™ä¸ªOutConContainerå‰é¢çš„template&lt;typename,typename&gt;åº”è¯¥æ€ä¹ˆç†è§£</p>2021-12-27</li><br/><li><span>æäº‘é¾™</span> ğŸ‘ï¼ˆ1ï¼‰ ğŸ’¬ï¼ˆ3ï¼‰<p>åˆ†äº«ä¸€ä¸‹æˆ‘çš„ä»£ç ï¼šå®ç°æ±‚æœ€å¤§å…¬çº¦æ•°çš„è¾—è½¬ç›¸é™¤æ³•
template &lt;bool Cond, typename Body&gt;
struct WhileLoop;

template &lt;typename Body&gt;
struct WhileLoop&lt;true, Body&gt;
{
    typedef typename WhileLoop&lt;Body::Cond, typename Body::NextType&gt;::type type;
};

template &lt;typename Body&gt;
struct WhileLoop&lt;false, Body&gt;
{
    typedef typename Body::ResType type;
};

template &lt;typename Body&gt;
struct While
{
    typedef typename WhileLoop&lt;Body::Cond, Body&gt;::type type;
};

template &lt;typename T, T val&gt;
struct integer
{
    typedef T ValueType;
    static const T Value = val;
    typedef integer type;
};

template &lt;int lhs, int rhs&gt;
struct GCD
{
    static const bool Cond = lhs % rhs != 0;
    static const int result = lhs;
    typedef integer&lt;int, result&gt; ResType;
    typedef GCD&lt;rhs, lhs % rhs&gt; NextType;
};

int main()
{
    cout &lt;&lt; While&lt;GCD&lt;100, 56&gt;&gt;::type::Value &lt;&lt; endl;
    return 0;
}</p>2023-10-14</li><br/><li><span>Geek_15f2c9</span> ğŸ‘ï¼ˆ1ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>è€å¸ˆï¼Œå¯¹ä¸‡èƒ½å¼•ç”¨ä½¿ç”¨å®Œç¾è½¬å‘æ˜¯å¦å¥½ç‚¹ï¼Œresult.push_back(std::forward&lt;decltype(f(item))&gt;(f(item)))æˆ–result.emplace_back(std::forward&lt;decltype(f(item))&gt;(f(item)));;</p>2021-04-28</li><br/><li><span>Gazelle</span> ğŸ‘ï¼ˆ1ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>æˆ‘å®è·µå†™äº†ä¸‹remove_constï¼Œå¥½åƒæ²¡æœ‰æŠŠconstå»æ‰ã€‚è¿™é‡Œæ˜¯ä¸æ˜¯æœ‰ç‚¹é—®é¢˜å‘¢ï¼Ÿ
https:&#47;&#47;stackoverflow.com&#47;questions&#47;15887144&#47;stdremove-const-with-const-references
æˆ‘çœ‹è¿™é‡Œè¯´æ˜¯å¦‚æœåŒæ—¶æœ‰constå’Œå¼•ç”¨çš„è¯ï¼Œè¿˜éœ€è¦å»æ‰å¼•ç”¨ï¼Ÿ
std::remove_const&lt;std::remove_reference&lt;const string&amp;&gt;::type&gt;::type</p>2020-11-29</li><br/><li><span>é²Â·æœ¬</span> ğŸ‘ï¼ˆ1ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>å¯¹While&lt;Sum&lt;10&gt;::type&gt;::type::valueè¿›è¡Œæ‰‹åŠ¨æ¨å¯¼ï¼Œæœ€ç»ˆæ˜¯èƒ½æ¨å¯¼å‡ºå®é™…è¯­å¥æ˜¯ integral_constant&lt;intï¼Œ10+9+...1&gt;::valueçš„ï¼Œä½†è®©æˆ‘ç‹¬ç«‹å†™å‡º å®Œæ•´çš„ä»£ç æ˜¯ä¸‡ä¸‡ä¸èƒ½çš„ğŸ˜„</p>2020-10-11</li><br/><li><span>åƒé±¼</span> ğŸ‘ï¼ˆ1ï¼‰ ğŸ’¬ï¼ˆ3ï¼‰<p>â€œå¦‚æœè¦å¾—åˆ°å¸ƒå°”å€¼çš„è¯ï¼Œå½“ç„¶ä½¿ç”¨ `is_trivially_destructible::value` å°±å¯ä»¥ï¼Œä½†æ­¤å¤„ä¸éœ€è¦ã€‚éœ€è¦çš„æ˜¯ï¼Œä½¿ç”¨ `()` è°ƒç”¨è¯¥ç±»å‹çš„æ„é€ å‡½æ•°ï¼Œè®©ç¼–è¯‘å™¨æ ¹æ®æ•°å€¼ç±»å‹æ¥é€‰æ‹©åˆé€‚çš„é‡è½½ã€‚è¿™æ ·ï¼Œåœ¨ä¼˜åŒ–ç¼–è¯‘çš„æƒ…å†µä¸‹ï¼Œç¼–è¯‘å™¨å¯ä»¥æŠŠä¸éœ€è¦çš„ææ„æ“ä½œå½»åº•å…¨éƒ¨åˆ é™¤ã€‚â€
è€å¸ˆï¼Œè¿™é‡Œæ²¡å¤ªæ‡‚ï¼Œä½¿ç”¨ `()` è°ƒç”¨è¯¥ç±»å‹çš„æ„é€ ï¼Œè¿™é‡Œçš„è°ƒç”¨æ˜¯åœ¨å“ªé‡Œè°ƒç”¨ï¼Œä¸ºä»€ä¹ˆ destroy è¦è°ƒç”¨æ„é€ å‡½æ•°</p>2020-06-02</li><br/><li><span>åƒä¸€ä¸ªèŠ’æœ</span> ğŸ‘ï¼ˆ1ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>template &lt;int num1, int num2&gt;
struct Add_
{
    const static int res = num1 + num2;
};

template &lt;int num1, int num2&gt;
struct Sub_
{
    const static int res = num1 - num2;
};

template &lt;bool Condition&gt;
struct If_;

template &lt;&gt;
struct If_ &lt;true&gt;
{
    template&lt;int num1, int num2&gt;
    using type = Add_&lt;num1, num2&gt;;
};

template &lt;&gt;
struct If_ &lt;false&gt;
{
    template&lt;int num1, int num2&gt;
    using type = Sub_&lt;num1, num2&gt;;
};

template&lt;int num1, int num2&gt;
template&lt;bool Condition&gt;
using If = typename If_&lt;Condition&gt;::template type&lt;num1, num2&gt;;

template&lt;int num1, int num2&gt;
using True = If&lt;true&gt;;

template&lt;int num1, int num2&gt;
using False = If&lt;false&gt;;

è€å¸ˆä½ å¥½ï¼Œæˆ‘æƒ³é—®ä¸€ä¸ªè¯­æ³•æ–¹é¢å¯èƒ½æ¯”è¾ƒé’»ç‰›è§’å°–çš„é—®é¢˜
æˆ‘å®šä¹‰äº†If_,ç”¨æ¥åœ¨trueå’Œfalseçš„æ—¶å€™è¿”å›ä¸åŒçš„æ¨¡æ¿ã€‚åˆå®šä¹‰äº†Trueå’ŒFalseï¼Œè¿™æ ·å°±å¯ä»¥é€šè¿‡True&lt;a, b&gt;::resæˆ–è€…False&lt;a, b&gt;::resæ¥è·å–ä¸åŒæ¨¡æ¿çš„è®¡ç®—ç»“æœã€‚ä½†æ˜¯å¦‚æœæˆ‘æƒ³ç”¨ç±»ä¼¼If&lt;condition&gt;&lt;a, b&gt;::resè¿™æ ·çš„è°ƒç”¨ï¼ˆä¸çŸ¥é“æˆ‘è¡¨è¾¾æ¸…æ¥šæ²¡æœ‰ï¼‰æ¥è·å–ä¸åŒçš„ç»“æœï¼ˆåœ¨ä¸æ”¹If_å®šä¹‰çš„æƒ…å†µä¸‹ï¼‰ï¼Œåº”è¯¥æ€ä¹ˆå†™å‘¢ï¼Ÿè°¢è°¢ï¼</p>2020-01-02</li><br/><li><span>æ€»ç»Ÿè€å”</span> ğŸ‘ï¼ˆ1ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>å´è€å¸ˆï¼Œå…³äºæœ€åè¿™ä¸ªä¾‹å­ï¼Œæœ‰ä¸¤ä¸ªå°é—®é¢˜ï¼š
1ï¼Œæˆ‘ä»¬å¹³æ—¶å®šä¹‰ä¸€ä¸ª vector çš„æ—¶å€™ï¼Œä¸€èˆ¬å¹¶ä¸ä¼šå†™æˆ vector&lt;int, allocator&lt;int&gt;&gt; vec è¿™ç§å½¢å¼ï¼Œä¸ºä»€ä¹ˆæ¨¡æ¿å‡½æ•°é‡Œé¢å®šä¹‰è¿”å›å€¼ result æ—¶ï¼Œéœ€è¦å¤šä¸€ä¸ª allocatorï¼Ÿ
2ï¼Œfmapå‡½æ•°çš„å…¥å‚å’Œforå¾ªç¯ï¼Œå…¨éƒ½ç”¨çš„å³å€¼å¼•ç”¨ï¼Œæœ‰ä»€ä¹ˆç‰¹æ®Šè€ƒé‡ä¹ˆï¼Ÿ</p>2019-12-27</li><br/><li><span>é™ˆç‹„</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>ç¼–è¯‘æœŸç¼–ç¨‹ç¡®å®6ï¼Œæ¨¡ç‰ˆå†™å¾ªç¯ç¡®å®ç»•ï¼Œå±•å¼€å¦‚ä¸‹ï¼š
While&lt;Sum&lt;10&gt;::type&gt;::type::value
While&lt;SumLoop&lt;0, 10&gt;&gt;::type::value
WhileLoop&lt;SumLoop&lt;0, 10&gt;::cond_value, SumLoop&lt;0, 10&gt;&gt;::type::value
WhileLoop&lt;true, SumLoop&lt;0, 10&gt;&gt;::type::value
WhileLoop&lt;SumLoop&lt;0, 10&gt;::cond_value, SumLoop&lt;0, 10&gt;::next_type&gt;::type::value
WhileLoop&lt;true, SumLoop&lt;10, 9&gt;&gt;::type::value
WhileLoop&lt;SumLoop&lt;10, 9&gt;&gt;::cond_value,SumLoop&lt;10, 9&gt;&gt;::next_type&gt;::type::value
...
WhileLoop&lt;SumLoop&lt;55, 0&gt;&gt;::cond_value,SumLoop&lt;55, 0&gt;&gt;::next_type&gt;::type::value
WhileLoop&lt;false,SumLoop&lt;55, -1&gt;&gt;::type::value
SumLoop&lt;55, -1&gt;::res_type::value
integral_constant&lt;int, 55&gt;::value</p>2022-04-29</li><br/><li><span>ç‹æ—§ä¸š</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>While&lt;Sum&lt;10&gt;::type&gt;::type::valueçš„ä¾‹å­ä¸­ä¼šä½¿ç”¨åˆ°äº†è‡ªå·±integral_constantæ¨¡æ¿ï¼Œä½†æ˜¯stlä¸­ä¹Ÿæœ‰ä¸€ä»½integral_constantï¼Œæ‰€ä»¥è¿è¡Œæœ¬ç¤ºä¾‹ä»£ç æ—¶å¦‚æœä¸€å¼€å§‹ç›´æ¥ using namespace stdä¼šç¼–è¯‘æŠ¥é”™</p>2021-02-17</li><br/><li><span>talor</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>è„‘å­çƒ§åäº†</p>2020-08-07</li><br/>
</ul>