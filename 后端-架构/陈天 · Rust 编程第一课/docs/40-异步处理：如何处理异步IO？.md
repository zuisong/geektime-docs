ä½ å¥½ï¼Œæˆ‘æ˜¯é™ˆå¤©ã€‚

å‰é¢ä¸¤è®²æˆ‘ä»¬å­¦ä¹ äº†å¼‚æ­¥å¤„ç†åŸºæœ¬çš„åŠŸèƒ½å’ŒåŸç†ï¼ˆFuture/async/awaitï¼‰ï¼Œä½†æ˜¯è¿˜æ²¡æœ‰æ­£å¼ä»‹ç»åœ¨å…·ä½“åœºåˆä¸‹è¯¥ç”¨å“ªäº›å·¥å…·æ¥å¤„ç†å¼‚æ­¥ IOã€‚ä¸è¿‡ä¹‹å‰è®² trait çš„æ—¶å€™ï¼Œå·²ç»äº†è§£å’Œä½¿ç”¨è¿‡ä¸€äº›å¤„ç†åŒæ­¥ IO çš„ç»“æ„å’Œ traitã€‚

ä»Šå¤©æˆ‘ä»¬å°±å¯¹æ¯”åŒæ­¥ IO æ¥å­¦ä¹ å¼‚æ­¥ IOã€‚æ¯•ç«Ÿåœ¨å­¦ä¹ æŸä¸ªæ–°çŸ¥è¯†çš„æ—¶å€™ï¼Œå¦‚æœèƒ½å¤Ÿå’Œå¤´è„‘ä¸­å·²æœ‰çš„çŸ¥è¯†è”ç³»èµ·æ¥ï¼Œå¤§è„‘ç¥ç»å…ƒä¹‹é—´çš„è¿æ¥å°±ä¼šè¢«æ¿€æ´»ï¼Œå­¦ä¹ çš„æ•ˆæœä¼šäº‹åŠåŠŸå€ã€‚

å›å¿†ä¸€ä¸‹åŒæ­¥ç¯å¢ƒéƒ½æœ‰å“ªäº›ç»“æ„å’Œ traitå‘¢ï¼Ÿé¦–å…ˆï¼Œå•ä¸ªçš„å€¼å¯ä»¥ç”¨ç±»å‹ T è¡¨è¿°ï¼Œä¸€ç»„å€¼å¯ä»¥ç”¨ Iterator trait è¡¨è¿°ï¼›åŒæ­¥ IOï¼Œæˆ‘ä»¬æœ‰æ ‡å‡†çš„ Read/Write/Seek traitã€‚é¡¾åæ€ä¹‰ï¼ŒRead/Write æ˜¯è¿›è¡Œ IO çš„è¯»å†™ï¼Œè€Œ Seek æ˜¯åœ¨ IO ä¸­å‰åç§»åŠ¨å½“å‰çš„ä½ç½®ã€‚

é‚£ä¹ˆå¼‚æ­¥å‘¢ï¼Ÿæˆ‘ä»¬å·²ç»å­¦ä¹ åˆ°ï¼Œå¯¹äºå•ä¸ªçš„ã€åœ¨æœªæ¥æŸä¸ªæ—¶åˆ»ä¼šå¾—åˆ°çš„å€¼ï¼Œå¯ä»¥ç”¨ Future æ¥è¡¨ç¤ºï¼š

![å›¾ç‰‡](https://static001.geekbang.org/resource/image/23/43/2371c456d1d7429caea5512f53ec5c43.jpg?wh=1920x1145)

ä½†è¿˜ä¸çŸ¥é“ä¸€ç»„æœªæ¥æ‰èƒ½å¾—åˆ°çš„å€¼è¯¥ç”¨ä»€ä¹ˆ trait æ¥è¡¨è¿°ï¼Œä¹Ÿä¸çŸ¥é“å¼‚æ­¥çš„ Read/Write è¯¥æ˜¯ä»€ä¹ˆæ ·å­ã€‚ä»Šå¤©ï¼Œæˆ‘ä»¬å°±æ¥èŠèŠè¿™äº›é‡è¦çš„å¼‚æ­¥æ•°æ®ç±»å‹ã€‚

## Stream trait

é¦–å…ˆæ¥äº†è§£ä¸€ä¸‹ Iterator åœ¨å¼‚æ­¥ç¯å¢ƒä¸‹çš„è¡¨å…„å¼Ÿï¼šStreamã€‚

æˆ‘ä»¬çŸ¥é“ï¼Œå¯¹äº Iteratorï¼Œå¯ä»¥ä¸æ–­è°ƒç”¨å…¶ next() æ–¹æ³•ï¼Œè·å¾—æ–°çš„å€¼ï¼Œç›´åˆ° Iterator è¿”å› Noneã€‚Iterator æ˜¯é˜»å¡å¼è¿”å›æ•°æ®çš„ï¼Œæ¯æ¬¡è°ƒç”¨ next()ï¼Œå¿…ç„¶ç‹¬å  CPU ç›´åˆ°å¾—åˆ°ä¸€ä¸ªç»“æœï¼Œ**è€Œå¼‚æ­¥çš„ Stream æ˜¯éé˜»å¡çš„ï¼Œåœ¨ç­‰å¾…çš„è¿‡ç¨‹ä¸­ä¼šç©ºå‡º CPU åšå…¶ä»–äº‹æƒ…**ã€‚

ä¸è¿‡å’Œ Future å·²ç»åœ¨æ ‡å‡†åº“ç¨³å®šä¸‹æ¥ä¸åŒï¼ŒStream trait ç›®å‰è¿˜åªèƒ½åœ¨ nightly ç‰ˆæœ¬ä½¿ç”¨ã€‚ä¸€èˆ¬è·Ÿ Stream æ‰“äº¤é“ï¼Œæˆ‘ä»¬ä¼šä½¿ç”¨ futures åº“ã€‚æ¥å¯¹æ¯” Iterator å’Œ Streamçš„æºç å®šä¹‰ï¼š

```rust
pub trait Iterator {
    type Item;
    fn next(&mut self) -> Option<Self::Item>;

    fn size_hint(&self) -> (usize, Option<usize>) { ... }
    fn map<B, F>(self, f: F) -> Map<Self, F> where F: FnMut(Self::Item) -> B { ... }
    ... // è¿˜æœ‰ 67 ä¸ªæ–¹æ³•
}

pub trait Stream {
    type Item;
    fn poll_next(self: Pin<&mut Self>,  cx: &mut Context<'_>) -> Poll<Option<Self::Item>>;

    fn size_hint(&self) -> (usize, Option<usize>) { ... }
}

pub trait StreamExt: Stream {
    fn next(&mut self) -> Next<'_, Self> where Self: Unpin { ... }
    fn map<T, F>(self, f: F) -> Map<Self, F> where F: FnMut(Self::Item) -> T { ... }
    ... // è¿˜æœ‰ 41 ä¸ªæ–¹æ³•
}
```

å¯ä»¥çœ‹åˆ°ï¼ŒIterator æŠŠæ‰€æœ‰æ–¹æ³•éƒ½æ”¾åœ¨ Iterator trait é‡Œï¼Œè€ŒStream æŠŠéœ€è¦å¼€å‘è€…å®ç°çš„åŸºæœ¬æ–¹æ³•å’Œæœ‰ç¼ºçœå®ç°çš„è¡ç”Ÿæ–¹æ³•åŒºåˆ«å¼€ï¼Œæ”¾åœ¨ä¸åŒçš„ trait é‡Œã€‚æ¯”å¦‚ mapã€‚

å®ç° Stream çš„æ—¶å€™ï¼Œå’Œ Iterator ç±»ä¼¼ï¼Œä½ éœ€è¦æä¾› Item ç±»å‹ï¼Œè¿™æ˜¯æ¯æ¬¡æ‹¿å‡ºä¸€ä¸ªå€¼æ—¶ï¼Œå€¼çš„ç±»å‹ï¼›æ­¤å¤–ï¼Œè¿˜æœ‰ poll\_next() æ–¹æ³•ï¼Œå®ƒé•¿å¾—å’Œ Future çš„ poll() æ–¹æ³•å¾ˆåƒï¼Œå’Œ Iterator ç‰ˆæœ¬çš„ next() çš„ä½œç”¨ç±»ä¼¼ã€‚

ç„¶è€Œï¼Œpoll\_next() è°ƒç”¨èµ·æ¥ä¸æ–¹ä¾¿ï¼Œæˆ‘ä»¬éœ€è¦è‡ªå·±å¤„ç† Poll çŠ¶æ€ï¼Œæ‰€ä»¥ï¼ŒStreamExt æä¾›äº† next() æ–¹æ³•ï¼Œè¿”å›ä¸€ä¸ªå®ç°äº† Future trait çš„ Next ç»“æ„ï¼Œè¿™æ ·ï¼Œæˆ‘ä»¬å°±å¯ä»¥ç›´æ¥é€šè¿‡ stream.next().await æ¥è·å–ä¸‹ä¸€ä¸ªå€¼äº†ã€‚æ¥çœ‹ next() æ–¹æ³•ä»¥åŠ Next ç»“æ„çš„å®ç°ï¼ˆ[æºç ](https://docs.rs/futures-util/0.3.17/src/futures_util/stream/stream/next.rs.html#10-34)ï¼‰ï¼š

```rust
pub trait StreamExt: Stream {
    fn next(&mut self) -> Next<'_, Self> where Self: Unpin {
        assert_future::<Option<Self::Item>, _>(Next::new(self))
    }
}

// next è¿”å›äº† Next ç»“æ„
pub struct Next<'a, St: ?Sized> {
    stream: &'a mut St,
}

// å¦‚æœ Stream Unpin é‚£ä¹ˆ Next ä¹Ÿæ˜¯ Unpin
impl<St: ?Sized + Unpin> Unpin for Next<'_, St> {}

impl<'a, St: ?Sized + Stream + Unpin> Next<'a, St> {
    pub(super) fn new(stream: &'a mut St) -> Self {
        Self { stream }
    }
}

// Next å®ç°äº† Futureï¼Œæ¯æ¬¡ poll() å®é™…ä¸Šå°±æ˜¯ä» stream ä¸­ poll_next()
impl<St: ?Sized + Stream + Unpin> Future for Next<'_, St> {
    type Output = Option<St::Item>;

    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        self.stream.poll_next_unpin(cx)
    }
}
```

çœ‹ä¸ªå°ä¾‹å­ï¼ˆ[ä»£ç ](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=4374c885eaf1a386fe6a67d8a54dc37b)ï¼‰ï¼š

```rust
use futures::prelude::*;

#[tokio::main]
async fn main() {
    let mut st = stream::iter(1..10)
        .filter(|x| future::ready(x % 2 == 0))
        .map(|x| x * x);

    while let Some(x) = st.next().await {
        println!("Got item: {}", x);
    }
}
```

æˆ‘ä»¬ä½¿ç”¨ stream::iter ç”Ÿæˆäº†ä¸€ä¸ª Streamï¼Œå¹¶å¯¹å…¶è¿›è¡Œ filter / map çš„æ“ä½œã€‚æœ€åï¼Œéå†æ•´ä¸ª streamï¼ŒæŠŠè·å¾—çš„æ•°æ®æ‰“å°å‡ºæ¥ã€‚ä»ä½¿ç”¨çš„æ„Ÿå—æ¥çœ‹ï¼ŒStream å’Œ Iterator ä¹Ÿå¾ˆç›¸ä¼¼ï¼Œå¯ä»¥å¯¹æ¯”ç€æ¥ç”¨ã€‚

### ç”Ÿæˆ Stream

futures åº“æä¾›äº†ä¸€äº›åŸºæœ¬çš„ç”Ÿæˆ Stream çš„æ–¹æ³•ï¼Œé™¤äº†ä¸Šé¢ç”¨åˆ°çš„ iter æ–¹æ³•ï¼Œè¿˜æœ‰ï¼š

- empty()ï¼šç”Ÿæˆä¸€ä¸ªç©ºçš„ Stream
- once()ï¼šç”Ÿæˆä¸€ä¸ªåªåŒ…å«å•ä¸ªå€¼çš„ Stream
- pending()ï¼šç”Ÿæˆä¸€ä¸ªä¸åŒ…å«ä»»ä½•å€¼ï¼Œåªè¿”å› Poll::Pending çš„ Stream
- repeat()ï¼šç”Ÿæˆä¸€ä¸ªä¸€ç›´è¿”å›ç›¸åŒå€¼çš„ Stream
- repeat\_with()ï¼šé€šè¿‡é—­åŒ…å‡½æ•°æ— ç©·å°½åœ°è¿”å›æ•°æ®çš„ Stream
- poll\_fn()ï¼šé€šè¿‡ä¸€ä¸ªè¿”å› Poll&lt;Option&lt;T&gt;&gt; çš„é—­åŒ…æ¥äº§ç”Ÿ Stream
- unfold()ï¼šé€šè¿‡åˆå§‹å€¼å’Œè¿”å› Future çš„é—­åŒ…æ¥äº§ç”Ÿ Stream

å‰å‡ ç§äº§ç”Ÿ Stream çš„æ–¹æ³•éƒ½å¾ˆå¥½ç†è§£ï¼Œæœ€åä¸‰ç§å¼•å…¥äº†é—­åŒ…å¤æ‚ä¸€ç‚¹ï¼Œæˆ‘ä»¬åˆ†åˆ«ä½¿ç”¨å®ƒä»¬æ¥å®ç°æ–æ³¢é‚£å¥‘æ•°åˆ—ï¼Œå¯¹æ¯”ä¸€ä¸‹å·®å¼‚ï¼ˆ[ä»£ç ](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=d83d2877d953b381c4f412b5768288ff)ï¼‰ï¼š

```rust
use futures::{prelude::*, stream::poll_fn};
use std::task::Poll;

#[tokio::main]
async fn main() {
    consume(fib().take(10)).await;
    consume(fib1(10)).await;
    // unfold äº§ç”Ÿçš„ Unfold stream æ²¡æœ‰å®ç° Unpinï¼Œ
    // æ‰€ä»¥æˆ‘ä»¬å°†å…¶ Pin<Box<T>> ä¸€ä¸‹ï¼Œä½¿å…¶æ»¡è¶³ consume çš„æ¥å£
    consume(fib2(10).boxed()).await;
}

async fn consume(mut st: impl Stream<Item = i32> + Unpin) {
    while let Some(v) = st.next().await {
        print!("{} ", v);
    }
    print!("\\n");
}

// ä½¿ç”¨ repeat_with åˆ›å»º streamï¼Œæ— æ³•æ§åˆ¶ä½•æ—¶ç»“æŸ
fn fib() -> impl Stream<Item = i32> {
    let mut a = 1;
    let mut b = 1;
    stream::repeat_with(move || {
        let c = a + b;
        a = b;
        b = c;
        b
    })
}

// ä½¿ç”¨ poll_fn åˆ›å»º streamï¼Œå¯ä»¥é€šè¿‡è¿”å› Poll::Ready(None) æ¥ç»“æŸ
fn fib1(mut n: usize) -> impl Stream<Item = i32> {
    let mut a = 1;
    let mut b = 1;
    poll_fn(move |_cx| -> Poll<Option<i32>> {
        if n == 0 {
            return Poll::Ready(None);
        }
        n -= 1;
        let c = a + b;
        a = b;
        b = c;
        Poll::Ready(Some(b))
    })
}

fn fib2(n: usize) -> impl Stream<Item = i32> {
    stream::unfold((n, (1, 1)), |(mut n, (a, b))| async move {
        if n == 0 {
            None
        } else {
            n -= 1;
            let c = a + b;
            // c ä½œä¸º poll_next() çš„è¿”å›å€¼ï¼Œ(n, (a, b)) ä½œä¸º state
            Some((c, (n, (b, c))))
        }
    })
}
```

å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œ**ä½¿ç”¨ unfold çš„æ—¶å€™ï¼ŒåŒæ—¶ä½¿ç”¨äº†å±€éƒ¨å˜é‡å’Œ Futureï¼Œæ‰€ä»¥ç”Ÿæˆçš„ Stream æ²¡æœ‰å®ç° Unpin**ï¼Œæˆ‘ä»¬åœ¨ä½¿ç”¨çš„æ—¶å€™ï¼Œéœ€è¦å°†å…¶ pin ä½ã€‚æ€ä¹ˆåšå‘¢ï¼Ÿ

Pin&lt;Box&lt;T&gt;&gt; æ˜¯ä¸€ç§å¾ˆç®€å•çš„æ–¹æ³•ï¼Œèƒ½å°†æ•°æ® Pin åœ¨å †ä¸Šï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ StreamExt çš„ boxed() æ–¹æ³•æ¥ç”Ÿæˆä¸€ä¸ª Pin&lt;Box&lt;T&gt;&gt;ã€‚

é™¤äº†ä¸Šé¢è®²çš„æ–¹æ³•ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥ä¸ºä¸€ä¸ªæ•°æ®ç»“æ„å®ç° Stream traitï¼Œä»è€Œä½¿å…¶æ”¯æŒ Streamã€‚çœ‹ä¸€ä¸ªä¾‹å­ï¼ˆ[ä»£ç ](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=94797b51e031dbde9d81ff04c5ff9f83)ï¼‰ï¼š

```rust
use futures::prelude::*;
use pin_project::pin_project;
use std::{
    pin::Pin,
    task::{Context, Poll},
};
use tokio::{
    fs,
    io::{AsyncBufReadExt, AsyncRead, BufReader, Lines},
};

/// LineStream å†…éƒ¨ä½¿ç”¨ tokio::io::Lines
#[pin_project]
struct LineStream<R> {
    #[pin]
    lines: Lines<BufReader<R>>,
}

impl<R: AsyncRead> LineStream<R> {
    /// ä» BufReader åˆ›å»ºä¸€ä¸ª LineStream
    pub fn new(reader: BufReader<R>) -> Self {
        Self {
            lines: reader.lines(),
        }
    }
}

/// ä¸º LineStream å®ç° Stream trait
impl<R: AsyncRead> Stream for LineStream<R> {
    type Item = std::io::Result<String>;

    fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
        self.project()
            .lines
            .poll_next_line(cx)
            .map(Result::transpose)
    }
}

#[tokio::main]
async fn main() -> std::io::Result<()> {
    let file = fs::File::open("Cargo.toml").await?;
    let reader = BufReader::new(file);
    let mut st = LineStream::new(reader);
    while let Some(Ok(line)) = st.next().await {
        println!("Got: {}", line);
    }

    Ok(())
}
```

è¿™æ®µä»£ç å°è£…äº† [Lines](https://docs.rs/tokio/1.14.0/tokio/io/struct.Lines.html) ç»“æ„ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ [AsyncBufReadExt](https://docs.rs/tokio/1.14.0/tokio/io/trait.AsyncBufReadExt.html) çš„ [lines()](https://docs.rs/tokio/1.14.0/tokio/io/trait.AsyncBufReadExt.html#method.lines) æ–¹æ³•ï¼ŒæŠŠä¸€ä¸ªå®ç°äº† [AsyncBufRead](https://docs.rs/tokio/1.14.0/tokio/io/trait.AsyncBufRead.html) trait çš„ reader è½¬æ¢æˆ Linesã€‚

ä½ ä¹Ÿè®¸æ³¨æ„åˆ°ä»£ç ä¸­å¼•å…¥çš„ [pin\_project](https://docs.rs/pin-project) åº“ï¼Œå®ƒæä¾›äº†ä¸€äº›ä¾¿åˆ©çš„å®ï¼Œæ–¹ä¾¿æˆ‘ä»¬æ“ä½œæ•°æ®ç»“æ„é‡Œéœ€è¦è¢« pin ä½çš„å­—æ®µã€‚åœ¨æ•°æ®ç»“æ„ä¸­ï¼Œ**å¯ä»¥ä½¿ç”¨ #\[pin] æ¥å£°æ˜æŸä¸ªå­—æ®µåœ¨ä½¿ç”¨çš„æ—¶å€™éœ€è¦è¢«å°è£…ä¸º Pin&lt;T&gt;**ã€‚è¿™æ ·ï¼Œè°ƒç”¨æ—¶ï¼Œæˆ‘ä»¬å°±å¯ä»¥ä½¿ç”¨ self.project().lines å¾—åˆ°ä¸€ä¸ª Pin&lt;&amp;mut Lines&gt;ï¼Œä»¥ä¾¿è°ƒç”¨å…¶ [poll\_next\_line()](https://docs.rs/tokio/1.14.0/tokio/io/struct.Lines.html#method.poll_next_line) æ–¹æ³•ï¼ˆè¿™ä¸ªæ–¹æ³•çš„ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ Pin&lt;&amp;mut Self&gt;ï¼‰ã€‚

åœ¨Linesè¿™ä¸ªç»“æ„å†…éƒ¨ï¼Œå¼‚æ­¥çš„ [next\_line()](https://docs.rs/tokio/1.14.0/tokio/io/struct.Lines.html#method.next_line) æ–¹æ³•å¯ä»¥è¯»å–ä¸‹ä¸€è¡Œï¼Œå®ƒå®é™…ä¸Šå°±æ˜¯æ¯”è¾ƒä½é˜¶çš„ [poll\_next\_line()](https://docs.rs/tokio/1.14.0/src/tokio/io/util/lines.rs.html#112-134) æ¥å£çš„ä¸€ä¸ªå°è£…ã€‚

**è™½ç„¶ Lines ç»“æ„æä¾›äº† next\_line()ï¼Œä½†å¹¶æ²¡æœ‰å®ç° Stream**ï¼Œæ‰€ä»¥æˆ‘ä»¬æ— æ³•åƒå…¶ä»– Stream é‚£æ ·ç»Ÿä¸€ç”¨ next() æ–¹æ³•è·å–ä¸‹ä¸€è¡Œã€‚äºæ˜¯ï¼Œæˆ‘ä»¬å°†å…¶åŒ…è£¹åœ¨è‡ªå·±çš„ LineStream ä¸‹ï¼Œå¹¶ä¸”ä¸º LineStream å®ç°äº† Stream æ–¹æ³•ã€‚

æ³¨æ„ï¼Œç”±äº poll\_next\_line() çš„ç»“æœæ˜¯ Result&lt;Option&lt;T&gt;&gt;ï¼Œè€Œ Stream çš„ poll\_next() çš„ç»“æœæ˜¯ Option&lt;Result&lt;T&gt;&gt;ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦ä½¿ç”¨ Result æ–¹æ³•çš„ [transpose](https://doc.rust-lang.org/std/result/enum.Result.html#method.transpose) æ¥å°†äºŒè€…å¯¹è°ƒã€‚è¿™ä¸ªtranspose æ–¹æ³•æ˜¯ä¸€ä¸ªå¾ˆåŸºç¡€çš„æ–¹æ³•ï¼Œéå¸¸å®ç”¨ã€‚

## å¼‚æ­¥ IO æ¥å£

åœ¨å®ç° LineStream æ—¶ï¼Œæˆ‘ä»¬é‡åˆ°äº†ä¸¤ä¸ªå¼‚æ­¥ I/O æ¥å£ï¼šAsyncRead ä»¥åŠ AsyncBufReadã€‚å›åˆ°å¼€å¤´çš„é‚£å¼ è¡¨ï¼Œç›¸ä¿¡ä½ ç°åœ¨å·²ç»æœ‰å¤§è‡´ç­”æ¡ˆäº†å§ï¼š**æ‰€æœ‰åŒæ­¥çš„ Read / Write / Seek traitï¼Œå‰é¢åŠ ä¸€ä¸ª Asyncï¼Œå°±æ„æˆäº†å¯¹åº”çš„å¼‚æ­¥ IO æ¥å£**ã€‚

ä¸è¿‡ï¼Œå’Œ Stream ä¸åŒçš„æ˜¯ï¼Œå¦‚æœä½ å¯¹æ¯” futures ä¸‹å®šä¹‰çš„ IO trait ä»¥åŠ tokio ä¸‹å®šä¹‰çš„ IO traitï¼Œä¼šå‘ç°å®ƒä»¬éƒ½æœ‰å„è‡ªçš„å®šä¹‰ï¼ŒåŒæ–¹å¹¶æœªç»Ÿä¸€ï¼Œæœ‰äº›è®¸çš„å·®åˆ«ï¼š

![å›¾ç‰‡](https://static001.geekbang.org/resource/image/da/28/da47e6ae335b4c46719afc64b5a60e28.jpg?wh=1920x1145)

æ¯”å¦‚ futures ä¸‹ [AsyncRead](https://docs.rs/futures/0.3.17/futures/io/trait.AsyncRead.html) çš„å®šä¹‰ï¼š

```rust
pub trait AsyncRead {
    fn poll_read(
        self: Pin<&mut Self>, 
        cx: &mut Context<'_>, 
        buf: &mut [u8]
    ) -> Poll<Result<usize, Error>>;

    unsafe fn initializer(&self) -> Initializer { ... }
    fn poll_read_vectored(
        self: Pin<&mut Self>, 
        cx: &mut Context<'_>, 
        bufs: &mut [IoSliceMut<'_>]
    ) -> Poll<Result<usize, Error>> { ... }
}
```

è€Œ tokio ä¸‹ [AsyncRead](https://docs.rs/tokio/1.14.0/tokio/io/trait.AsyncRead.html) çš„å®šä¹‰ï¼š

```rust
pub trait AsyncRead {
    fn poll_read(
        self: Pin<&mut Self>, 
        cx: &mut Context<'_>, 
        buf: &mut ReadBuf<'_>
    ) -> Poll<Result<()>>;
}
```

æˆ‘ä»¬çœ‹ä¸åŒä¹‹å¤„ï¼štokio çš„ poll\_read() æ–¹æ³•éœ€è¦ [ReadBuf](https://docs.rs/tokio/1.14.0/src/tokio/io/read_buf.rs.html#27-31)ï¼Œè€Œ futures çš„ poll\_read() æ–¹æ³•éœ€è¦ &amp;mut \[u8]ã€‚æ­¤å¤–ï¼Œfutures çš„ AsyncRead è¿˜å¤šäº†ä¸¤ä¸ªç¼ºçœæ–¹æ³•ã€‚

å†çœ‹ AsyncWriteã€‚futures ä¸‹çš„ [AsyncWrite](https://docs.rs/futures/0.3.17/futures/io/trait.AsyncWrite.html) æ¥å£å¦‚ä¸‹ï¼š

```rust
pub trait AsyncWrite {
    fn poll_write(
        self: Pin<&mut Self>, 
        cx: &mut Context<'_>, 
        buf: &[u8]
    ) -> Poll<Result<usize, Error>>;
    fn poll_flush(
        self: Pin<&mut Self>, 
        cx: &mut Context<'_>
    ) -> Poll<Result<(), Error>>;
    fn poll_close(
        self: Pin<&mut Self>, 
        cx: &mut Context<'_>
    ) -> Poll<Result<(), Error>>;

    fn poll_write_vectored(
        self: Pin<&mut Self>, 
        cx: &mut Context<'_>, 
        bufs: &[IoSlice<'_>]
    ) -> Poll<Result<usize, Error>> { ... }
}
```

è€Œ tokio ä¸‹çš„ [AsyncWrite](https://docs.rs/tokio/1.14.0/tokio/io/trait.AsyncWrite.html) çš„å®šä¹‰ï¼š

```rust
pub trait AsyncWrite {
    fn poll_write(
        self: Pin<&mut Self>, 
        cx: &mut Context<'_>, 
        buf: &[u8]
    ) -> Poll<Result<usize, Error>>;
    fn poll_flush(
        self: Pin<&mut Self>, 
        cx: &mut Context<'_>
    ) -> Poll<Result<(), Error>>;
    fn poll_shutdown(
        self: Pin<&mut Self>, 
        cx: &mut Context<'_>
    ) -> Poll<Result<(), Error>>;

    fn poll_write_vectored(
        self: Pin<&mut Self>, 
        cx: &mut Context<'_>, 
        bufs: &[IoSlice<'_>]
    ) -> Poll<Result<usize, Error>> { ... }
    fn is_write_vectored(&self) -> bool { ... }
}
```

å¯ä»¥çœ‹åˆ°ï¼ŒAsyncWrite äºŒè€…çš„å·®è·å°±åªæœ‰ poll\_close() å’Œ poll\_shutdown() å‘½åä¸Šçš„åˆ†åˆ«ã€‚å…¶å®ƒçš„å¼‚æ­¥ IO æ¥å£æˆ‘å°±ä¸ä¸€ä¸€ä¸¾ä¾‹äº†ï¼Œä½ å¯ä»¥è‡ªå·±å»çœ‹ä»£ç å¯¹æ¯”ã€‚

### å¼‚æ­¥ IO æ¥å£çš„å…¼å®¹æ€§å¤„ç†

ä¸ºä»€ä¹ˆ Rust çš„å¼‚æ­¥ IO trait ä¼šæœ‰è¿™æ ·çš„åˆ†è£‚ï¼Ÿè¿™æ˜¯å› ä¸ºåœ¨ tokio / futures åº“å®ç°çš„æ—©æœŸï¼Œç¤¾åŒºè¿˜æ²¡æœ‰å½¢æˆæ¯”è¾ƒç»Ÿä¸€çš„å¼‚æ­¥ IO traitï¼Œä¸åŒçš„æ¥å£èƒŒåä¹Ÿæœ‰å„è‡ªä¸åŒçš„è€ƒè™‘ï¼Œè¿™ç§åˆ†è£‚å°±æ²¿è¢­ä¸‹æ¥ã€‚

æ‰€ä»¥ï¼Œå¦‚æœæˆ‘ä»¬ä½¿ç”¨ tokio è¿›è¡Œå¼‚æ­¥å¼€å‘ï¼Œé‚£ä¹ˆï¼Œä»£ç éœ€è¦ä½¿ç”¨ tokio::io ä¸‹çš„å¼‚æ­¥ IO traitã€‚ä¹Ÿè®¸ï¼Œæœªæ¥ç­‰ Async IO trait ç¨³å®šå¹¶è¿›å…¥æ ‡å‡†åº“åï¼Œtokio ä¼šæ›´æ–°è‡ªå·±çš„ traitã€‚

è™½ç„¶ Rust çš„å¼‚æ­¥ IO trait æœ‰è¿™æ ·çš„åˆ†è£‚ï¼Œä½ ä¹Ÿä¸å¿…è¿‡åˆ†æ‹…å¿ƒã€‚**tokio-util æä¾›äº†ç›¸åº”çš„**[Compat](https://docs.rs/tokio-util/0.6.9/tokio_util/compat/index.html)**åŠŸèƒ½ï¼Œå¯ä»¥è®©ä½ çš„æ•°æ®ç»“æ„åœ¨äºŒè€…ä¹‹é—´è‡ªå¦‚åˆ‡æ¢**ã€‚çœ‹ä¸€ä¸ªä½¿ç”¨ [yamux](https://docs.rs/yamux) åšå¤šè·¯å¤ç”¨çš„ä¾‹å­ï¼Œé‡ç‚¹ä½ç½®è¯¦ç»†æ³¨é‡Šäº†ï¼š

```rust
use anyhow::Result;
use futures::prelude::*;
use tokio::net::TcpListener;
use tokio_util::{
    codec::{Framed, LinesCodec},
    compat::{FuturesAsyncReadCompatExt, TokioAsyncReadCompatExt},
};
use tracing::info;
use yamux::{Config, Connection, Mode, WindowUpdateMode};

#[tokio::main]
async fn main() -> Result<()> {
    tracing_subscriber::fmt::init();
    let addr = "0.0.0.0:8080";
    let listener = TcpListener::bind(addr).await?;
    info!("Listening on: {:?}", addr);
    loop {
        let (stream, addr) = listener.accept().await?;
        info!("Accepted: {:?}", addr);
        let mut config = Config::default();
        config.set_window_update_mode(WindowUpdateMode::OnRead);
        // ä½¿ç”¨ compat() æ–¹æ³•æŠŠ tokio AsyncRead/AsyncWrite è½¬æ¢æˆ futures å¯¹åº”çš„ trait
        let conn = Connection::new(stream.compat(), config, Mode::Server);
        // Yamux ctrl stream å¯ä»¥ç”¨æ¥æ‰“å¼€æ–°çš„ stream
        let _ctrl = conn.control();
        tokio::spawn(
            yamux::into_stream(conn).try_for_each_concurrent(None, move |s| async move {
                // ä½¿ç”¨ compat() æ–¹æ³•æŠŠ futures AsyncRead/AsyncWrite è½¬æ¢æˆ tokio å¯¹åº”çš„ trait
                let mut framed = Framed::new(s.compat(), LinesCodec::new());
                while let Some(Ok(line)) = framed.next().await {
                    println!("Got: {}", line);
                    framed
                        .send(format!("Hello! I got '{}'", line))
                        .await
                        .unwrap();
                }

                Ok(())
            }),
        );
    }
}
```

yamux æ˜¯ä¸€ä¸ªç±»ä¼¼ HTTP/2 å†…éƒ¨å¤šè·¯å¤ç”¨æœºåˆ¶çš„åè®®ï¼Œå¯ä»¥è®©ä½ åœ¨ä¸€ä¸ª TCP è¿æ¥ä¸Šæ‰“å¼€å¤šä¸ªé€»è¾‘ yamux streamï¼Œè€Œyamux stream ä¹‹é—´å¹¶è¡Œå·¥ä½œï¼Œäº’ä¸å¹²æ‰°ã€‚

yamux crate åœ¨å®ç°çš„æ—¶å€™ï¼Œä½¿ç”¨äº† futures ä¸‹çš„å¼‚æ­¥ IO æ¥å£ã€‚ä½†æ˜¯å½“æˆ‘ä»¬ä½¿ç”¨ tokio Listener æ¥å—ä¸€ä¸ªå®¢æˆ·ç«¯ï¼Œå¾—åˆ°å¯¹åº”çš„ TcpStream æ—¶ï¼Œè¿™ä¸ª TcpStream ä½¿ç”¨çš„æ˜¯ tokio ä¸‹çš„å¼‚æ­¥ IO æ¥å£ã€‚æ‰€ä»¥æˆ‘ä»¬éœ€è¦ tokio\_util::compat æ¥ååŠ©æ¥å£çš„å…¼å®¹ã€‚

åœ¨ä»£ç ä¸­ï¼Œé¦–å…ˆæˆ‘ç”¨ stream.compat() ç”Ÿæˆä¸€ä¸ª Compat ç»“æ„ï¼Œä¾› yamux Connection ä½¿ç”¨ï¼š

```rust
let conn = Connection::new(stream.compat(), config, Mode::Server);
```

ä¹‹åï¼Œæ‹¿åˆ° yamux connection ä¸‹æ‰€æœ‰ stream è¿›è¡Œå¤„ç†æ—¶ï¼Œæˆ‘ä»¬æƒ³ç”¨ tokio çš„ Frame å’Œ Codec ä¸€è¡Œè¡Œè¯»å–å’Œå†™å…¥ï¼Œä¹Ÿå°±éœ€è¦æŠŠä½¿ç”¨ futures å¼‚æ­¥æ¥å£çš„ yamux streamï¼Œè½¬æ¢æˆä½¿ç”¨ tokio æ¥å£çš„æ•°æ®ç»“æ„ï¼Œè¿™æ ·å°±å¯ä»¥ç”¨åœ¨ Framed::new() ä¸­ï¼š

```rust
let mut framed = Framed::new(s.compat(), LinesCodec::new());
```

å¦‚æœä½ æƒ³è¿è¡Œè¿™æ®µä»£ç ï¼Œå¯ä»¥çœ‹è¿™é—¨è¯¾çš„ [GitHub repo](https://github.com/tyrchen/geektime-rust) ä¸‹çš„å®Œæ•´ç‰ˆï¼ŒåŒ…æ‹¬ä¾èµ–ä»¥åŠå®¢æˆ·ç«¯çš„ä»£ç ã€‚

### å®ç°å¼‚æ­¥ IO æ¥å£

å¼‚æ­¥ IO ä¸»è¦åº”ç”¨åœ¨æ–‡ä»¶å¤„ç†ã€ç½‘ç»œå¤„ç†ç­‰åœºåˆï¼Œè€Œè¿™äº›åœºåˆçš„æ•°æ®ç»“æ„éƒ½å·²ç»å®ç°äº†å¯¹åº”çš„æ¥å£ï¼Œæ¯”å¦‚ File æˆ–è€… TcpStreamï¼Œå®ƒä»¬ä¹Ÿå·²ç»å®ç°äº† AsyncRead / AsyncWriteã€‚æ‰€ä»¥åŸºæœ¬ä¸Šï¼Œæˆ‘ä»¬ä¸ç”¨è‡ªå·±å®ç°å¼‚æ­¥ IO æ¥å£ï¼Œåªéœ€è¦ä¼šç”¨å°±å¯ä»¥äº†ã€‚

ä¸è¿‡æœ‰äº›æƒ…å†µï¼Œæˆ‘ä»¬å¯èƒ½ä¼šæŠŠå·²æœ‰çš„æ•°æ®ç»“æ„å°è£…åœ¨è‡ªå·±çš„æ•°æ®ç»“æ„ä¸­ï¼Œæ­¤æ—¶ï¼Œä¹Ÿåº”è¯¥å®ç°ç›¸åº”çš„å¼‚æ­¥ IO æ¥å£ï¼ˆ[ä»£ç ](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=b53409b4ad26aaf078d4799bfe95f65c)ï¼‰ï¼š

```rust
use anyhow::Result;
use pin_project::pin_project;
use std::{
    pin::Pin,
    task::{Context, Poll},
};
use tokio::{
    fs::File,
    io::{AsyncRead, AsyncReadExt, ReadBuf},
};

#[pin_project]
struct FileWrapper {
    #[pin]
    file: File,
}

impl FileWrapper {
    pub async fn try_new(name: &str) -> Result<Self> {
        let file = File::open(name).await?;
        Ok(Self { file })
    }
}

impl AsyncRead for FileWrapper {
    fn poll_read(
        self: Pin<&mut Self>,
        cx: &mut Context<'_>,
        buf: &mut ReadBuf<'_>,
    ) -> Poll<std::io::Result<()>> {
        self.project().file.poll_read(cx, buf)
    }
}

#[tokio::main]
async fn main() -> Result<()> {
    let mut file = FileWrapper::try_new("./Cargo.toml").await?;
    let mut buffer = String::new();
    file.read_to_string(&mut buffer).await?;
    println!("{}", buffer);
    Ok(())
}
```

è¿™æ®µä»£ç å°è£…äº† tokio::fs::File ç»“æ„ï¼Œæˆ‘ä»¬æƒ³è¯»å–å†…éƒ¨çš„ file å­—æ®µï¼Œä½†åˆä¸æƒ³æŠŠ File æš´éœ²å‡ºæ¥ï¼Œå› æ­¤å®ç°äº† AsyncRead traitã€‚

## Sink trait

åœ¨åŒæ­¥ç¯å¢ƒä¸‹å¾€ IO ä¸­å‘é€è¿ç»­çš„æ•°æ®ï¼Œå¯ä»¥ä¸€æ¬¡æ€§å‘é€ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨ Write trait å¤šæ¬¡å‘é€ï¼Œä½¿ç”¨èµ·æ¥å¹¶æ²¡æœ‰ä»€ä¹ˆéº»çƒ¦ï¼›ä½†åœ¨å¼‚æ­¥ IO ä¸‹ï¼ŒåšåŒæ ·çš„äº‹æƒ…ï¼Œæˆ‘ä»¬éœ€è¦æ›´æ–¹ä¾¿çš„æ¥å£ã€‚å› æ­¤å¼‚æ­¥IOè¿˜æœ‰ä¸€ä¸ªæ¯”è¾ƒç‹¬ç‰¹çš„ Sink traitï¼Œå®ƒæ˜¯ä¸€ä¸ªç”¨äºå‘é€ä¸€ç³»åˆ—å¼‚æ­¥å€¼çš„æ¥å£ã€‚

çœ‹ Sink trait çš„å®šä¹‰ï¼š

```rust
pub trait Sink<Item> {
    type Error;
    fn poll_ready(
        self: Pin<&mut Self>, 
        cx: &mut Context<'_>
    ) -> Poll<Result<(), Self::Error>>;
    fn start_send(self: Pin<&mut Self>, item: Item) -> Result<(), Self::Error>;
    fn poll_flush(
        self: Pin<&mut Self>, 
        cx: &mut Context<'_>
    ) -> Poll<Result<(), Self::Error>>;
    fn poll_close(
        self: Pin<&mut Self>, 
        cx: &mut Context<'_>
    ) -> Poll<Result<(), Self::Error>>;
}

pub trait SinkExt<Item>: Sink<Item> {
    ...
    fn send(&mut self, item: Item) -> Send<'_, Self, Item> where Self: Unpin { ... }
    ...
}
```

å’Œ Stream trait ä¸åŒçš„æ˜¯ï¼ŒSink trait çš„ Item æ˜¯ trait çš„æ³›å‹å‚æ•°ï¼Œè€Œä¸æ˜¯å…³è”ç±»å‹ã€‚**ä¸€èˆ¬è€Œè¨€ï¼Œå½“ trait æ¥å—æŸä¸ª inputï¼Œåº”è¯¥ä½¿ç”¨æ³›å‹å‚æ•°ï¼Œæ¯”å¦‚ Add&lt;Rhs&gt;ï¼›å½“å®ƒè¾“å‡ºæŸä¸ª outputï¼Œé‚£ä¹ˆåº”è¯¥ä½¿ç”¨å…³è”ç±»å‹ï¼Œæ¯”å¦‚ Futureã€Streamã€Iterator ç­‰**ã€‚

Item å¯¹äº Sink æ¥è¯´æ˜¯è¾“å…¥ï¼Œæ‰€ä»¥ä½¿ç”¨æ³›å‹å‚æ•°æ˜¯æ­£ç¡®çš„é€‰æ‹©ã€‚å› ä¸ºè¿™ä¹Ÿæ„å‘³ç€ï¼Œåœ¨å‘é€ç«¯ï¼Œå¯ä»¥å‘é€ä¸åŒç±»å‹çš„æ•°æ®ç»“æ„ã€‚

çœ‹ä¸Šé¢çš„å®šä¹‰æºç ï¼ŒSink trait æœ‰å››ä¸ªæ–¹æ³•ï¼š

- poll\_ready()ï¼šç”¨æ¥å‡†å¤‡ Sink ä½¿å…¶å¯ä»¥å‘é€æ•°æ®ã€‚åªæœ‰ poll\_ready() è¿”å› Poll::Ready(Ok(())) åï¼ŒSink æ‰ä¼šå¼€å±•åç»­çš„åŠ¨ä½œã€‚poll\_ready() å¯ä»¥ç”¨æ¥æ§åˆ¶èƒŒå‹ã€‚
- start\_send()ï¼šå¼€å§‹å‘é€æ•°æ®åˆ° Sinkã€‚ä½†æ˜¯start\_send() å¹¶ä¸ä¿è¯æ•°æ®è¢«å‘é€å®Œæ¯•ï¼Œæ‰€ä»¥è°ƒç”¨è€…è¦è°ƒç”¨ poll\_flush() æˆ–è€… poll\_close() æ¥ä¿è¯å®Œæ•´å‘é€ã€‚
- poll\_flush()ï¼šå°†ä»»ä½•å°šæœªå‘é€çš„æ•°æ® flush åˆ°è¿™ä¸ª Sinkã€‚
- poll\_close()ï¼šå°†ä»»ä½•å°šæœªå‘é€çš„æ•°æ® flush åˆ°è¿™ä¸ª Sinkï¼Œå¹¶å…³é—­è¿™ä¸ª Sinkã€‚

å…¶ä¸­ä¸‰ä¸ªæ–¹æ³•å’Œ Item æ˜¯æ— å…³çš„ï¼Œè¿™ä¼šå¯¼è‡´ï¼Œå¦‚æœä¸åŒçš„è¾“å…¥ç±»å‹æœ‰å¤šä¸ªå®ç°ï¼ŒSinkçš„poll\_readyã€poll\_flush å’Œ poll\_close å¯èƒ½ä¼šæœ‰é‡å¤çš„ä»£ç ã€‚æ‰€ä»¥ä¸€èˆ¬æˆ‘ä»¬åœ¨ä½¿ç”¨ Sink æ—¶ï¼Œå¦‚æœç¡®å®éœ€è¦å¤„ç†ä¸åŒçš„æ•°æ®ç±»å‹ï¼Œå¯ä»¥ç”¨ enum å°†å®ƒä»¬ç»Ÿä¸€ï¼ˆæ„Ÿå…´è¶£çš„è¯ï¼Œå¯ä»¥è¿›ä¸€æ­¥é˜…è¯»è¿™ä¸ª[è®¨è®º](https://github.com/rust-lang/futures-rs/issues/623)ï¼‰ã€‚

æˆ‘ä»¬å°±ç”¨ä¸€ä¸ªç®€å•çš„ FileSink çš„ä¾‹å­ï¼Œçœ‹çœ‹å¦‚ä½•å®ç°è¿™äº›æ–¹æ³•ã€‚tokio::fs ä¸‹çš„ File ç»“æ„å·²ç»å®ç°äº† AsyncRead / AsyncWriteï¼Œæˆ‘ä»¬åªéœ€è¦åœ¨ Sink çš„å‡ ä¸ªæ–¹æ³•ä¸­è°ƒç”¨ AsyncWrite çš„æ–¹æ³•å³å¯ï¼ˆ[ä»£ç ](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=b3aab166023b7478ccd947703f8f53cd)ï¼‰ï¼š

```rust
use anyhow::Result;
use bytes::{BufMut, BytesMut};
use futures::{Sink, SinkExt};
use pin_project::pin_project;
use std::{
    pin::Pin,
    task::{Context, Poll},
};
use tokio::{fs::File, io::AsyncWrite};

#[pin_project]
struct FileSink {
    #[pin]
    file: File,
    buf: BytesMut,
}

impl FileSink {
    pub fn new(file: File) -> Self {
        Self {
            file,
            buf: BytesMut::new(),
        }
    }
}

impl Sink<&str> for FileSink {
    type Error = std::io::Error;

    fn poll_ready(self: Pin<&mut Self>, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
        Poll::Ready(Ok(()))
    }

    fn start_send(self: Pin<&mut Self>, item: &str) -> Result<(), Self::Error> {
        let this = self.project();
        eprint!("{}", item);
        this.buf.put(item.as_bytes());
        Ok(())
    }

    fn poll_flush(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
        // å¦‚æœæƒ³ project() å¤šæ¬¡ï¼Œéœ€è¦å…ˆæŠŠ self reborrow ä¸€ä¸‹
        let this = self.as_mut().project();
        let buf = this.buf.split_to(this.buf.len());
        if buf.is_empty() {
            return Poll::Ready(Ok(()));
        }

        // å†™å…¥æ–‡ä»¶
        if let Err(e) = futures::ready!(this.file.poll_write(cx, &buf[..])) {
            return Poll::Ready(Err(e));
        }
        // åˆ·æ–°æ–‡ä»¶
        self.project().file.poll_flush(cx)
    }

    fn poll_close(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
        let this = self.project();
        // ç»“æŸå†™å…¥
        this.file.poll_shutdown(cx)
    }
}

#[tokio::main]
async fn main() -> Result<()> {
    let file_sink = FileSink::new(File::create("/tmp/hello").await?);
    // pin_mut å¯ä»¥æŠŠå˜é‡ pin ä½
    futures::pin_mut!(file_sink);
    file_sink.send("hello\\n").await?;
    file_sink.send("world!\\n").await?;
    file_sink.send("Tyr!\\n").await?;

    Ok(())
}
```

å¯¹äº poll\_ready() æ–¹æ³•ï¼Œç›´æ¥è¿”å› Poll::Ready(Ok(()))ã€‚

åœ¨ start\_send() æ–¹æ³•ä¸­ï¼Œæˆ‘ä»¬æŠŠä¼ å…¥çš„ itemï¼Œå†™å…¥ FileSink çš„ BytesMut ä¸­ã€‚ç„¶ååœ¨ poll\_flush() æ—¶ï¼Œæˆ‘ä»¬æ‹¿åˆ° bufï¼ŒæŠŠå·²æœ‰çš„å†…å®¹è°ƒç”¨ [split\_to()](https://docs.rs/bytes/1.1.0/bytes/struct.BytesMut.html#method.split_to)ï¼Œå¾—åˆ°ä¸€ä¸ªåŒ…å«æ‰€æœ‰æœªå†™å…¥æ–‡ä»¶çš„æ–° bufferã€‚è¿™ä¸ª buffer å’Œ self æ— å…³ï¼Œæ‰€ä»¥ä¼ å…¥ poll\_write() æ—¶ï¼Œä¸ä¼šæœ‰å¯¹ self çš„å¼•ç”¨é—®é¢˜ã€‚

åœ¨å†™å…¥æ–‡ä»¶åï¼Œæˆ‘ä»¬å†æ¬¡è°ƒç”¨ poll\_flush() ï¼Œç¡®ä¿å†™å…¥çš„å†…å®¹åˆ·æ–°åˆ°ç£ç›˜ä¸Šã€‚æœ€åï¼Œåœ¨ poll\_close() æ—¶è°ƒç”¨ poll\_shutdown() å…³é—­æ–‡ä»¶ã€‚

è¿™æ®µä»£ç è™½ç„¶å®ç°äº† Sink traitï¼Œä¹Ÿå±•ç¤ºäº†å¦‚ä½•å®ç° Sink çš„å‡ ä¸ªæ–¹æ³•ï¼Œä½†æ˜¯è¿™ä¹ˆç®€å•çš„ä¸€ä¸ªé—®é¢˜ï¼Œå¤„ç†èµ·æ¥è¿˜æ˜¯é¢‡ä¸ºè´¹åŠ²ã€‚æœ‰æ²¡æœ‰æ›´ç®€å•çš„æ–¹æ³•å‘¢ï¼Ÿ

æœ‰çš„ã€‚futures é‡Œæä¾›äº† sink::unfold æ–¹æ³•ï¼Œç±»ä¼¼ stream::unfoldï¼Œæˆ‘ä»¬æ¥é‡å†™ä¸Šé¢çš„ File Sink çš„ä¾‹å­ï¼ˆ[ä»£ç ](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=2582cfe2473f615b4e2f021893d738a3)ï¼‰ï¼š

```rust
use anyhow::Result;
use futures::prelude::*;
use tokio::{fs::File, io::AsyncWriteExt};

#[tokio::main]
async fn main() -> Result<()> {
    let file_sink = writer(File::create("/tmp/hello").await?);
    // pin_mut å¯ä»¥æŠŠå˜é‡ pin ä½
    futures::pin_mut!(file_sink);
    if let Err(_) = file_sink.send("hello\\n").await {
        println!("Error on send");
    }
    if let Err(_) = file_sink.send("world!\\n").await {
        println!("Error on send");
    }
    Ok(())
}

/// ä½¿ç”¨ unfold ç”Ÿæˆä¸€ä¸ª Sink æ•°æ®ç»“æ„
fn writer<'a>(file: File) -> impl Sink<&'a str> {
    sink::unfold(file, |mut file, line: &'a str| async move {
        file.write_all(line.as_bytes()).await?;
        eprint!("Received: {}", line);
        Ok::<_, std::io::Error>(file)
    })
}
```

å¯ä»¥çœ‹åˆ°ï¼Œé€šè¿‡ unfold æ–¹æ³•ï¼Œæˆ‘ä»¬ä¸éœ€è¦æ’°å†™ Sink çš„å‡ ä¸ªæ–¹æ³•äº†ï¼Œè€Œä¸”å¯ä»¥åœ¨ä¸€ä¸ªè¿”å› Future çš„é—­åŒ…ä¸­æ¥æä¾›å¤„ç†é€»è¾‘ï¼Œè¿™å°±æ„å‘³ç€æˆ‘ä»¬å¯ä»¥ä¸ä½¿ç”¨ poll\_xxx è¿™æ ·çš„æ–¹æ³•ï¼Œç›´æ¥åœ¨é—­åŒ…ä¸­ä½¿ç”¨è¿™æ ·çš„å¼‚æ­¥å‡½æ•°ï¼š

```rust
file.write_all(line.as_bytes()).await?
```

ä½ çœ‹ï¼ŒçŸ­çŸ­ 5 è¡Œä»£ç ï¼Œå°±å®ç°äº†åˆšæ‰äº”åå¤šè¡Œä»£ç è¦è¡¨è¾¾çš„é€»è¾‘ã€‚

## å°ç»“

ä»Šå¤©æˆ‘ä»¬å­¦ä¹ äº†å’Œå¼‚æ­¥ IO ç›¸å…³çš„ Stream / Sink traitï¼Œä»¥åŠå’Œå¼‚æ­¥è¯»å†™ç›¸å…³çš„ AsyncRead / AsyncWrite ç­‰ traitã€‚åœ¨å­¦ä¹ å¼‚æ­¥ IO æ—¶ï¼Œå¾ˆå¤šå†…å®¹éƒ½å¯ä»¥å’ŒåŒæ­¥ IO çš„å¤„ç†å¯¹æ¯”ç€å­¦ï¼Œè¿™æ ·äº‹åŠåŠŸå€ã€‚

![å›¾ç‰‡](https://static001.geekbang.org/resource/image/da/28/da47e6ae335b4c46719afc64b5a60e28.jpg?wh=1920x1145)

åœ¨å¤„ç†å¼‚æ­¥ IO æ—¶ï¼Œåº•å±‚çš„ poll\_xxx() å‡½æ•°å¾ˆéš¾å†™ï¼Œå› ä¸ºå®ƒçš„çº¦æŸå¾ˆå¤šã€‚å¥½åœ¨æœ‰ pin\_project è¿™ä¸ªé¡¹ç›®ï¼Œç”¨å®å¸®æˆ‘ä»¬è§£å†³äº†å¾ˆå¤šå…³äº Pin/Unpin çš„é—®é¢˜ã€‚

ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬ä¸å¤ªéœ€è¦ç›´æ¥å®ç° Stream / Sink / AsyncRead / AsyncWrite traitï¼Œå¦‚æœçš„ç¡®éœ€è¦ï¼Œå…ˆçœ‹çœ‹æœ‰æ²¡æœ‰å¯ä»¥ä½¿ç”¨çš„è¾…åŠ©å‡½æ•°ï¼Œæ¯”å¦‚é€šè¿‡ poll\_fn / unfold åˆ›å»º Streamã€é€šè¿‡ unfold åˆ›å»º Sinkã€‚

### æ€è€ƒé¢˜

æˆ‘ä»¬çŸ¥é“ tokio:sync::mpsc ä¸‹æœ‰æ”¯æŒå¼‚æ­¥çš„ MPSC channelï¼Œç”Ÿäº§è€…å¯ä»¥é€šè¿‡ send() å‘é€æ¶ˆæ¯ï¼Œæ¶ˆè´¹è€…å¯ä»¥é€šè¿‡ recv() æ¥æ¥æ”¶æ¶ˆæ¯ã€‚ä½ èƒ½ä¸èƒ½ä¸ºå…¶å°è£… Sink å’Œ Stream çš„å®ç°ï¼Œè®© MPSC channel å¯ä»¥åƒ Stream / Sink ä¸€æ ·ä½¿ç”¨ï¼Ÿï¼ˆæç¤ºï¼štokio-stream æœ‰ ReceiverStream çš„å®ç°ï¼‰ã€‚

æ¬¢è¿åœ¨ç•™è¨€åŒºåˆ†äº«ä½ çš„æ€è€ƒå’Œå­¦ä¹ æ”¶è·ï¼Œæ„Ÿè°¢æ”¶å¬ï¼Œæ­å–œä½ å·²ç»å®Œæˆäº†rustå­¦ä¹ çš„40æ¬¡æ‰“å¡ï¼Œå¦‚æœè§‰å¾—æœ‰æ”¶è·ï¼Œä¹Ÿæ¬¢è¿åˆ†äº«ç»™ä½ èº«è¾¹çš„æœ‹å‹ï¼Œé‚€ä»–ä¸€èµ·è®¨è®ºã€‚æˆ‘ä»¬ä¸‹èŠ‚è¯¾è§ã€‚
<div><strong>ç²¾é€‰ç•™è¨€ï¼ˆ7ï¼‰</strong></div><ul>
<li><span>ç½—åŒå­¦</span> ğŸ‘ï¼ˆ4ï¼‰ ğŸ’¬ï¼ˆ2ï¼‰<p>è¿˜æ˜¯æ²¡ææ‡‚è¿™å‡ ä¸ªæ¥å£çš„æ„ä¹‰ï¼Œæˆ‘åœ¨ç»¿è‰²çº¿ç¨‹é‡Œç”¨åŒæ­¥çš„å½¢å¼å¤„ç†ioï¼Œç„¶åå†é€šè¿‡channel ç­‰æ–¹å¼åˆ†äº«å‡ºå»æ•°æ®ï¼Œä¸æ˜¯ä¹Ÿå¯ä»¥å—ï¼Ÿè¿™å‡ ä¸ªå¼‚æ­¥ioçš„æ¥å£æ˜¯ä¸æ˜¯æœ‰ç‚¹å¤šä½™ï¼Ÿæˆ–è€…æ˜¯ä»€ä¹ˆåœºæ™¯ä¸‹ä½¿ç”¨ï¼Ÿ
</p>2021-12-01</li><br/><li><span>ä¹Œé¾™çŒ¹</span> ğŸ‘ï¼ˆ4ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>2021å¹´å°±å‰©ä¸‹æœ€åä¸€ä¸ªæœˆ  é™ˆè€å¸ˆçš„è¯¾ä¹Ÿå³å°†å®Œç»“  æ‰€å¹¸2021å¹´è·Ÿéšé™ˆè€å¸ˆçš„è¯¾ç¨‹å¯¹ rust æœ‰äº†ä¸€ä¸ªåˆæ­¥çš„äº†è§£  å¸Œæœ›æ¥å¹´èƒ½ç”¨rust åšç‚¹å•¥  æå‰é¢„å®šè€å¸ˆçš„ elixir è¯¾ç¨‹ </p>2021-12-01</li><br/><li><span>Rex Wang</span> ğŸ‘ï¼ˆ1ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>å›ç­”ä¸€ä¸‹ä¸Šè¾¹ trait Sink å’Œ trait AsyncWrite çš„åŒºåˆ«ï¼Œç»“åˆä¸‹ä¸€è®²å¯ä»¥çœ‹å‡ºã€‚Sink æ˜¯æœ‰ä¸€ä¸ªæ³›å‹ Item çš„æŠ½è±¡çš„ï¼Œä¹Ÿå°±æ˜¯å¯ä»¥æŠŠä»»æ„ç±»å‹â€œå†™â€å…¥ï¼›è€Œ AsyncWrite åªä½œç”¨äº [u8].</p>2022-11-25</li><br/><li><span>worm</span> ğŸ‘ï¼ˆ1ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>ä¸ºä»€ä¹ˆè¦ç”¨sink trait,ç›´æ¥ä½¿ç”¨asyncWriteæœ‰ä»€ä¹ˆä¸å¥½å—ï¼Œæ²¡ææ‡‚</p>2022-01-28</li><br/><li><span>overheat</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>Streamå¥½åƒå·²ç»ç¨³å®šä¸‹æ¥äº†ï¼Œæ²¡æœ‰çœ‹åˆ°nightlyçš„æç¤ºäº†</p>2022-09-04</li><br/><li><span>Geek_676746</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>AsyncRead æ˜¯ç¬¬ä¸‰æ–¹çš„traitï¼Œæ²¡å¿…è¦è®¨è®ºå§</p>2022-04-05</li><br/><li><span>è‰¯å¸ˆç›Šå‹</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>ä»è¿™ç¯‡å¼€å§‹ï¼Œå˜å¾—è¶…éš¾</p>2021-12-07</li><br/>
</ul>