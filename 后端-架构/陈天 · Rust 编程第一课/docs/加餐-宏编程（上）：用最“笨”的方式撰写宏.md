ä½ å¥½ï¼Œæˆ‘æ˜¯é™ˆå¤©ã€‚

å­¦è¿‡ä¸Šä¸€è®²ï¼Œç›¸ä¿¡ä½ ç°åœ¨åº”è¯¥ç†è§£ä¸ºä»€ä¹ˆåœ¨è¯¾ç¨‹çš„[ç¬¬ 6 è®²](https://time.geekbang.org/column/article/414478)æˆ‘ä»¬è¯´ï¼Œå®çš„æœ¬è´¨å…¶å®å¾ˆç®€å•ï¼ŒæŠ›å¼€ quote/unquoteï¼Œå®ç¼–ç¨‹ä¸»è¦çš„å·¥ä½œå°±æ˜¯æŠŠä¸€æ£µè¯­æ³•æ ‘è½¬æ¢æˆå¦ä¸€é¢—è¯­æ³•æ ‘ï¼Œè€Œè¿™ä¸ªè½¬æ¢çš„è¿‡ç¨‹æ·±å…¥ä¸‹å»ï¼Œä¸è¿‡å°±æ˜¯æ•°æ®ç»“æ„åˆ°æ•°æ®ç»“æ„çš„è½¬æ¢ã€‚

é‚£åœ¨Rusté‡Œå®åˆ°åº•æ˜¯å¦‚ä½•åšåˆ°è½¬æ¢çš„å‘¢ï¼Ÿ

æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°±ä¸€èµ·å°è¯•æ„å»ºå£°æ˜å®å’Œè¿‡ç¨‹å®ã€‚å¸Œæœ›ä½ èƒ½ä»è‡ªå·±æ’°å†™çš„è¿‡ç¨‹ä¸­ï¼Œæ„Ÿå—æ„å»ºå®çš„è¿‡ç¨‹ä¸­åšæ•°æ®è½¬æ¢çš„æ€è·¯å’Œæ–¹æ³•ï¼ŒæŒæ¡äº†è¿™ä¸ªæ–¹æ³•ï¼Œä½ å¯ä»¥åº”å¯¹å‡ ä¹æ‰€æœ‰å’Œå®ç¼–ç¨‹æœ‰å…³çš„é—®é¢˜ã€‚

## å¦‚ä½•æ„å»ºå£°æ˜å®

é¦–å…ˆçœ‹å£°æ˜å®æ˜¯å¦‚ä½•åˆ›å»ºçš„ã€‚

æˆ‘ä»¬ `cargo new macros --lib` åˆ›å»ºä¸€ä¸ªæ–°çš„é¡¹ç›®ï¼Œç„¶ååœ¨æ–°ç”Ÿæˆçš„é¡¹ç›®ä¸‹ï¼Œåˆ›å»º examples ç›®å½•ï¼Œæ·»åŠ  examples/rule.rsï¼ˆ[ä»£ç ](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=13d255537f5bae59fb83a205373b1ff7)ï¼‰ï¼š

```rust
#[macro_export]
macro_rules! my_vec {
    // æ²¡å¸¦ä»»ä½•å‚æ•°çš„ my_vecï¼Œæˆ‘ä»¬åˆ›å»ºä¸€ä¸ªç©ºçš„ vec
    () => {
        std::vec::Vec::new()
    };
    // å¤„ç† my_vec![1, 2, 3, 4]
    ($($el:expr),*) => ({
        let mut v = std::vec::Vec::new();
        $(v.push($el);)*
        v
    });
    // å¤„ç† my_vec![0; 10]
    ($el:expr; $n:expr) => {
        std::vec::from_elem($el, $n)
    }
}

fn main() {
    let mut v = my_vec![];
    v.push(1);
    // è°ƒç”¨æ—¶å¯ä»¥ä½¿ç”¨ [], (), {}
    let _v = my_vec!(1, 2, 3, 4);
    let _v = my_vec![1, 2, 3, 4];
    let v = my_vec! {1, 2, 3, 4};
    println!("{:?}", v);

    println!("{:?}", v);
    //
    let v = my_vec![1; 10];
    println!("{:?}", v);
}
```

ä¸Šä¸€è®²æˆ‘ä»¬è¯´è¿‡å¯¹äºå£°æ˜å®å¯ä»¥ç”¨ `macro_rules!` ç”Ÿæˆã€‚macro\_rules ä½¿ç”¨æ¨¡å¼åŒ¹é…ï¼Œæ‰€ä»¥ä½ å¯ä»¥æä¾›å¤šä¸ªåŒ¹é…æ¡ä»¶ä»¥åŠåŒ¹é…åå¯¹åº”æ‰§è¡Œçš„ä»£ç å—ã€‚

çœ‹è¿™æ®µä»£ç ï¼Œæˆ‘ä»¬å†™äº†3ä¸ªåŒ¹é…çš„rulesã€‚

ç¬¬ä¸€ä¸ª `() => (std::vec::Vec::new())` å¾ˆå¥½ç†è§£ï¼Œå¦‚æœæ²¡æœ‰ä¼ å…¥ä»»ä½•å‚æ•°ï¼Œå°±åˆ›å»ºä¸€ä¸ªæ–°çš„ Vecã€‚æ³¨æ„ï¼Œç”±äºå®è¦åœ¨è°ƒç”¨çš„åœ°æ–¹å±•å¼€ï¼Œæˆ‘ä»¬æ— æ³•é¢„æµ‹è°ƒç”¨è€…çš„ç¯å¢ƒæ˜¯å¦å·²ç»åšäº†ç›¸å…³çš„ useï¼Œæ‰€ä»¥æˆ‘ä»¬ä½¿ç”¨çš„ä»£ç æœ€å¥½å¸¦ç€å®Œæ•´çš„å‘½åç©ºé—´ã€‚

**è¿™ç¬¬äºŒä¸ªåŒ¹é…æ¡ä»¶ `($($el:expr),*)`ï¼Œéœ€è¦è¯¦ç»†ä»‹ç»ä¸€ä¸‹**ã€‚

åœ¨å£°æ˜å®ä¸­ï¼Œæ¡ä»¶æ•è·çš„å‚æ•°ä½¿ç”¨ $ å¼€å¤´çš„æ ‡è¯†ç¬¦æ¥å£°æ˜ã€‚æ¯ä¸ªå‚æ•°éƒ½éœ€è¦æä¾›ç±»å‹ï¼Œè¿™é‡Œ expr ä»£è¡¨è¡¨è¾¾å¼ï¼Œæ‰€ä»¥ `$el:expr` æ˜¯è¯´æŠŠåŒ¹é…åˆ°çš„è¡¨è¾¾å¼å‘½åä¸º `$el`ã€‚`$(...),*` å‘Šè¯‰ç¼–è¯‘å™¨å¯ä»¥åŒ¹é…ä»»æ„å¤šä¸ªä»¥é€—å·åˆ†éš”çš„è¡¨è¾¾å¼ï¼Œç„¶åæ•è·åˆ°çš„æ¯ä¸€ä¸ªè¡¨è¾¾å¼å¯ä»¥ç”¨ `$el` æ¥è®¿é—®ã€‚

ç”±äºåŒ¹é…çš„æ—¶å€™åŒ¹é…åˆ°ä¸€ä¸ª `$(...)*` ï¼ˆæˆ‘ä»¬å¯ä»¥ä¸ç®¡åˆ†éš”ç¬¦ï¼‰ï¼Œåœ¨æ‰§è¡Œçš„ä»£ç å—ä¸­ï¼Œæˆ‘ä»¬ä¹Ÿè¦ç›¸åº”åœ°ä½¿ç”¨ `$(...)*` å±•å¼€ã€‚æ‰€ä»¥è¿™å¥ `$(v.push($el);)*` ç›¸å½“äºåŒ¹é…å‡ºå¤šå°‘ä¸ª `$el`å°±å±•å¼€å¤šå°‘å¥ push è¯­å¥ã€‚

ç†è§£äº†ç¬¬äºŒä¸ªåŒ¹é…æ¡ä»¶ï¼Œç¬¬ä¸‰ä¸ªå°±å¾ˆå¥½ç†è§£äº†ï¼šå¦‚æœä¼ å…¥ç”¨å†’å·åˆ†éš”çš„ä¸¤ä¸ªè¡¨è¾¾å¼ï¼Œé‚£ä¹ˆä¼šç”¨ from\_element æ„å»º Vecã€‚

åœ¨ä½¿ç”¨å£°æ˜å®æ—¶ï¼Œæˆ‘ä»¬éœ€è¦ä¸ºå‚æ•°æ˜ç¡®ç±»å‹ï¼Œå“ªäº›ç±»å‹å¯ç”¨ä¹Ÿæ•´ç†åœ¨è¿™é‡Œäº†ï¼š

- `item`ï¼Œæ¯”å¦‚ä¸€ä¸ªå‡½æ•°ã€ç»“æ„ä½“ã€æ¨¡å—ç­‰ã€‚
- `block`ï¼Œä»£ç å—ã€‚æ¯”å¦‚ä¸€ç³»åˆ—ç”±èŠ±æ‹¬å·åŒ…è£¹çš„è¡¨è¾¾å¼å’Œè¯­å¥ã€‚
- `stmt`ï¼Œè¯­å¥ã€‚æ¯”å¦‚ä¸€ä¸ªèµ‹å€¼è¯­å¥ã€‚
- `pat`ï¼Œæ¨¡å¼ã€‚
- `expr`ï¼Œè¡¨è¾¾å¼ã€‚åˆšæ‰çš„ä¾‹å­ä½¿ç”¨è¿‡äº†ã€‚
- `ty`ï¼Œç±»å‹ã€‚æ¯”å¦‚ Vecã€‚
- `ident`ï¼Œæ ‡è¯†ç¬¦ã€‚æ¯”å¦‚ä¸€ä¸ªå˜é‡åã€‚
- `path`ï¼Œè·¯å¾„ã€‚æ¯”å¦‚ï¼š`foo`ã€`::std::mem::replace`ã€`transmute::<_,Â int>`ã€‚
- `meta`ï¼Œå…ƒæ•°æ®ã€‚ä¸€èˆ¬æ˜¯åœ¨ `#[...]`Â å’ŒÂ `#![...]`Â å±æ€§å†…éƒ¨çš„æ•°æ®ã€‚
- `tt`ï¼Œå•ä¸ªçš„ token æ ‘ã€‚
- `vis`ï¼Œå¯èƒ½ä¸ºç©ºçš„ä¸€ä¸ªÂ `Visibility`Â ä¿®é¥°ç¬¦ã€‚æ¯”å¦‚ pubã€pub(crate)ã€‚

å£°æ˜å®æ„å»ºèµ·æ¥å¾ˆç®€å•ï¼Œ**åªè¦éµå¾ªå®ƒçš„åŸºæœ¬è¯­æ³•ï¼Œä½ å¯ä»¥å¾ˆå¿«æŠŠä¸€ä¸ªå‡½æ•°æˆ–è€…ä¸€äº›é‡å¤çš„è¯­å¥ç‰‡æ®µè½¬æ¢æˆå£°æ˜å®**ã€‚

æ¯”å¦‚åœ¨å¤„ç† pipeline æ—¶ï¼Œæˆ‘ç»å¸¸ä¼šæ ¹æ®æŸä¸ªè¿”å› Result çš„è¡¨è¾¾å¼çš„ç»“æœï¼Œåšä¸‹é¢ä»£ç é‡Œè¿™æ ·çš„ matchï¼Œä½¿å…¶åœ¨å‡ºé”™æ—¶è¿”å› PipelineError è¿™ä¸ª enum è€Œé Resultï¼š

```rust
match result {
    Ok(v) => v,
    Err(e) => {
        return pipeline::PlugResult::Err {
            ctx,
            err: pipeline::PipelineError::Internal(e.to_string()),
        }
    }
}
```

ä½†æ˜¯è¿™ç§å†™æ³•ï¼Œåœ¨åŒä¸€ä¸ªå‡½æ•°å†…ï¼Œå¯èƒ½ä¼šåå¤å‡ºç°ï¼Œæˆ‘ä»¬åˆæ— æ³•ç”¨å‡½æ•°å°†å…¶å°è£…ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç”¨å£°æ˜å®æ¥å®ç°ï¼Œå¯ä»¥å¤§å¤§ç®€åŒ–ä»£ç ï¼š

```rust
#[macro_export]
macro_rules! try_with {
    ($ctx:ident, $exp:expr) => {
        match $exp {
            Ok(v) => v,
            Err(e) => {
                return pipeline::PlugResult::Err {
                    ctx: $ctx,
                    err: pipeline::PipelineError::Internal(e.to_string()),
                }
            }
        }
    };
}
```

## å¦‚ä½•æ„å»ºè¿‡ç¨‹å®

æ¥ä¸‹æ¥æˆ‘ä»¬è®²è®²å¦‚ä½•æ„å»ºè¿‡ç¨‹å®ã€‚

è¿‡ç¨‹å®è¦æ¯”å£°æ˜å®è¦å¤æ‚å¾ˆå¤šï¼Œä¸è¿‡æ— è®ºæ˜¯å“ªä¸€ç§è¿‡ç¨‹å®ï¼Œ**æœ¬è´¨éƒ½æ˜¯ä¸€æ ·çš„ï¼Œéƒ½æ¶‰åŠè¦æŠŠè¾“å…¥çš„ TokenStream å¤„ç†æˆè¾“å‡ºçš„ TokenStream**ã€‚

è¦æ„å»ºè¿‡ç¨‹å®ï¼Œä½ éœ€è¦å•ç‹¬æ„å»ºä¸€ä¸ª crateï¼Œåœ¨ Cargo.toml ä¸­æ·»åŠ  proc-macro çš„å£°æ˜ï¼š

```rust
[lib]
proc-macro = true
```

è¿™æ ·ï¼Œç¼–è¯‘å™¨æ‰å…è®¸ä½ ä½¿ç”¨ `#[proc_macro]` ç›¸å…³çš„å®ã€‚æ‰€ä»¥æˆ‘ä»¬å…ˆåœ¨ä»Šå¤©è¿™å ‚è¯¾ç”Ÿæˆçš„ crate çš„ Cargo.toml ä¸­æ·»åŠ è¿™ä¸ªå£°æ˜ï¼Œç„¶ååœ¨ [lib.rs](http://lib.rs) é‡Œå†™å…¥å¦‚ä¸‹ä»£ç ï¼š

```rust
use proc_macro::TokenStream;

#[proc_macro]
pub fn query(input: TokenStream) -> TokenStream {
    println!("{:#?}", input);
    "fn hello() { println!(\\"Hello world!\\"); }"
        .parse()
        .unwrap()
}
```

è¿™æ®µä»£ç é¦–å…ˆå£°æ˜äº†å®ƒæ˜¯ä¸€ä¸ª proc\_macroï¼Œå¹¶ä¸”æ˜¯æœ€åŸºæœ¬çš„ã€å‡½æ•°å¼çš„è¿‡ç¨‹å®ã€‚

ä½¿ç”¨è€…å¯ä»¥é€šè¿‡ `query!(...)` æ¥è°ƒç”¨ã€‚æˆ‘ä»¬æ‰“å°ä¼ å…¥çš„ [TokenStream](https://doc.rust-lang.org/proc_macro/struct.TokenStream.html)ï¼Œç„¶åæŠŠä¸€æ®µåŒ…å«åœ¨å­—ç¬¦ä¸²ä¸­çš„ä»£ç è§£ææˆ TokenStream è¿”å›ã€‚è¿™é‡Œå¯ä»¥éå¸¸æ–¹ä¾¿åœ°ç”¨å­—ç¬¦ä¸²çš„ parse() æ–¹æ³•æ¥è·å¾— TokenStreamï¼Œæ˜¯å› ä¸º TokenStream å®ç°äº† [FromStr](https://doc.rust-lang.org/std/str/trait.FromStr.html) traitï¼Œæ„Ÿè°¢Rustã€‚

å¥½ï¼Œæ˜ç™½è¿™æ®µä»£ç åšäº†ä»€ä¹ˆï¼Œæˆ‘ä»¬å†™ä¸ªä¾‹å­å°è¯•ä½¿ç”¨ä¸€ä¸‹ï¼Œæ¥åˆ›å»º examples/query.rsï¼Œå¹¶å†™å…¥ä»£ç ï¼š

```rust
use macros::query;

fn main() {
    query!(SELECT * FROM users WHERE age > 10);
}
```

å¯ä»¥çœ‹åˆ°ï¼Œå°½ç®¡ `SELECT * FROM user WHERE age > 10` ä¸æ˜¯ä¸€ä¸ªåˆæ³•çš„ Rust è¯­æ³•ï¼Œä½† Rust çš„è¯æ³•åˆ†æå™¨è¿˜æ˜¯æŠŠå®ƒè§£ææˆäº† TokenStreamï¼Œæä¾›ç»™ query å®ã€‚

è¿è¡Œ `cargo run --example query`ï¼Œçœ‹ query å®å¯¹è¾“å…¥ TokenStream çš„æ‰“å°ï¼š

```rust
TokenStream [
    Ident {
        ident: "SELECT",
        span: #0 bytes(43..49),
    },
    Punct {
        ch: '*',
        spacing: Alone,
        span: #0 bytes(50..51),
    },
    Ident {
        ident: "FROM",
        span: #0 bytes(52..56),
    },
    Ident {
        ident: "users",
        span: #0 bytes(57..62),
    },
    Ident {
        ident: "WHERE",
        span: #0 bytes(63..68),
    },
    Ident {
        ident: "age",
        span: #0 bytes(69..72),
    },
    Punct {
        ch: '>',
        spacing: Alone,
        span: #0 bytes(73..74),
    },
    Literal {
        kind: Integer,
        symbol: "10",
        suffix: None,
        span: #0 bytes(75..77),
    },
]
```

è¿™é‡Œé¢ï¼ŒTokenStream æ˜¯ä¸€ä¸ª Iteratorï¼Œé‡Œé¢åŒ…å«ä¸€ç³»åˆ—çš„ [TokenTree](https://doc.rust-lang.org/proc_macro/enum.TokenTree.html)ï¼š

```rust
pub enum TokenTree {
    Group(Group),
    Ident(Ident),
    Punct(Punct),
    Literal(Literal),
}
```

åä¸‰ä¸ªåˆ†åˆ«æ˜¯ Identï¼ˆæ ‡è¯†ç¬¦ï¼‰ã€Punctï¼ˆæ ‡ç‚¹ç¬¦å·ï¼‰å’Œ Literalï¼ˆå­—é¢é‡ï¼‰ã€‚è¿™é‡Œçš„Groupï¼ˆç»„ï¼‰ï¼Œæ˜¯å› ä¸ºå¦‚æœä½ çš„ä»£ç ä¸­åŒ…å«æ‹¬å·ï¼Œæ¯”å¦‚`{} [] <> ()` ï¼Œé‚£ä¹ˆå†…éƒ¨çš„å†…å®¹ä¼šè¢«åˆ†ææˆä¸€ä¸ª Groupï¼ˆç»„ï¼‰ã€‚ä½ ä¹Ÿå¯ä»¥è¯•è¯•æŠŠä¾‹å­ä¸­å¯¹ `query!` çš„è°ƒç”¨æ”¹æˆè¿™ä¸ªæ ·å­ï¼š

```rust
query!(SELECT * FROM users u JOIN (SELECT * from profiles p) WHERE u.id = p.id and u.age > 10);
```

å†è¿è¡Œä¸€ä¸‹ `cargo run --example query`ï¼Œçœ‹çœ‹ç°åœ¨çš„ TokenStream é•¿ä»€ä¹ˆæ ·å­ï¼Œæ˜¯å¦åŒ…å« Groupã€‚

å¥½ï¼Œç°åœ¨æˆ‘ä»¬å¯¹è¾“å…¥çš„ TokenStream æœ‰äº†ä¸€ä¸ªæ¦‚å¿µï¼Œé‚£ä¹ˆï¼Œè¾“å‡ºçš„ TokenStream æœ‰ä»€ä¹ˆç”¨å‘¢ï¼Ÿæˆ‘ä»¬çš„ `query!` å®è¿”å›äº†ä¸€ä¸ª `hello()` å‡½æ•°çš„ TokenStreamï¼Œè¿™ä¸ªå‡½æ•°çœŸçš„å¯ä»¥ç›´æ¥è°ƒç”¨ä¹ˆï¼Ÿ

ä½ å¯ä»¥è¯•è¯•åœ¨ main() é‡ŒåŠ å…¥å¯¹ hello() çš„è°ƒç”¨ï¼Œå†æ¬¡è¿è¡Œè¿™ä¸ª exampleï¼Œå¯ä»¥çœ‹åˆ°ä¹…è¿çš„ â€œHello world!â€ æ‰“å°ã€‚

æ­å–œä½ ï¼ä½ çš„ç¬¬ä¸€ä¸ªè¿‡ç¨‹å®å°±å®Œæˆäº†ï¼

è™½ç„¶è¿™å¹¶ä¸æ˜¯ä»€ä¹ˆäº†ä¸èµ·çš„ç»“æœï¼Œä½†æ˜¯é€šè¿‡å®ƒï¼Œæˆ‘ä»¬è®¤è¯†åˆ°äº†è¿‡ç¨‹å®çš„åŸºæœ¬å†™æ³•ï¼Œä»¥åŠTokenStream / TokenTree çš„åŸºæœ¬ç»“æ„ã€‚

æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°±å°è¯•å®ç°ä¸€ä¸ªæ´¾ç”Ÿå®ï¼Œè¿™æ˜¯è¿‡ç¨‹å®çš„ä¸‰ç±»å®ä¸­å¯¹å¤§å®¶æœ€æœ‰æ„ä¹‰çš„ä¸€ç±»ï¼Œä¹Ÿæ˜¯å·¥ä½œä¸­å¦‚æœéœ€è¦å†™è¿‡ç¨‹å®ä¸»è¦ä¼šç”¨åˆ°çš„å®ç±»å‹ã€‚

## å¦‚ä½•æ„å»ºæ´¾ç”Ÿå®

æˆ‘ä»¬æœŸæœ›æ„å»ºä¸€ä¸ª Builder æ´¾ç”Ÿå®ï¼Œå®ç° [proc-macro-workshop](https://github.com/dtolnay/proc-macro-workshop) é‡Œ[å¦‚ä¸‹éœ€æ±‚](https://github.com/dtolnay/proc-macro-workshop/blob/master/builder/tests/06-optional-field.rs)ï¼ˆproc-macro-workshopæ˜¯ Rust å¤§ç‰› David Tolnay ä¸ºå¸®åŠ©å¤§å®¶æ›´å¥½åœ°å­¦ä¹ å®ç¼–ç¨‹æ„å»ºçš„ç»ƒä¹ ï¼‰ï¼š

```rust
#[derive(Builder)]
pub struct Command {
    executable: String,
    args: Vec<String>,
    env: Vec<String>,
    current_dir: Option<String>,
}

fn main() {
    let command = Command::builder()
        .executable("cargo".to_owned())
        .args(vec!["build".to_owned(), "--release".to_owned()])
        .env(vec![])
        .build()
        .unwrap();
    assert!(command.current_dir.is_none());

    let command = Command::builder()
        .executable("cargo".to_owned())
        .args(vec!["build".to_owned(), "--release".to_owned()])
        .env(vec![])
        .current_dir("..".to_owned())
        .build()
        .unwrap();
    assert!(command.current_dir.is_some());
}
```

å¯ä»¥çœ‹åˆ°ï¼Œæˆ‘ä»¬ä»…ä»…æ˜¯ä¸º Command è¿™ä¸ªç»“æ„æä¾›äº† Builder å®ï¼Œå°±è®©å®ƒæ”¯æŒ builder() æ–¹æ³•ï¼Œè¿”å›äº†ä¸€ä¸ª CommandBuilder ç»“æ„ï¼Œè¿™ä¸ªç»“æ„æœ‰è‹¥å¹²ä¸ªå’Œ Command å†…éƒ¨æ¯ä¸ªåŸŸåå­—ç›¸åŒçš„æ–¹æ³•ï¼Œæˆ‘ä»¬å¯ä»¥é“¾å¼è°ƒç”¨è¿™äº›æ–¹æ³•ï¼Œæœ€å build() å‡ºä¸€ä¸ª Command ç»“æ„ã€‚

æˆ‘ä»¬åˆ›å»ºä¸€ä¸ª examples/command.rsï¼ŒæŠŠè¿™éƒ¨åˆ†ä»£ç æ·»åŠ è¿›å»ã€‚æ˜¾ç„¶ï¼Œå®ƒæ˜¯æ— æ³•ç¼–è¯‘é€šè¿‡çš„ã€‚ä¸‹é¢å…ˆæ¥æ‰‹å·¥æ’°å†™å¯¹åº”çš„ä»£ç ï¼Œçœ‹çœ‹ä¸€ä¸ªå®Œæ•´çš„ã€èƒ½å¤Ÿè®© main() æ­£ç¡®è¿è¡Œçš„ä»£ç é•¿ä»€ä¹ˆæ ·å­ï¼š

```rust
#[allow(dead_code)]
#[derive(Debug)]
pub struct Command {
    executable: String,
    args: Vec<String>,
    env: Vec<String>,
    current_dir: Option<String>,
}

#[derive(Debug, Default)]
pub struct CommandBuilder {
    executable: Option<String>,
    args: Option<Vec<String>>,
    env: Option<Vec<String>>,
    current_dir: Option<String>,
}

impl Command {
    pub fn builder() -> CommandBuilder {
        Default::default()
    }
}

impl CommandBuilder {
    pub fn executable(mut self, v: String) -> Self {
        self.executable = Some(v.to_owned());
        self
    }

    pub fn args(mut self, v: Vec<String>) -> Self {
        self.args = Some(v.to_owned());
        self
    }

    pub fn env(mut self, v: Vec<String>) -> Self {
        self.env = Some(v.to_owned());
        self
    }

    pub fn current_dir(mut self, v: String) -> Self {
        self.current_dir = Some(v.to_owned());
        self
    }

    pub fn build(mut self) -> Result<Command, &'static str> {
        Ok(Command {
            executable: self.executable.take().ok_or("executable must be set")?,
            args: self.args.take().ok_or("args must be set")?,
            env: self.env.take().ok_or("env must be set")?,
            current_dir: self.current_dir.take(),
        })
    }
}

fn main() {
    let command = Command::builder()
        .executable("cargo".to_owned())
        .args(vec!["build".to_owned(), "--release".to_owned()])
        .env(vec![])
        .build()
        .unwrap();
    assert!(command.current_dir.is_none());

    let command = Command::builder()
        .executable("cargo".to_owned())
        .args(vec!["build".to_owned(), "--release".to_owned()])
        .env(vec![])
        .current_dir("..".to_owned())
        .build()
        .unwrap();
    assert!(command.current_dir.is_some());
    println!("{:?}", command);
} 
```

è¿™ä¸ªä»£ç å¾ˆç®€å•ï¼ŒåŸºæœ¬å°±æ˜¯ç…§ç€ main() ä¸­çš„ä½¿ç”¨æ–¹æ³•ï¼Œä¸€ä¸ªå‡½æ•°ä¸€ä¸ªå‡½æ•°æ‰‹å†™å‡ºæ¥çš„ï¼Œä½ å¯ä»¥çœ‹åˆ°ä»£ç ä¸­å¾ˆå¤šé‡å¤çš„éƒ¨åˆ†ï¼Œå°¤å…¶æ˜¯ CommandBuilder é‡Œçš„æ–¹æ³•ï¼Œè¿™æ˜¯æˆ‘ä»¬å¯ä»¥ç”¨å®æ¥è‡ªåŠ¨ç”Ÿæˆçš„ã€‚

é‚£æ€ä¹ˆç”Ÿæˆè¿™æ ·çš„ä»£ç å‘¢ï¼Ÿæ˜¾ç„¶ï¼Œæˆ‘ä»¬è¦æŠŠè¾“å…¥çš„ TokenStreamæŠ½å–å‡ºæ¥ï¼Œä¹Ÿå°±æ˜¯æŠŠåœ¨ struct çš„å®šä¹‰å†…éƒ¨ï¼Œæ¯ä¸ªåŸŸçš„åå­—åŠå…¶ç±»å‹éƒ½æŠ½å‡ºæ¥ï¼Œç„¶åç”Ÿæˆå¯¹åº”çš„æ–¹æ³•ä»£ç ã€‚

**å¦‚æœæŠŠä»£ç çœ‹åšæ˜¯å­—ç¬¦ä¸²çš„è¯ï¼Œä¸éš¾æƒ³è±¡åˆ°ï¼Œå®é™…ä¸Šå°±æ˜¯è¦é€šè¿‡ä¸€ä¸ªæ¨¡æ¿å’Œå¯¹åº”çš„æ•°æ®ï¼Œç”Ÿæˆæˆ‘ä»¬æƒ³è¦çš„ç»“æœ**ã€‚ç”¨æ¨¡æ¿ç”Ÿæˆ HTMLï¼Œæƒ³å¿…å„ä½éƒ½ä¸é™Œç”Ÿï¼Œä½†é€šè¿‡æ¨¡æ¿ç”Ÿæˆ Rust ä»£ç ï¼Œä¼°è®¡ä½ æ˜¯ç¬¬ä¸€æ¬¡ã€‚

æœ‰äº†è¿™ä¸ªæ€è·¯ï¼Œæˆ‘ä»¬å°è¯•ç€ç”¨ [jinja](https://jinja.palletsprojects.com/en/3.0.x/) å†™ä¸€ä¸ªç”Ÿæˆ CommandBuilder ç»“æ„çš„æ¨¡æ¿ã€‚åœ¨ Rust é‡Œï¼Œæˆ‘ä»¬æœ‰ [askma](https://github.com/djc/askama) è¿™ä¸ªéå¸¸é«˜æ•ˆçš„åº“æ¥å¤„ç† jinjaã€‚æ¨¡æ¿å¤§æ¦‚é•¿è¿™ä¸ªæ ·å­ï¼š

```rust
#[derive(Debug, Default)]
pub struct {{ builder_name }} {
    {% for field in fields %}
    {{ field.name }}: Option<{{ field.ty }}>,
    {% endfor %}
}
```

è¿™é‡Œçš„ fileds / builder\_name æ˜¯æˆ‘ä»¬è¦ä¼ å…¥çš„å‚æ•°ï¼Œæ¯ä¸ª field è¿˜éœ€è¦ name å’Œ ty ä¸¤ä¸ªå±æ€§ï¼Œåˆ†åˆ«å¯¹åº” field çš„åå­—å’Œç±»å‹ã€‚æˆ‘ä»¬ä¹Ÿå¯ä»¥ä¸ºè¿™ä¸ªç»“æ„ç”Ÿæˆæ–¹æ³•ï¼š

```rust
impl {{ builder_name }} {
    {% for field in fields %}
    pub fn {{ field.name }}(mut self, v: impl Into<{{ field.ty }}>) -> {{ builder_name }} {
        self.{{ field.name }} = Some(v.into());
        self
    }
    {% endfor %}

    pub fn build(self) -> Result<{{ name }}, &'static str> {
        Ok({{ name }} {
            {% for field in fields %}
            {% if field.optional %}
            {{ field.name }}: self.{{ field.name }},
            {% else %}
            {{ field.name }}: self.{{ field.name }}.ok_or("Build failed: missing {{ field.name }}")?,
            {% endif %}
            {% endfor %}
        })
    }
}
```

å¯¹äºåŸæœ¬æ˜¯ Option&lt;T&gt; ç±»å‹çš„åŸŸï¼Œè¦é¿å…ç”Ÿæˆ Option&lt;Option&gt;ï¼Œæˆ‘ä»¬éœ€è¦æŠŠæ˜¯å¦æ˜¯ Option å•ç‹¬æŠ½å–å‡ºæ¥ï¼Œå¦‚æœæ˜¯ Option&lt;T&gt;ï¼Œé‚£ä¹ˆ ty å°±æ˜¯ Tã€‚æ‰€ä»¥ï¼Œfield è¿˜éœ€è¦ä¸€ä¸ªå±æ€§ optionalã€‚

æœ‰äº†è¿™ä¸ªæ€è·¯ï¼Œæˆ‘ä»¬å¯ä»¥æ„å»ºè‡ªå·±çš„æ•°æ®ç»“æ„æ¥æè¿° Fieldï¼š

```rust
#[derive(Debug, Default)]
struct Fd {
    name: String,
    ty: String,
    optional: bool,
}
```

**å½“æˆ‘ä»¬æœ‰äº†æ¨¡æ¿ï¼Œåˆå®šä¹‰å¥½äº†ä¸ºæ¨¡æ¿æä¾›æ•°æ®çš„ç»“æ„ï¼Œæ¥ä¸‹æ¥è¦å¤„ç†çš„æ ¸å¿ƒé—®é¢˜å°±æ˜¯ï¼šå¦‚ä½•ä» TokenStream ä¸­æŠ½å–å‡ºæ¥æˆ‘ä»¬æƒ³è¦çš„ä¿¡æ¯**ï¼Ÿ

å¸¦ç€è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬åœ¨ [lib.rs](http://lib.rs) é‡Œæ·»åŠ ä¸€ä¸ª derive macroï¼ŒæŠŠ input æ‰“å°å‡ºæ¥ï¼š

```rust
#[proc_macro_derive(RawBuilder)]
pub fn derive_raw_builder(input: TokenStream) -> TokenStream {
    println!("{:#?}", input);
    TokenStream::default()
}
```

å¯¹äº derive macroï¼Œè¦ä½¿ç”¨ `proce_macro_derive` è¿™ä¸ªå®ã€‚æˆ‘ä»¬æŠŠè¿™ä¸ª derive macro å‘½åä¸º RawBuilderã€‚åœ¨ examples/command.rs ä¸­ï¼Œæˆ‘ä»¬ä¿®æ”¹ Command ç»“æ„ï¼Œä½¿å…¶ä½¿ç”¨ RawBuilderï¼ˆæ³¨æ„è¦ use macros::RawBuilderï¼‰ï¼š

```rust
use macros::RawBuilder;

#[allow(dead_code)]
#[derive(Debug, RawBuilder)]
pub struct Command {
    ...
}
```

è¿è¡Œè¿™ä¸ª example åï¼Œæˆ‘ä»¬ä¼šçœ‹åˆ°ä¸€å¤§ç‰‡ TokenStream çš„æ‰“å°ï¼ˆæ¯”è¾ƒé•¿è¿™é‡Œå°±ä¸è´´äº†ï¼‰ï¼Œä»”ç»†é˜…è¯»è¿™ä¸ªæ‰“å°ï¼Œå¯ä»¥çœ‹åˆ°ï¼š

- é¦–å…ˆæœ‰ä¸€ä¸ª Groupï¼ŒåŒ…å«äº† `#[allow(dead_code)]` å±æ€§çš„ä¿¡æ¯ã€‚å› ä¸ºæˆ‘ä»¬ç°åœ¨æ‹¿åˆ°çš„ derive ä¸‹çš„ä¿¡æ¯ï¼Œæ‰€ä»¥æ‰€æœ‰ä¸å±äº `#[derive(...)]` çš„å±æ€§ï¼Œéƒ½ä¼šè¢«æ”¾å…¥ TokenStream ä¸­ã€‚
- ä¹‹åæ˜¯ pub / struct / Command ä¸‰ä¸ª identã€‚
- éšååˆæ˜¯ä¸€ä¸ª Groupï¼ŒåŒ…å«äº†æ¯ä¸ª field çš„ä¿¡æ¯ã€‚æˆ‘ä»¬çœ‹åˆ°ï¼Œfield ä¹‹é—´ç”¨é€—å·è¿™ä¸ª Punct åˆ†éš”ï¼Œfield çš„åå­—å’Œç±»å‹åˆæ˜¯é€šè¿‡å†’å·è¿™ä¸ª Punct åˆ†éš”ã€‚è€Œç±»å‹ï¼Œå¯èƒ½æ˜¯ä¸€ä¸ª Identï¼Œå¦‚ Stringï¼Œæˆ–è€…ä¸€ç³»åˆ— Ident / Punctï¼Œå¦‚ Vec / &lt; / String / &gt;ã€‚

**æˆ‘ä»¬è¦åšçš„å°±æ˜¯ï¼ŒæŠŠè¿™ä¸ª TokenStream ä¸­çš„ struct åå­—ï¼Œä»¥åŠæ¯ä¸ª field çš„åå­—å’Œç±»å‹æ‹¿å‡ºæ¥**ã€‚å¦‚æœç±»å‹æ˜¯ Option&lt;T&gt;ï¼Œé‚£ä¹ˆæŠŠ T æ‹¿å‡ºæ¥ï¼ŒæŠŠ optional è®¾ç½®ä¸º trueã€‚

å¥½ï¼Œæœ‰äº†è¿™ä¸ªæ€è·¯ï¼Œæ¥å†™ä»£ç ã€‚é¦–å…ˆåœ¨ Cargo.toml ä¸­å¼•å…¥ä¸€äº›ä¾èµ–ï¼š

```rust
[dependencies]
anyhow = "1"
askama = "0.11" # å¤„ç† jinjia æ¨¡æ¿ï¼Œæ¨¡æ¿éœ€è¦æ”¾åœ¨å’Œ src å¹³è¡Œçš„ templates ç›®å½•ä¸‹
```

akama è¦æ±‚æ¨¡æ¿æ”¾åœ¨å’Œ src å¹³è¡Œçš„ templates ç›®å½•ä¸‹ï¼Œåˆ›å»ºè¿™ä¸ªç›®å½•ï¼Œç„¶åå†™å…¥ templates/builder.j2ï¼š

```rust
impl {{ name }} {
    pub fn builder() -> {{ builder_name }} {
        Default::default()
    }
}

#[derive(Debug, Default)]
pub struct {{ builder_name }} {
    {% for field in fields %}
        {{ field.name }}: Option<{{ field.ty }}>,
    {% endfor %}
}

impl {{ builder_name }} {
    {% for field in fields %}
    pub fn {{ field.name }}(mut self, v: impl Into<{{ field.ty }}>) -> {{ builder_name }} {
        self.{{ field.name }} = Some(v.into());
        self
    }
    {% endfor %}

    pub fn build(self) -> Result<{{ name }}, &'static str> {
        Ok({{ name }} {
            {% for field in fields %}
                {% if field.optional %}
                {{ field.name }}: self.{{ field.name }},
                {% else %}
                {{ field.name }}: self.{{ field.name }}.ok_or("Build failed: missing {{ field.name }}")?,
                {% endif %}
            {% endfor %}
        })
    }
}
```

ç„¶ååˆ›å»º src/raw\_builder.rsï¼ˆè®°å¾—åœ¨ [lib.rs](http://lib.rs) ä¸­å¼•å…¥ï¼‰ï¼Œå†™å…¥ä»£ç ï¼Œè¿™æ®µä»£ç æˆ‘åŠ äº†è¯¦ç»†çš„æ³¨é‡Šï¼Œä½ å¯ä»¥å¯¹ç€æ‰“å°å‡ºæ¥çš„ TokenStreamå’Œåˆšæ‰çš„åˆ†æï¼Œç›¸ä¿¡ä¸éš¾ç†è§£ã€‚

```rust
use anyhow::Result;
use askama::Template;
use proc_macro::{Ident, TokenStream, TokenTree};
use std::collections::VecDeque;

/// å¤„ç† jinja æ¨¡æ¿çš„æ•°æ®ç»“æ„ï¼Œåœ¨æ¨¡æ¿ä¸­æˆ‘ä»¬ä½¿ç”¨äº† name / builder_name / fields
#[derive(Template)]
#[template(path = "builder.j2", escape = "none")]
pub struct BuilderContext {
    name: String,
    builder_name: String,
    fields: Vec<Fd>,
}

/// æè¿° struct çš„æ¯ä¸ª field
#[derive(Debug, Default)]
struct Fd {
    name: String,
    ty: String,
    optional: bool,
}

impl Fd {
    /// name å’Œ field éƒ½æ˜¯é€šè¿‡å†’å· Punct åˆ‡åˆ†å‡ºæ¥çš„ TokenTree åˆ‡ç‰‡
    pub fn new(name: &[TokenTree], ty: &[TokenTree]) -> Self {
        // æŠŠç±»ä¼¼ Ident("Option"), Punct('<'), Ident("String"), Punct('>) çš„ ty
        // æ”¶é›†æˆä¸€ä¸ª String åˆ—è¡¨ï¼Œå¦‚ vec!["Option", "<", "String", ">"]
        let ty = ty
            .iter()
            .map(|v| match v {
                TokenTree::Ident(n) => n.to_string(),
                TokenTree::Punct(p) => p.as_char().to_string(),
                e => panic!("Expect ident, got {:?}", e),
            })
            .collect::<Vec<_>>();
        // å†’å·å‰æœ€åä¸€ä¸ª TokenTree æ˜¯ field çš„åå­—
        // æ¯”å¦‚ï¼šexecutable: String,
        // æ³¨æ„è¿™é‡Œä¸åº”è¯¥ç”¨ name[0]ï¼Œå› ä¸ºæœ‰å¯èƒ½æ˜¯ pub executable: String
        // ç”šè‡³ï¼Œå¸¦ attributes çš„ fieldï¼Œ
        // æ¯”å¦‚ï¼š#[builder(hello = world)] pub executable: String
        match name.last() {
            Some(TokenTree::Ident(name)) => {
                // å¦‚æœ ty ç¬¬ 0 é¡¹æ˜¯ Optionï¼Œé‚£ä¹ˆä»ç¬¬äºŒé¡¹å–åˆ°å€’æ•°ç¬¬ä¸€é¡¹
                // å–å®Œåä¸Šé¢çš„ä¾‹å­ä¸­çš„ ty ä¼šå˜æˆ ["String"]ï¼Œoptiona = true
                let (ty, optional) = if ty[0].as_str() == "Option" {
                    (&ty[2..ty.len() - 1], true)
                } else {
                    (&ty[..], false)
                };
                Self {
                    name: name.to_string(),
                    ty: ty.join(""), // æŠŠ ty join æˆå­—ç¬¦ä¸²
                    optional,
                }
            }
            e => panic!("Expect ident, got {:?}", e),
        }
    }
}

impl BuilderContext {
    /// ä» TokenStream ä¸­æå–ä¿¡æ¯ï¼Œæ„å»º BuilderContext
    fn new(input: TokenStream) -> Self {
        let (name, input) = split(input);
        let fields = get_struct_fields(input);
        Self {
            builder_name: format!("{}Builder", name),
            name: name.to_string(),
            fields,
        }
    }

    /// æŠŠæ¨¡æ¿æ¸²æŸ“æˆå­—ç¬¦ä¸²ä»£ç 
    pub fn render(input: TokenStream) -> Result<String> {
        let template = Self::new(input);
        Ok(template.render()?)
    }
}

/// æŠŠ TokenStream åˆ†å‡º struct çš„åå­—ï¼Œå’ŒåŒ…å« fields çš„ TokenStream
fn split(input: TokenStream) -> (Ident, TokenStream) {
    let mut input = input.into_iter().collect::<VecDeque<_>>();
    // ä¸€ç›´å¾€åæ‰¾ï¼Œæ‰¾åˆ° struct åœä¸‹æ¥
    while let Some(item) = input.pop_front() {
        if let TokenTree::Ident(v) = item {
            if v.to_string() == "struct" {
                break;
            }
        }
    }

    // struct åé¢ï¼Œåº”è¯¥æ˜¯ struct name
    let ident;
    if let Some(TokenTree::Ident(v)) = input.pop_front() {
        ident = v;
    } else {
        panic!("Didn't find struct name");
    }

    // struct åé¢å¯èƒ½è¿˜æœ‰è‹¥å¹² TokenTreeï¼Œæˆ‘ä»¬ä¸ç®¡ï¼Œä¸€è·¯æ‰¾åˆ°ç¬¬ä¸€ä¸ª Group
    let mut group = None;
    for item in input {
        if let TokenTree::Group(g) = item {
            group = Some(g);
            break;
        }
    }

    (ident, group.expect("Didn't find field group").stream())
}

/// ä»åŒ…å« fields çš„ TokenStream ä¸­åˆ‡å‡ºæ¥ä¸€ä¸ªä¸ª Fd
fn get_struct_fields(input: TokenStream) -> Vec<Fd> {
    let input = input.into_iter().collect::<Vec<_>>();
    input
        .split(|v| match v {
            // å…ˆç”¨ ',' åˆ‡å‡ºæ¥ä¸€ä¸ªä¸ªåŒ…å« field æ‰€æœ‰ä¿¡æ¯çš„ &[TokenTree]
            TokenTree::Punct(p) => p.as_char() == ',',
            _ => false,
        })
        .map(|tokens| {
            tokens
                .split(|v| match v {
                    // å†ç”¨ ':' æŠŠ &[TokenTree] åˆ‡æˆ [&[TokenTree], &[TokenTree]]
                    // å®ƒä»¬åˆ†åˆ«å¯¹åº”åå­—å’Œç±»å‹
                    TokenTree::Punct(p) => p.as_char() == ':',
                    _ => false,
                })
                .collect::<Vec<_>>()
        })
        // æ­£å¸¸æƒ…å†µä¸‹ï¼Œåº”è¯¥å¾—åˆ° [&[TokenTree], &[TokenTree]]ï¼Œå¯¹äºåˆ‡å‡ºæ¥é•¿åº¦ä¸ä¸º 2 çš„ç»Ÿç»Ÿè¿‡æ»¤æ‰
        .filter(|tokens| tokens.len() == 2)
        // ä½¿ç”¨ Fd::new åˆ›å»ºå‡ºæ¯ä¸ª Fd
        .map(|tokens| Fd::new(tokens[0], &tokens[1]))
        .collect()
}
```

æ ¸å¿ƒçš„å°±æ˜¯ get\_struct\_fields() æ–¹æ³•ï¼Œå¦‚æœä½ è§‰å¾—éš¾æ‡‚ï¼Œå¯ä»¥æƒ³æƒ³å¦‚æœä½ è¦æŠŠä¸€ä¸ª `a=1,b=2` çš„å­—ç¬¦ä¸²åˆ‡æˆ `[[a, 1], [b, 2]]` è¯¥æ€ä¹ˆåšï¼Œå°±å¾ˆå®¹æ˜“ç†è§£äº†ã€‚

å¥½ï¼Œå®Œæˆäº†æŠŠ TokenStream è½¬æ¢æˆ BuilderContext çš„ä»£ç ï¼Œ**æ¥ä¸‹æ¥å°±æ˜¯åœ¨ proc\_macro ä¸­ä½¿ç”¨è¿™ä¸ªç»“æ„ä»¥åŠå®ƒçš„ render æ–¹æ³•**ã€‚æˆ‘ä»¬æŠŠ [lib.rs](http://lib.rs) ä¸­çš„ä»£ç ä¿®æ”¹ä¸€ä¸‹ï¼ˆæ³¨æ„æ·»åŠ ç›¸å…³çš„ useï¼‰ï¼š

```rust
#[proc_macro_derive(RawBuilder)]
pub fn derive_raw_builder(input: TokenStream) -> TokenStream {
    BuilderContext::render(input).unwrap().parse().unwrap()
}
```

ä¿å­˜åï¼Œä½ ç«‹åˆ»ä¼šå‘ç°ï¼ŒVS Code æŠ±æ€¨ examples/command.rs ç¼–è¯‘ä¸è¿‡ï¼Œå› ä¸ºé‡Œé¢æœ‰é‡å¤çš„æ•°æ®ç»“æ„å’Œæ–¹æ³•çš„å®šä¹‰ã€‚æˆ‘ä»¬æŠŠä¹‹å‰æ‰‹å·¥ç”Ÿæˆçš„ä»£ç å…¨éƒ¨åˆ æ‰ï¼Œåªä¿ç•™ï¼š

```rust
use macros::RawBuilder;

#[allow(dead_code)]
#[derive(Debug, RawBuilder)]
pub struct Command {
    executable: String,
    args: Vec<String>,
    env: Vec<String>,
    current_dir: Option<String>,
}

fn main() {
    let command = Command::builder()
        .executable("cargo".to_owned())
        .args(vec!["build".to_owned(), "--release".to_owned()])
        .env(vec![])
        .build()
        .unwrap();
    assert!(command.current_dir.is_none());

    let command = Command::builder()
        .executable("cargo".to_owned())
        .args(vec!["build".to_owned(), "--release".to_owned()])
        .env(vec![])
        .current_dir("..".to_owned())
        .build()
        .unwrap();
    assert!(command.current_dir.is_some());
    println!("{:?}", command);
}
```

è¿è¡Œä¹‹ï¼Œæˆ‘ä»¬æ’°å†™çš„ RawBuilder å®èµ·ä½œç”¨äº†ï¼ä»£ç è¿è¡Œä¸€åˆ‡æ­£å¸¸ï¼

## å°ç»“

è¿™ä¸€è®²æˆ‘ä»¬ç®€å•ä»‹ç»äº† Rust å®ç¼–ç¨‹çš„èƒ½åŠ›ï¼Œå¹¶æ’°å†™äº†ä¸€ä¸ªå£°æ˜å® my\_vec! å’Œä¸€ä¸ªæ´¾ç”Ÿå® RawBuilderã€‚é€šè¿‡è‡ªå·±æ‰‹å†™ï¼Œæ ¸å¿ƒå°±æ˜¯è¦ç†è§£æ¸…æ¥šå®åšæ•°æ®è½¬æ¢çš„æ–¹æ³•ï¼šå¦‚ä½•ä» TokenStream ä¸­æŠ½å–éœ€è¦çš„æ•°æ®ï¼Œç„¶åç”ŸæˆåŒ…å«ç›®æ ‡ä»£ç çš„å­—ç¬¦ä¸²ï¼Œæœ€åå†æŠŠå­—ç¬¦ä¸²è½¬æ¢æˆ TokenStreamã€‚

åœ¨æ„å»º RawBuilder çš„è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬è¿˜äº†è§£äº† TokenStream å’Œ TokenTreeï¼Œè™½ç„¶è¿™ä¸¤ä¸ªæ•°æ®ç»“æ„æ˜¯ Rust ä¸‹çš„ç»“æ„ï¼Œä½†æ˜¯ token stream / token tree è¿™æ ·çš„æ¦‚å¿µæ˜¯æ¯ä¸ªæ”¯æŒå®çš„è¯­è¨€å…±æœ‰çš„ï¼Œå¦‚æœä½ ç†è§£äº† Rust çš„å®ç¼–ç¨‹ï¼Œé‚£ä¹ˆå­¦ä¹ å…¶ä»–è¯­è¨€çš„å®ç¼–ç¨‹å°±å¾ˆå®¹æ˜“äº†ã€‚

åœ¨æ‰‹å†™çš„è¿‡ç¨‹ä¸­ï¼Œä½ å¯èƒ½ä¼šè§‰å¾—å®ç¼–ç¨‹è¿‡äºç¹çï¼Œè¿™æ˜¯å› ä¸ºè§£æ TokenStream æ˜¯ä¸€ä¸ªè‹¦åŠ›æ´»ï¼Œè¦å’Œå„ç§å„æ ·çš„æƒ…å†µæ‰“äº¤é“ï¼Œå¦‚æœå¤„ç†ä¸å¥½ï¼Œå°±å¾ˆå®¹æ˜“å‡ºé”™ã€‚

é‚£åœ¨Rustç”Ÿæ€ä¸‹æœ‰æ²¡æœ‰äººå·²ç»åšè¿‡è¿™ä¸ªè‹¦åŠ›æ´»äº†å‘¢ï¼Ÿæˆ‘ä»¬ä¸‹èŠ‚è¯¾ç»§ç»­â€¦â€¦

### æ€è€ƒé¢˜

æœ€åå‡ºä¸ªæ€è€ƒé¢˜ç»™ä½ ç»ƒç»ƒæ‰‹ã€‚å·¥ä½œä¸­ï¼Œæœ‰å¾ˆå¤šåœºæ™¯æˆ‘ä»¬éœ€è¦é€šè¿‡ç¬¬ä¸‰æ–¹çš„ schema æ¥ç”Ÿæˆ Rust æ•°æ®ç»“æ„ï¼Œæ¯”å¦‚ protobuf çš„å®šä¹‰åˆ° Rust struct/enum çš„è½¬æ¢ã€‚è¿™äº›è½¬æ¢å¦‚æœæ‰‹å·¥æ’°å†™çš„è¯ï¼Œæ˜¯çº¯ç²¹çš„ä½“åŠ›æ´»ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡å®æ¥ç®€åŒ–è¿™ä¸ªæ“ä½œã€‚

å‡è®¾ä½ çš„å…¬å¸ç»´æŠ¤äº†å¤§é‡çš„ openapi v3 specï¼Œéœ€è¦ä½ é€šè¿‡å®ƒæ¥ç”Ÿæˆ Rust ç±»å‹ï¼Œæ¯”å¦‚è¿™é‡Œçš„ schema å®šä¹‰ï¼ˆ[æ¥æº](https://gist.github.com/danielflower/5c5ae8a46a0a49aee508690c19b33ada#file-petstore-json-L833-L869)ï¼‰ï¼š

```rust
{
  "type": "object",
  "properties": {
    "id": {
      "type": "integer",
      "format": "int64"
    },
    "petId": {
      "type": "integer",
      "format": "int64"
    },
    "quantity": {
      "type": "integer",
      "format": "int32"
    },
    "shipDate": {
      "type": "string",
      "format": "date-time"
    },
    "status": {
      "type": "string",
      "description": "Order Status",
      "enum": [
        "placed",
        "approved",
        "delivered"
      ]
    },
    "complete": {
      "type": "boolean",
      "default": false
    }
  },
  "xml": {
    "name": "Order"
  }
}
```

ä½ å¯ä»¥è¯•ç€ä½¿ç”¨ä»Šå¤©æ‰€å­¦å†…å®¹ï¼Œæ’°å†™ä¸€ä¸ª `generate!` å®ï¼Œæ¥å—ä¸€ä¸ªåŒ…å« schema å®šä¹‰çš„æ–‡ä»¶åï¼Œç”Ÿæˆ schemaã€‚å¦‚æœä½ é‡åˆ°é—®é¢˜å¡å£³äº†ï¼Œå¯ä»¥å‚è€ƒBç«™ä¸Šæˆ‘live codingçš„[è§†é¢‘](https://www.bilibili.com/video/BV1Za411q7LQ/)ã€‚

æ¬¢è¿åœ¨ç•™è¨€åŒºè®¨è®ºä½ çš„æƒ³æ³•ï¼Œå¦‚æœè§‰å¾—æœ‰æ”¶è·ï¼Œä¹Ÿæ¬¢è¿ä½ åˆ†äº«ç»™èº«è¾¹çš„æœ‹å‹ï¼Œé‚€ä»–ä¸€èµ·è®¨è®ºã€‚æˆ‘ä»¬ä¸‹èŠ‚è¯¾è§ã€‚
<div><strong>ç²¾é€‰ç•™è¨€ï¼ˆ6ï¼‰</strong></div><ul>
<li><span>pedro</span> ğŸ‘ï¼ˆ3ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>å€¼ï¼</p>2022-01-25</li><br/><li><span>Geek_4df987</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>å¦‚æœä¼ å…¥ç”¨å†’å·åˆ†éš”çš„ä¸¤ä¸ªè¡¨è¾¾å¼
é”™åˆ«å­—ï¼šåº”è¯¥æ˜¯ç”¨ â€œåˆ†å·â€ åˆ†éš”</p>2023-09-28</li><br/><li><span>Geek_4df987</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>å¦ä¸€é¢—è¯­æ³•æ ‘
é”™åˆ«å­—</p>2023-09-28</li><br/><li><span>å­”ç¥¥æ—­</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ2ï¼‰<p>æ‚¨å¥½, æˆ‘è¿è¡Œç¨‹åºä¹‹å, query!(xxxxx)å¹¶æ²¡æœ‰è¾“å‡ºä»»ä½•ä¿¡æ¯, è¿™æ˜¯æ€ä¹ˆä¸€å›äº‹, æˆ‘åœ¨å®çš„ä¸Šé¢å’Œä¸‹é¢å®šä¹‰äº†println(&quot;1&quot;), å‡æœ‰è¾“å‡º</p>2023-06-12</li><br/><li><span>è®°äº‹æœ¬</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>é™ˆè€å¸ˆï¼Œæ— æ³•è¯†åˆ«use proc_macro::{TokenStream} unresolved import å…‹éš†ä½ ä»“åº“çš„ä»£ç éƒ½ä¸€æ ·
</p>2022-03-05</li><br/><li><span>è®°äº‹æœ¬</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>æ¸…æ¥š</p>2022-03-05</li><br/>
</ul>