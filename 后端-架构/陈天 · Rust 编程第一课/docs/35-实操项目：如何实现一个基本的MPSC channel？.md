ä½ å¥½ï¼Œæˆ‘æ˜¯é™ˆå¤©ã€‚

é€šè¿‡ä¸Šä¸¤è®²çš„å­¦ä¹ ï¼Œç›¸ä¿¡ä½ å·²ç»æ„è¯†åˆ°ï¼Œè™½ç„¶å¹¶å‘åŸè¯­çœ‹ä¸Šå»æ˜¯å¾ˆåº•å±‚ã€å¾ˆç¥ç§˜çš„ä¸œè¥¿ï¼Œä½†å®ç°èµ·æ¥ä¹Ÿå¹¶ä¸åƒæƒ³è±¡ä¸­çš„é‚£ä¹ˆå›°éš¾ï¼Œå°¤å…¶æ˜¯åœ¨ Rust ä¸‹ï¼Œåœ¨[ç¬¬ 33 è®²](https://time.geekbang.org/column/article/442216)ä¸­ï¼Œæˆ‘ä»¬ç”¨äº†å‡ åè¡Œä»£ç å°±å®ç°äº†ä¸€ä¸ªç®€å•çš„ SpinLockã€‚

ä½ ä¹Ÿè®¸ä¼šè§‰å¾—ä¸å¤ªè¿‡ç˜¾ï¼Œè€Œä¸” SpinLock ä¹Ÿä¸æ˜¯ç»å¸¸ä½¿ç”¨çš„å¹¶å‘åŸè¯­ï¼Œé‚£ä¹ˆä»Šå¤©ï¼Œæˆ‘ä»¬è¯•ç€å®ç°ä¸€ä¸ªä½¿ç”¨éå¸¸å¹¿æ³›çš„ MPSC channel å¦‚ä½•ï¼Ÿ

ä¹‹å‰æˆ‘ä»¬è°ˆè®ºäº†å¦‚ä½•åœ¨æœç´¢å¼•æ“çš„ Index writer ä¸Šä½¿ç”¨ MPSC channelï¼šè¦æ›´æ–° index çš„ä¸Šä¸‹æ–‡æœ‰å¾ˆå¤šï¼ˆå¯ä»¥æ˜¯çº¿ç¨‹ä¹Ÿå¯ä»¥æ˜¯å¼‚æ­¥ä»»åŠ¡ï¼‰ï¼Œè€Œ IndexWriter åªèƒ½æ˜¯å”¯ä¸€çš„ã€‚ä¸ºäº†é¿å…åœ¨è®¿é—® IndexWriter æ—¶åŠ é”ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ MPSC channelï¼Œåœ¨å¤šä¸ªä¸Šä¸‹æ–‡ä¸­ç»™ channel å‘æ¶ˆæ¯ï¼Œç„¶ååœ¨å”¯ä¸€æ‹¥æœ‰ IndexWriter çš„çº¿ç¨‹ä¸­è¯»å–è¿™äº›æ¶ˆæ¯ï¼Œéå¸¸é«˜æ•ˆã€‚

å¥½ï¼Œæ¥çœ‹çœ‹ä»Šå¤©è¦å®ç°çš„ MPSC channel çš„åŸºæœ¬åŠŸèƒ½ã€‚ä¸ºäº†ç®€ä¾¿èµ·è§ï¼Œæˆ‘ä»¬åªå…³å¿ƒ unbounded MPSC channelã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå½“é˜Ÿåˆ—å®¹é‡ä¸å¤Ÿæ—¶ï¼Œä¼šè‡ªåŠ¨æ‰©å®¹ï¼Œæ‰€ä»¥ï¼Œ**ä»»ä½•æ—¶å€™ç”Ÿäº§è€…å†™å…¥æ•°æ®éƒ½ä¸ä¼šè¢«é˜»å¡ï¼Œä½†æ˜¯å½“é˜Ÿåˆ—ä¸­æ²¡æœ‰æ•°æ®æ—¶ï¼Œæ¶ˆè´¹è€…ä¼šè¢«é˜»å¡**ï¼š  
![](https://static001.geekbang.org/resource/image/cf/a2/cfb839fc9c21f9ec51930c063f0ffda2.jpg?wh=2364x1355)

## æµ‹è¯•é©±åŠ¨çš„è®¾è®¡

ä¹‹å‰æˆ‘ä»¬ä¼šä»éœ€æ±‚çš„è§’åº¦æ¥è®¾è®¡æ¥å£å’Œæ•°æ®ç»“æ„ï¼Œä»Šå¤©æˆ‘ä»¬å°±æ¢ç§æ–¹å¼ï¼Œå®Œå…¨ç«™åœ¨ä½¿ç”¨è€…çš„è§’åº¦ï¼Œç”¨ä½¿ç”¨å®ä¾‹ï¼ˆæµ‹è¯•ï¼‰æ¥é©±åŠ¨æ¥å£å’Œæ•°æ®ç»“æ„çš„è®¾è®¡ã€‚

### éœ€æ±‚ 1

è¦å®ç°åˆšæ‰è¯´çš„ MPSC channelï¼Œéƒ½æœ‰ä»€ä¹ˆéœ€æ±‚å‘¢ï¼Ÿé¦–å…ˆï¼Œç”Ÿäº§è€…å¯ä»¥äº§ç”Ÿæ•°æ®ï¼Œæ¶ˆè´¹è€…èƒ½å¤Ÿæ¶ˆè´¹äº§ç”Ÿå‡ºæ¥çš„æ•°æ®ï¼Œä¹Ÿå°±æ˜¯åŸºæœ¬çš„ send/recvï¼Œæˆ‘ä»¬ä»¥ä¸‹é¢è¿™ä¸ªå•å…ƒæµ‹è¯• 1 æ¥æè¿°è¿™ä¸ªéœ€æ±‚ï¼š

```rust
#[test]
fn channel_should_work() {
    let (mut s, mut r) = unbounded();
    s.send("hello world!".to_string()).unwrap();
    let msg = r.recv().unwrap();
    assert_eq!(msg, "hello world!");
}
```

è¿™é‡Œï¼Œé€šè¿‡ unbounded() æ–¹æ³•ï¼Œ å¯ä»¥åˆ›å»ºä¸€ä¸ª senderå’Œä¸€ä¸ª receiverï¼Œsender æœ‰ send() æ–¹æ³•ï¼Œå¯ä»¥å‘é€æ•°æ®ï¼Œreceiver æœ‰ recv() æ–¹æ³•ï¼Œå¯ä»¥æ¥å—æ•°æ®ã€‚æ•´ä½“çš„æ¥å£ï¼Œæˆ‘ä»¬è®¾è®¡å’Œ [std::sync::mpsc](https://doc.rust-lang.org/std/sync/mpsc/index.html) ä¿æŒä¸€è‡´ï¼Œé¿å…ä½¿ç”¨è€…ä½¿ç”¨ä¸Šçš„å¿ƒæ™ºè´Ÿæ‹…ã€‚

ä¸ºäº†å®ç°è¿™æ ·ä¸€ä¸ªæ¥å£ï¼Œéœ€è¦ä»€ä¹ˆæ ·çš„æ•°æ®ç»“æ„å‘¢ï¼Ÿé¦–å…ˆï¼Œç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…ä¹‹é—´ä¼šå…±äº«ä¸€ä¸ªé˜Ÿåˆ—ï¼Œä¸Šä¸€è®²æˆ‘ä»¬è¯´åˆ°ï¼Œå¯ä»¥ç”¨ VecDequeã€‚æ˜¾ç„¶ï¼Œè¿™ä¸ªé˜Ÿåˆ—åœ¨æ’å…¥å’Œå–å‡ºæ•°æ®æ—¶éœ€è¦äº’æ–¥ï¼Œæ‰€ä»¥éœ€è¦ç”¨ Mutex æ¥ä¿æŠ¤å®ƒã€‚æ‰€ä»¥ï¼Œæˆ‘ä»¬å¤§æ¦‚å¯ä»¥å¾—åˆ°è¿™æ ·ä¸€ä¸ªç»“æ„ï¼š

```rust
struct Shared<T> {
    queue: Mutex<VecDeque<T>>,
}

pub struct Sender<T> {
    shared: Arc<Shared<T>>,
}

pub struct Receiver<T> {
    shared: Arc<Shared<T>>,
}
```

è¿™æ ·çš„æ•°æ®ç»“æ„åº”è¯¥å¯ä»¥æ»¡è¶³å•å…ƒæµ‹è¯• 1ã€‚

### éœ€æ±‚ 2

ç”±äºéœ€è¦çš„æ˜¯ MPSCï¼Œæ‰€ä»¥ï¼Œæˆ‘ä»¬å…è®¸å¤šä¸ª sender å¾€ channel é‡Œå‘é€æ•°æ®ï¼Œç”¨å•å…ƒæµ‹è¯• 2 æ¥æè¿°è¿™ä¸ªéœ€æ±‚ï¼š

```rust
#[test]
fn multiple_senders_should_work() {
    let (mut s, mut r) = unbounded();
    let mut s1 = s.clone();
    let mut s2 = s.clone();
    let t = thread::spawn(move || {
        s.send(1).unwrap();
    });
    let t1 = thread::spawn(move || {
        s1.send(2).unwrap();
    });
    let t2 = thread::spawn(move || {
        s2.send(3).unwrap();
    });
    for handle in [t, t1, t2] {
        handle.join().unwrap();
    }

    let mut result = [r.recv().unwrap(), r.recv().unwrap(), r.recv().unwrap()];
    // åœ¨è¿™ä¸ªæµ‹è¯•é‡Œï¼Œæ•°æ®åˆ°è¾¾çš„é¡ºåºæ˜¯ä¸ç¡®å®šçš„ï¼Œæ‰€ä»¥æˆ‘ä»¬æ’ä¸ªåºå† assert
    result.sort();

    assert_eq!(result, [1, 2, 3]);
}
```

è¿™ä¸ªéœ€æ±‚ï¼Œåˆšæ‰çš„æ•°æ®ç»“æ„å°±å¯ä»¥æ»¡è¶³ï¼Œåªæ˜¯ Sender éœ€è¦å®ç° Clone traitã€‚ä¸è¿‡æˆ‘ä»¬åœ¨å†™è¿™ä¸ªæµ‹è¯•çš„æ—¶å€™ç¨å¾®æœ‰äº›åˆ«æ‰­ï¼Œå› ä¸ºè¿™ä¸€è¡Œæœ‰ä¸æ–­é‡å¤çš„ä»£ç ï¼š

```rust
let mut result = [r.recv().unwrap(), r.recv().unwrap(), r.recv().unwrap()];
```

æ³¨æ„ï¼Œæµ‹è¯•ä»£ç çš„ DRY ä¹Ÿå¾ˆé‡è¦ï¼Œæˆ‘ä»¬ä¹‹å‰å¼ºè°ƒè¿‡ã€‚æ‰€ä»¥ï¼Œå½“å†™ä¸‹è¿™ä¸ªæµ‹è¯•çš„æ—¶å€™ï¼Œä¹Ÿè®¸ä¼šæƒ³ï¼Œæˆ‘ä»¬å¯å¦æä¾› Iterator çš„å®ç°ï¼Ÿæ©è¿™ä¸ªæƒ³æ³•å…ˆæš‚å­˜ä¸‹æ¥ã€‚

### éœ€æ±‚ 3

æ¥ä¸‹æ¥è€ƒè™‘å½“é˜Ÿåˆ—ç©ºçš„æ—¶å€™ï¼Œreceiver æ‰€åœ¨çš„çº¿ç¨‹ä¼šè¢«é˜»å¡è¿™ä¸ªéœ€æ±‚ã€‚é‚£ä¹ˆï¼Œå¦‚ä½•å¯¹è¿™ä¸ªéœ€æ±‚è¿›è¡Œæµ‹è¯•å‘¢ï¼Ÿè¿™å¹¶ä¸ç®€å•ï¼Œæˆ‘ä»¬æ²¡æœ‰æ¯”è¾ƒç›´è§‚çš„æ–¹å¼æ¥æ£€æµ‹çº¿ç¨‹çš„çŠ¶æ€ã€‚

**ä¸è¿‡ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡æ£€æµ‹â€œçº¿ç¨‹æ˜¯å¦é€€å‡ºâ€æ¥é—´æ¥åˆ¤æ–­çº¿ç¨‹æ˜¯å¦è¢«é˜»å¡**ã€‚ç†ç”±å¾ˆç®€å•ï¼Œå¦‚æœçº¿ç¨‹æ²¡æœ‰ç»§ç»­å·¥ä½œï¼Œåˆæ²¡æœ‰é€€å‡ºï¼Œé‚£ä¹ˆä¸€å®šè¢«é˜»å¡ä½äº†ã€‚é˜»å¡ä½ä¹‹åï¼Œæˆ‘ä»¬ç»§ç»­å‘é€æ•°æ®ï¼Œæ¶ˆè´¹è€…æ‰€åœ¨çš„çº¿ç¨‹ä¼šè¢«å”¤é†’ï¼Œç»§ç»­å·¥ä½œï¼Œæ‰€ä»¥æœ€ç»ˆé˜Ÿåˆ—é•¿åº¦åº”è¯¥ä¸º 0ã€‚æˆ‘ä»¬çœ‹å•å…ƒæµ‹è¯• 3ï¼š

```rust
#[test]
fn receiver_should_be_blocked_when_nothing_to_read() {
    let (mut s, r) = unbounded();
    let mut s1 = s.clone();
    thread::spawn(move || {
        for (idx, i) in r.into_iter().enumerate() {
            // å¦‚æœè¯»åˆ°æ•°æ®ï¼Œç¡®ä¿å®ƒå’Œå‘é€çš„æ•°æ®ä¸€è‡´
            assert_eq!(idx, i);
        }
        // è¯»ä¸åˆ°åº”è¯¥ä¼‘çœ ï¼Œæ‰€ä»¥ä¸ä¼šæ‰§è¡Œåˆ°è¿™ä¸€å¥ï¼Œæ‰§è¡Œåˆ°è¿™ä¸€å¥è¯´æ˜é€»è¾‘å‡ºé”™
        assert!(false);
    });

    thread::spawn(move || {
        for i in 0..100usize {
            s.send(i).unwrap();
        }
    });

    // 1ms è¶³å¤Ÿè®©ç”Ÿäº§è€…å‘å®Œ 100 ä¸ªæ¶ˆæ¯ï¼Œæ¶ˆè´¹è€…æ¶ˆè´¹å®Œ 100 ä¸ªæ¶ˆæ¯å¹¶é˜»å¡
    thread::sleep(Duration::from_millis(1));

    // å†æ¬¡å‘é€æ•°æ®ï¼Œå”¤é†’æ¶ˆè´¹è€…
    for i in 100..200usize {
        s1.send(i).unwrap();
    }

    // ç•™ç‚¹æ—¶é—´è®© receiver å¤„ç†
    thread::sleep(Duration::from_millis(1));

    // å¦‚æœ receiver è¢«æ­£å¸¸å”¤é†’å¤„ç†ï¼Œé‚£ä¹ˆé˜Ÿåˆ—é‡Œçš„æ•°æ®ä¼šéƒ½è¢«è¯»å®Œ
    assert_eq!(s1.total_queued_items(), 0);
}
```

è¿™ä¸ªæµ‹è¯•ä»£ç ä¸­ï¼Œæˆ‘ä»¬å‡å®š receiver å®ç°äº† Iteratorï¼Œè¿˜å‡å®š sender æä¾›äº†ä¸€ä¸ªæ–¹æ³•total\_queued\_items()ã€‚è¿™äº›å¯ä»¥åœ¨å®ç°çš„æ—¶å€™å†å¤„ç†ã€‚

ä½ å¯ä»¥èŠ±äº›æ—¶é—´ä»”ç»†çœ‹çœ‹è¿™æ®µä»£ç ï¼Œæƒ³æƒ³å…¶ä¸­çš„å¤„ç†é€»è¾‘ã€‚è™½ç„¶ä»£ç å¾ˆç®€å•ï¼Œä¸éš¾ç†è§£ï¼Œä½†æ˜¯æŠŠä¸€ä¸ªå®Œæ•´çš„éœ€æ±‚è½¬åŒ–æˆåˆé€‚çš„æµ‹è¯•ä»£ç ï¼Œè¿˜æ˜¯è¦é¢‡è´¹äº›å¿ƒæ€çš„ã€‚

å¥½ï¼Œå¦‚æœè¦èƒ½æ”¯æŒé˜Ÿåˆ—ä¸ºç©ºæ—¶é˜»å¡ï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨ [Condvar](https://doc.rust-lang.org/std/sync/struct.Condvar.html)ã€‚æ‰€ä»¥ Shared&lt;T&gt; éœ€è¦ä¿®æ”¹ä¸€ä¸‹ï¼š

```rust
struct Shared<T> {
    queue: Mutex<VecDeque<T>>,
    available: Condvar,
}
```

è¿™æ ·å½“å®ç° Receiver çš„ recv() æ–¹æ³•åï¼Œæˆ‘ä»¬å¯ä»¥åœ¨è¯»ä¸åˆ°æ•°æ®æ—¶é˜»å¡çº¿ç¨‹ï¼š

```rust
// æ‹¿åˆ°é”
let mut inner = self.shared.queue.lock().unwrap();
// ... å‡è®¾è¯»ä¸åˆ°æ•°æ®
// ä½¿ç”¨ condvar å’Œ MutexGuard é˜»å¡å½“å‰çº¿ç¨‹
self.shared.available.wait(inner)
```

### éœ€æ±‚ 4

é¡ºç€åˆšæ‰çš„å¤šä¸ª senderæƒ³ï¼Œå¦‚æœç°åœ¨æ‰€æœ‰ Sender éƒ½é€€å‡ºä½œç”¨åŸŸï¼ŒReceiver ç»§ç»­æ¥æ”¶ï¼Œåˆ°æ²¡æœ‰æ•°æ®å¯è¯»äº†ï¼Œè¯¥æ€ä¹ˆå¤„ç†ï¼Ÿæ˜¯ä¸æ˜¯åº”è¯¥äº§ç”Ÿä¸€ä¸ªé”™è¯¯ï¼Œè®©è°ƒç”¨è€…çŸ¥é“ï¼Œç°åœ¨ channel çš„å¦ä¸€ä¾§å·²ç»æ²¡æœ‰ç”Ÿäº§è€…äº†ï¼Œå†è¯»ä¹Ÿè¯»ä¸å‡ºæ•°æ®äº†ï¼Ÿ

æˆ‘ä»¬æ¥å†™å•å…ƒæµ‹è¯• 4ï¼š

```rust
#[test]
fn last_sender_drop_should_error_when_receive() {
    let (s, mut r) = unbounded();
    let s1 = s.clone();
    let senders = [s, s1];
    let total = senders.len();

    // sender å³ç”¨å³æŠ›
    for mut sender in senders {
        thread::spawn(move || {
            sender.send("hello").unwrap();
            // sender åœ¨æ­¤è¢«ä¸¢å¼ƒ
        })
        .join()
        .unwrap();
    }

    // è™½ç„¶æ²¡æœ‰ sender äº†ï¼Œæ¥æ”¶è€…ä¾ç„¶å¯ä»¥æ¥å—å·²ç»åœ¨é˜Ÿåˆ—é‡Œçš„æ•°æ®
    for _ in 0..total {
        r.recv().unwrap();
    }

    // ç„¶è€Œï¼Œè¯»å–æ›´å¤šæ•°æ®æ—¶ä¼šå‡ºé”™
    assert!(r.recv().is_err());
}
```

è¿™ä¸ªæµ‹è¯•ä¾æ—§å¾ˆç®€å•ã€‚ä½ å¯ä»¥æƒ³è±¡ä¸€ä¸‹ï¼Œä½¿ç”¨ä»€ä¹ˆæ ·çš„æ•°æ®ç»“æ„å¯ä»¥è¾¾åˆ°è¿™æ ·çš„ç›®çš„ã€‚

é¦–å…ˆï¼Œæ¯æ¬¡ Clone æ—¶ï¼Œè¦å¢åŠ  Sender çš„è®¡æ•°ï¼›åœ¨ Sender Drop æ—¶ï¼Œå‡å°‘è¿™ä¸ªè®¡æ•°ï¼›ç„¶åï¼Œæˆ‘ä»¬ä¸º Receiver æä¾›ä¸€ä¸ªæ–¹æ³• total\_senders()ï¼Œæ¥è¯»å– Sender çš„è®¡æ•°ï¼Œå½“è®¡æ•°ä¸º 0ï¼Œä¸”é˜Ÿåˆ—ä¸­æ²¡æœ‰æ•°æ®å¯è¯»æ—¶ï¼Œrecv() æ–¹æ³•å°±æŠ¥é”™ã€‚

æœ‰äº†è¿™ä¸ªæ€è·¯ï¼Œä½ æƒ³ä¸€æƒ³ï¼Œè¿™ä¸ªè®¡æ•°å™¨ç”¨ä»€ä¹ˆæ•°æ®ç»“æ„å‘¢ï¼Ÿç”¨é”ä¿æŠ¤ä¹ˆï¼Ÿ

å“ˆï¼Œä½ ä¸€å®šæƒ³åˆ°äº†å¯ä»¥ä½¿ç”¨ atomicsã€‚å¯¹ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ AtomicUsizeã€‚æ‰€ä»¥ï¼ŒShared æ•°æ®ç»“æ„éœ€è¦æ›´æ–°ä¸€ä¸‹ï¼š

```rust
struct Shared<T> {
    queue: Mutex<VecDeque<T>>,
    available: Condvar,
    senders: AtomicUsize,
}
```

### éœ€æ±‚ 5

æ—¢ç„¶æ²¡æœ‰ Sender äº†è¦æŠ¥é”™ï¼Œé‚£ä¹ˆå¦‚æœæ²¡æœ‰ Receiveräº†ï¼ŒSender å‘é€æ—¶æ˜¯ä¸æ˜¯ä¹Ÿåº”è¯¥é”™è¯¯è¿”å›ï¼Ÿè¿™ä¸ªéœ€æ±‚å’Œä¸Šé¢ç±»ä¼¼ï¼Œå°±ä¸èµ˜è¿°äº†ã€‚çœ‹æ„é€ çš„å•å…ƒæµ‹è¯• 5ï¼š

```rust
#[test]
fn receiver_drop_should_error_when_send() {
    let (mut s1, mut s2) = {
        let (s, _) = unbounded();
        let s1 = s.clone();
        let s2 = s.clone();
        (s1, s2)
    };

    assert!(s1.send(1).is_err());
    assert!(s2.send(1).is_err());
}
```

è¿™é‡Œï¼Œæˆ‘ä»¬åˆ›å»ºä¸€ä¸ª channelï¼Œäº§ç”Ÿä¸¤ä¸ª Sender åä¾¿ç«‹å³ä¸¢å¼ƒ Receiverã€‚ä¸¤ä¸ª Sender åœ¨å‘é€æ—¶éƒ½ä¼šå‡ºé”™ã€‚

åŒæ ·çš„ï¼ŒShared æ•°æ®ç»“æ„è¦æ›´æ–°ä¸€ä¸‹ï¼š

```rust
struct Shared<T> {
    queue: Mutex<VecDeque<T>>,
    available: Condvar,
    senders: AtomicUsize,
    receivers: AtomicUsize,
}
```

## å®ç° MPSC channel

ç°åœ¨å†™äº†äº”ä¸ªå•å…ƒæµ‹è¯•ï¼Œæˆ‘ä»¬å·²ç»æŠŠéœ€æ±‚æ‘¸é€äº†ï¼Œå¹¶ä¸”æœ‰äº†åŸºæœ¬çš„æ¥å£å’Œæ•°æ®ç»“æ„çš„è®¾è®¡ã€‚æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬æ¥å†™å®ç°çš„ä»£ç ã€‚

åˆ›å»ºä¸€ä¸ªæ–°çš„é¡¹ç›® `cargo new con_utils --lib`ã€‚åœ¨ cargo.toml ä¸­æ·»åŠ  anyhow ä½œä¸ºä¾èµ–ã€‚åœ¨ [lib.rs](http://lib.rs) é‡Œï¼Œæˆ‘ä»¬å°±å†™å…¥ä¸€å¥ï¼š`pub mod channel` , ç„¶ååˆ›å»º src/channel.rsï¼ŒæŠŠåˆšæ‰è®¾è®¡æ—¶ä½¿ç”¨çš„ test caseã€è®¾è®¡çš„æ•°æ®ç»“æ„ï¼Œä»¥åŠ test case é‡Œä½¿ç”¨åˆ°çš„æ¥å£ï¼Œç”¨ä»£ç å…¨éƒ¨æ”¾è¿›æ¥ï¼š

```rust
use anyhow::Result;
use std::{
    collections::VecDeque,
    sync::{atomic::AtomicUsize, Arc, Condvar, Mutex},
};

/// å‘é€è€…
pub struct Sender<T> {
    shared: Arc<Shared<T>>,
}

/// æ¥æ”¶è€…
pub struct Receiver<T> {
    shared: Arc<Shared<T>>,
}

/// å‘é€è€…å’Œæ¥æ”¶è€…ä¹‹é—´å…±äº«ä¸€ä¸ª VecDequeï¼Œç”¨ Mutex äº’æ–¥ï¼Œç”¨ Condvar é€šçŸ¥
/// åŒæ—¶ï¼Œæˆ‘ä»¬è®°å½•æœ‰å¤šå°‘ä¸ª senders å’Œ receivers

struct Shared<T> {
    queue: Mutex<VecDeque<T>>,
    available: Condvar,
    senders: AtomicUsize,
    receivers: AtomicUsize,
}

impl<T> Sender<T> {
    /// ç”Ÿäº§è€…å†™å…¥ä¸€ä¸ªæ•°æ®
    pub fn send(&mut self, t: T) -> Result<()> {
        todo!()
    }

    pub fn total_receivers(&self) -> usize {
        todo!()
    }

    pub fn total_queued_items(&self) -> usize {
        todo!()
    }
}

impl<T> Receiver<T> {
    pub fn recv(&mut self) -> Result<T> {
        todo!()
    }

    pub fn total_senders(&self) -> usize {
        todo!()
    }
}

impl<T> Iterator for Receiver<T> {
    type Item = T;

    fn next(&mut self) -> Option<Self::Item> {
        todo!()
    }
}

/// å…‹éš† sender
impl<T> Clone for Sender<T> {
    fn clone(&self) -> Self {
        todo!()
    }
}

/// Drop sender
impl<T> Drop for Sender<T> {
    fn drop(&mut self) {
        todo!()
    }
}

impl<T> Drop for Receiver<T> {
    fn drop(&mut self) {
        todo!()
    }
}

/// åˆ›å»ºä¸€ä¸ª unbounded channel
pub fn unbounded<T>() -> (Sender<T>, Receiver<T>) {
    todo!()
}

#[cfg(test)]
mod tests {
    use std::{thread, time::Duration};

    use super::*;
		// æ­¤å¤„çœç•¥æ‰€æœ‰ test case
}
```

ç›®å‰è¿™ä¸ªä»£ç è™½ç„¶èƒ½å¤Ÿç¼–è¯‘é€šè¿‡ï¼Œä½†å› ä¸ºæ²¡æœ‰ä»»ä½•å®ç°ï¼Œæ‰€ä»¥ cargo test å…¨éƒ¨å‡ºé”™ã€‚æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°±æ¥ä¸€ç‚¹ç‚¹å®ç°åŠŸèƒ½ã€‚

### åˆ›å»º unbounded channel

åˆ›å»º unbounded channel çš„æ¥å£å¾ˆç®€å•ï¼š

```rust
pub fn unbounded<T>() -> (Sender<T>, Receiver<T>) {
    let shared = Shared::default();
    let shared = Arc::new(shared);
    (
        Sender {
            shared: shared.clone(),
        },
        Receiver { shared },
    )
}

const INITIAL_SIZE: usize = 32;
impl<T> Default for Shared<T> {
    fn default() -> Self {
        Self {
            queue: Mutex::new(VecDeque::with_capacity(INITIAL_SIZE)),
            available: Condvar::new(),
            senders: AtomicUsize::new(1),
            receivers: AtomicUsize::new(1),
        }
    }
}
```

å› ä¸ºè¿™é‡Œä½¿ç”¨ default() åˆ›å»ºäº† Shared&lt;T&gt; ç»“æ„ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦ä¸ºå…¶å®ç° Defaultã€‚åˆ›å»ºæ—¶ï¼Œæˆ‘ä»¬æœ‰ 1 ä¸ªç”Ÿäº§è€…å’Œ1 ä¸ªæ¶ˆè´¹è€…ã€‚

### å®ç°æ¶ˆè´¹è€…

å¯¹äºæ¶ˆè´¹è€…ï¼Œæˆ‘ä»¬ä¸»è¦éœ€è¦å®ç° recv æ–¹æ³•ã€‚

åœ¨ recv ä¸­ï¼Œå¦‚æœé˜Ÿåˆ—ä¸­æœ‰æ•°æ®ï¼Œé‚£ä¹ˆç›´æ¥è¿”å›ï¼›å¦‚æœæ²¡æ•°æ®ï¼Œä¸”æ‰€æœ‰ç”Ÿäº§è€…éƒ½ç¦»å¼€äº†ï¼Œæˆ‘ä»¬å°±è¿”å›é”™è¯¯ï¼›å¦‚æœæ²¡æ•°æ®ï¼Œä½†è¿˜æœ‰ç”Ÿäº§è€…ï¼Œæˆ‘ä»¬å°±é˜»å¡æ¶ˆè´¹è€…çš„çº¿ç¨‹ï¼š

```rust
impl<T> Receiver<T> {
    pub fn recv(&mut self) -> Result<T> {
        // æ‹¿åˆ°é˜Ÿåˆ—çš„é”
        let mut inner = self.shared.queue.lock().unwrap();
        loop {
            match inner.pop_front() {
                // è¯»åˆ°æ•°æ®è¿”å›ï¼Œé”è¢«é‡Šæ”¾
                Some(t) => {
                    return Ok(t);
                }
                // è¯»ä¸åˆ°æ•°æ®ï¼Œå¹¶ä¸”ç”Ÿäº§è€…éƒ½é€€å‡ºäº†ï¼Œé‡Šæ”¾é”å¹¶è¿”å›é”™è¯¯
                None if self.total_senders() == 0 => return Err(anyhow!("no sender left")),
                // è¯»ä¸åˆ°æ•°æ®ï¼ŒæŠŠé”æäº¤ç»™ available Condvarï¼Œå®ƒä¼šé‡Šæ”¾é”å¹¶æŒ‚èµ·çº¿ç¨‹ï¼Œç­‰å¾… notify
                None => {
                    // å½“ Condvar è¢«å”¤é†’åä¼šè¿”å› MutexGuardï¼Œæˆ‘ä»¬å¯ä»¥ loop å›å»æ‹¿æ•°æ®
                    // è¿™æ˜¯ä¸ºä»€ä¹ˆ Condvar è¦åœ¨ loop é‡Œä½¿ç”¨
                    inner = self
                        .shared
                        .available
                        .wait(inner)
                        .map_err(|_| anyhow!("lock poisoned"))?;
                }
            }
        }
    }

    pub fn total_senders(&self) -> usize {
        self.shared.senders.load(Ordering::SeqCst)
    }
}
```

æ³¨æ„çœ‹è¿™é‡Œ Condvar çš„ä½¿ç”¨ã€‚

åœ¨ wait() æ–¹æ³•é‡Œï¼Œå®ƒæ¥æ”¶ä¸€ä¸ª MutexGuardï¼Œç„¶åé‡Šæ”¾è¿™ä¸ª Mutexï¼ŒæŒ‚èµ·çº¿ç¨‹ã€‚ç­‰å¾—åˆ°é€šçŸ¥åï¼Œå®ƒä¼šå†è·å–é”ï¼Œå¾—åˆ°ä¸€ä¸ª MutexGuardï¼Œè¿”å›ã€‚æ‰€ä»¥è¿™é‡Œæ˜¯ï¼š

```rust
inner = self.shared.available.wait(inner).map_err(|_| anyhow!("lock poisoned"))?;
```

å› ä¸º recv() ä¼šè¿”å›ä¸€ä¸ªå€¼ï¼Œæ‰€ä»¥é˜»å¡å›æ¥ä¹‹åï¼Œæˆ‘ä»¬åº”è¯¥å¾ªç¯å›å»æ‹¿æ•°æ®ã€‚è¿™æ˜¯ä¸ºä»€ä¹ˆè¿™æ®µé€»è¾‘è¦è¢« loop {} åŒ…è£¹ã€‚æˆ‘ä»¬å‰é¢åœ¨è®¾è®¡æ—¶è€ƒè™‘è¿‡ï¼šå½“å‘é€è€…å‘é€æ•°æ®æ—¶ï¼Œåº”è¯¥é€šçŸ¥è¢«é˜»å¡çš„æ¶ˆè´¹è€…ã€‚æ‰€ä»¥ï¼Œåœ¨å®ç° Sender çš„ send() æ—¶ï¼Œéœ€è¦åšç›¸åº”çš„ notify å¤„ç†ã€‚

è®°å¾—è¿˜è¦å¤„ç†æ¶ˆè´¹è€…çš„ dropï¼š

```rust
impl<T> Drop for Receiver<T> {
    fn drop(&mut self) {
        self.shared.receivers.fetch_sub(1, Ordering::AcqRel);
    }
}
```

å¾ˆç®€å•ï¼Œæ¶ˆè´¹è€…ç¦»å¼€æ—¶ï¼Œå°† receivers å‡ä¸€ã€‚

### å®ç°ç”Ÿäº§è€…

æ¥ä¸‹æ¥æˆ‘ä»¬çœ‹ç”Ÿäº§è€…çš„åŠŸèƒ½æ€ä¹ˆå®ç°ã€‚

é¦–å…ˆï¼Œåœ¨æ²¡æœ‰æ¶ˆè´¹è€…çš„æƒ…å†µä¸‹ï¼Œåº”è¯¥æŠ¥é”™ã€‚æ­£å¸¸åº”è¯¥ä½¿ç”¨ thiserror å®šä¹‰è‡ªå·±çš„é”™è¯¯ï¼Œä¸è¿‡è¿™é‡Œä¸ºäº†ç®€åŒ–ä»£ç ï¼Œå°±ä½¿ç”¨ anyhow! å®äº§ç”Ÿä¸€ä¸ª adhoc çš„é”™è¯¯ã€‚å¦‚æœæ¶ˆè´¹è€…è¿˜åœ¨ï¼Œé‚£ä¹ˆæˆ‘ä»¬è·å– VecDeque çš„é”ï¼ŒæŠŠæ•°æ®å‹å…¥ï¼š

```rust
impl<T> Sender<T> {
    /// ç”Ÿäº§è€…å†™å…¥ä¸€ä¸ªæ•°æ®
    pub fn send(&mut self, t: T) -> Result<()> {
        // å¦‚æœæ²¡æœ‰æ¶ˆè´¹è€…äº†ï¼Œå†™å…¥æ—¶å‡ºé”™
        if self.total_receivers() == 0 {
            return Err(anyhow!("no receiver left"));
        }

        // åŠ é”ï¼Œè®¿é—® VecDequeï¼Œå‹å…¥æ•°æ®ï¼Œç„¶åç«‹åˆ»é‡Šæ”¾é”
        let was_empty = {
            let mut inner = self.shared.queue.lock().unwrap();
            let empty = inner.is_empty();
            inner.push_back(t);
            empty
        };

        // é€šçŸ¥ä»»æ„ä¸€ä¸ªè¢«æŒ‚èµ·ç­‰å¾…çš„æ¶ˆè´¹è€…æœ‰æ•°æ®
        if was_empty {
            self.shared.available.notify_one();
        }

        Ok(())
    }

    pub fn total_receivers(&self) -> usize {
        self.shared.receivers.load(Ordering::SeqCst)
    }

    pub fn total_queued_items(&self) -> usize {
        let queue = self.shared.queue.lock().unwrap();
        queue.len()
    }
}
```

è¿™é‡Œï¼Œè·å– total\_receivers æ—¶ï¼Œæˆ‘ä»¬ä½¿ç”¨äº† Ordering::SeqCstï¼Œä¿è¯æ‰€æœ‰çº¿ç¨‹çœ‹åˆ°åŒæ ·é¡ºåºçš„å¯¹ receivers çš„æ“ä½œã€‚è¿™ä¸ªå€¼æ˜¯æœ€æ–°çš„å€¼ã€‚

**åœ¨å‹å…¥æ•°æ®æ—¶ï¼Œéœ€è¦åˆ¤æ–­ä¸€ä¸‹ä¹‹å‰æ˜¯é˜Ÿåˆ—æ˜¯å¦ä¸ºç©ºï¼Œå› ä¸ºé˜Ÿåˆ—ä¸ºç©ºçš„æ—¶å€™ï¼Œæˆ‘ä»¬éœ€è¦ç”¨ notify\_one() æ¥å”¤é†’æ¶ˆè´¹è€…**ã€‚è¿™ä¸ªéå¸¸é‡è¦ï¼Œå¦‚æœæ²¡å¤„ç†çš„è¯ï¼Œä¼šå¯¼è‡´æ¶ˆè´¹è€…é˜»å¡åæ— æ³•å¤åŸæ¥æ”¶æ•°æ®ã€‚

ç”±äºæˆ‘ä»¬å¯ä»¥æœ‰å¤šä¸ªç”Ÿäº§è€…ï¼Œæ‰€ä»¥è¦å…è®¸å®ƒ cloneï¼š

```rust
impl<T> Clone for Sender<T> {
    fn clone(&self) -> Self {
        self.shared.senders.fetch_add(1, Ordering::AcqRel);
        Self {
            shared: Arc::clone(&self.shared),
        }
    }
}
```

å®ç° Clone trait çš„æ–¹æ³•å¾ˆç®€å•ï¼Œä½†è®°å¾—è¦æŠŠ shared.senders åŠ  1ï¼Œä½¿å…¶ä¿æŒå’Œå½“å‰çš„ senders çš„æ•°é‡ä¸€è‡´ã€‚

å½“ç„¶ï¼Œåœ¨ drop çš„æ—¶å€™æˆ‘ä»¬ä¹Ÿè¦ç»´æŠ¤ shared.senders ä½¿å…¶å‡ 1ï¼š

```rust
impl<T> Drop for Sender<T> {
    fn drop(&mut self) {
        self.shared.senders.fetch_sub(1, Ordering::AcqRel);
        
    }
}
```

### å…¶å®ƒåŠŸèƒ½

ç›®å‰è¿˜ç¼ºä¹ Receiver çš„ Iterator çš„å®ç°ï¼Œè¿™ä¸ªå¾ˆç®€å•ï¼Œå°±æ˜¯åœ¨ next() é‡Œè°ƒç”¨ recv() æ–¹æ³•ï¼ŒRust æä¾›äº†æ”¯æŒåœ¨ Option / Result ä¹‹é—´å¾ˆæ–¹ä¾¿è½¬æ¢çš„å‡½æ•°ï¼Œæ‰€ä»¥è¿™é‡Œæˆ‘ä»¬å¯ä»¥ç›´æ¥é€šè¿‡ ok() æ¥å°† Result è½¬æ¢æˆ Optionï¼š

```rust
impl<T> Iterator for Receiver<T> {
    type Item = T;

    fn next(&mut self) -> Option<Self::Item> {
        self.recv().ok()
    }
}
```

å¥½ï¼Œç›®å‰æ‰€æœ‰éœ€è¦å®ç°çš„ä»£ç éƒ½å®ç°å®Œæ¯•ï¼Œ `cargo test` æµ‹è¯•ä¸€ä¸‹ã€‚wowï¼æµ‹è¯•ä¸€æ¬¡æ€§é€šè¿‡ï¼è¿™ä¹Ÿå¤ªé¡ºåˆ©äº†å§ï¼

æœ€åæ¥ä»”ç»†å®¡è§†ä¸€ä¸‹ä»£ç ã€‚å¾ˆå¿«ï¼Œæˆ‘ä»¬å‘ç° Sender çš„ Drop å®ç°ä¼¼ä¹æœ‰ç‚¹é—®é¢˜ã€‚**å¦‚æœ Receiver è¢«é˜»å¡ï¼Œè€Œæ­¤åˆ»æ‰€æœ‰ Sender éƒ½èµ°äº†ï¼Œé‚£ä¹ˆ Receiver å°±æ²¡æœ‰äººå”¤é†’ï¼Œä¼šå¸¦æ¥èµ„æºçš„æ³„éœ²**ã€‚è¿™æ˜¯ä¸€ä¸ªå¾ˆè¾¹è¾¹è§’è§’çš„é—®é¢˜ï¼Œæ‰€ä»¥ä¹‹å‰çš„æµ‹è¯•æ²¡æœ‰è¦†ç›–åˆ°ã€‚

æˆ‘ä»¬æ¥è®¾è®¡ä¸€ä¸ªåœºæ™¯è®©è¿™ä¸ªé—®é¢˜æš´éœ²ï¼š

```rust
#[test]
fn receiver_shall_be_notified_when_all_senders_exit() {
    let (s, mut r) = unbounded::<usize>();
    // ç”¨äºä¸¤ä¸ªçº¿ç¨‹åŒæ­¥
    let (mut sender, mut receiver) = unbounded::<usize>();
    let t1 = thread::spawn(move || {
        // ä¿è¯ r.recv() å…ˆäº t2 çš„ drop æ‰§è¡Œ
        sender.send(0).unwrap();
        assert!(r.recv().is_err());
    });

    thread::spawn(move || {
        receiver.recv().unwrap();
        drop(s);
    });

    t1.join().unwrap();
}
```

åœ¨æˆ‘è¿›ä¸€æ­¥è§£é‡Šä¹‹å‰ï¼Œä½ å¯ä»¥åœä¸‹æ¥æƒ³æƒ³ä¸ºä»€ä¹ˆè¿™ä¸ªæµ‹è¯•å¯ä»¥ä¿è¯æš´éœ²è¿™ä¸ªé—®é¢˜ï¼Ÿå®ƒæ˜¯æ€ä¹ˆæš´éœ²çš„ï¼Ÿå¦‚æœæƒ³ä¸åˆ°ï¼Œå† `cargo test` çœ‹çœ‹ä¼šå‡ºç°ä»€ä¹ˆé—®é¢˜ã€‚

æ¥ä¸€èµ·åˆ†æåˆ†æï¼Œè¿™é‡Œï¼Œæˆ‘ä»¬åˆ›å»ºäº†ä¸¤ä¸ªçº¿ç¨‹ t1 å’Œ t2ï¼Œåˆ†åˆ«è®©å®ƒä»¬å¤„ç†æ¶ˆè´¹è€…å’Œç”Ÿäº§è€…ã€‚**t1 è¯»å–æ•°æ®ï¼Œæ­¤æ—¶æ²¡æœ‰æ•°æ®ï¼Œæ‰€ä»¥ä¼šé˜»å¡ï¼Œè€Œt2 ç›´æ¥æŠŠç”Ÿäº§è€… drop æ‰**ã€‚æ‰€ä»¥ï¼Œæ­¤åˆ»å¦‚æœæ²¡æœ‰äººå”¤é†’ t1ï¼Œé‚£ä¹ˆ t1.join() å°±ä¼šä¸€ç›´ç­‰å¾…ï¼Œå› ä¸º t1 ä¸€ç›´æ²¡æœ‰é€€å‡ºã€‚

æ‰€ä»¥ï¼Œä¸ºäº†ä¿è¯ä¸€å®šæ˜¯ t1 `r.recv()`å…ˆæ‰§è¡Œå¯¼è‡´é˜»å¡ã€t2 å† `drop(s)`ï¼Œæˆ‘ä»¬ï¼ˆeat your own dog foodï¼‰ç”¨å¦ä¸€ä¸ª channel æ¥æ§åˆ¶ä¸¤ä¸ªçº¿ç¨‹çš„æ‰§è¡Œé¡ºåºã€‚è¿™æ˜¯ä¸€ç§å¾ˆé€šç”¨çš„åšæ³•ï¼Œä½ å¯ä»¥å¥½å¥½ç¢ç£¨ä¸€ä¸‹ã€‚

è¿è¡Œ `cargo test` åï¼Œæµ‹è¯•è¢«é˜»å¡ã€‚è¿™æ˜¯å› ä¸ºï¼Œt1 æ²¡æœ‰æœºä¼šå¾—åˆ°å”¤é†’ï¼Œæ‰€ä»¥è¿™ä¸ªæµ‹è¯•å°±åœåœ¨é‚£é‡Œä¸åŠ¨äº†ã€‚

è¦ä¿®å¤è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬éœ€è¦å¦¥å–„å¤„ç† Sender çš„ Dropï¼š

```rust
impl<T> Drop for Sender<T> {
    fn drop(&mut self) {
        let old = self.shared.senders.fetch_sub(1, Ordering::AcqRel);
        // sender èµ°å…‰äº†ï¼Œå”¤é†’ receiver è¯»å–æ•°æ®ï¼ˆå¦‚æœé˜Ÿåˆ—ä¸­è¿˜æœ‰çš„è¯ï¼‰ï¼Œè¯»ä¸åˆ°å°±å‡ºé”™
        if old <= 1 {
            // å› ä¸ºæˆ‘ä»¬å®ç°çš„æ˜¯ MPSCï¼Œreceiver åªæœ‰ä¸€ä¸ªï¼Œæ‰€ä»¥ notify_all å®é™…ç­‰ä»· notify_one
            self.shared.available.notify_all();
        }
    }
}
```

è¿™é‡Œï¼Œå¦‚æœå‡ä¸€ä¹‹å‰ï¼Œæ—§çš„ senders çš„æ•°é‡å°äºç­‰äº 1ï¼Œæ„å‘³ç€ç°åœ¨æ˜¯æœ€åä¸€ä¸ª Sender è¦ç¦»å¼€äº†ï¼Œä¸ç®¡æ€æ ·æˆ‘ä»¬éƒ½è¦å”¤é†’ Receiver ï¼Œæ‰€ä»¥è¿™é‡Œä½¿ç”¨äº† notify\_all()ã€‚å¦‚æœ Receiver ä¹‹å‰å·²ç»è¢«é˜»å¡ï¼Œæ­¤åˆ»å°±èƒ½è¢«å”¤é†’ã€‚ä¿®æ”¹å®Œæˆï¼Œ`cargo test` ä¸€åˆ‡æ­£å¸¸ã€‚

## æ€§èƒ½ä¼˜åŒ–

ä»åŠŸèƒ½ä¸Šæ¥è¯´ï¼Œç›®å‰æˆ‘ä»¬çš„ MPSC unbounded channel æ²¡æœ‰å¤ªå¤šçš„é—®é¢˜ï¼Œå¯ä»¥åº”ç”¨åœ¨ä»»ä½•éœ€è¦ MPSC channel çš„åœºæ™¯ã€‚ç„¶è€Œï¼Œæ¯æ¬¡è¯»å†™éƒ½éœ€è¦è·å–é”ï¼Œè™½ç„¶é”çš„ç²’åº¦å¾ˆå°ï¼Œä½†è¿˜æ˜¯è®©æ•´ä½“çš„æ€§èƒ½æ‰“äº†ä¸ªæŠ˜æ‰£ã€‚æœ‰æ²¡æœ‰å¯èƒ½ä¼˜åŒ–é”å‘¢ï¼Ÿ

ä¹‹å‰æˆ‘ä»¬è®²åˆ°ï¼Œä¼˜åŒ–é”çš„æ‰‹æ®µæ— éæ˜¯**å‡å°ä¸´ç•ŒåŒºçš„å¤§å°**ï¼Œè®©æ¯æ¬¡åŠ é”çš„æ—¶é—´å¾ˆçŸ­ï¼Œè¿™æ ·å†²çªçš„å‡ ç‡å°±å˜å°ã€‚å¦å¤–ï¼Œå°±æ˜¯**é™ä½åŠ é”çš„é¢‘ç‡ï¼Œ**å¯¹äºæ¶ˆè´¹è€…æ¥è¯´ï¼Œå¦‚æœæˆ‘ä»¬èƒ½å¤Ÿä¸€æ¬¡æ€§æŠŠé˜Ÿåˆ—ä¸­çš„æ‰€æœ‰æ•°æ®éƒ½è¯»å®Œç¼“å­˜èµ·æ¥ï¼Œä»¥ååœ¨éœ€è¦çš„æ—¶å€™ä»ç¼“å­˜ä¸­è¯»å–ï¼Œè¿™æ ·å°±å¯ä»¥å¤§å¤§å‡å°‘æ¶ˆè´¹è€…åŠ é”çš„é¢‘æ¬¡ã€‚

é¡ºç€è¿™ä¸ªæ€è·¯ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨ Receiver çš„ç»“æ„ä¸­æ”¾ä¸€ä¸ª cacheï¼š

```rust
pub struct Receiver<T> {
    shared: Arc<Shared<T>>,
    cache: VecDeque<T>,
}
```

å¦‚æœä½ ä¹‹å‰æœ‰ C è¯­è¨€å¼€å‘çš„ç»éªŒï¼Œä¹Ÿè®¸ä¼šæƒ³ï¼Œåˆ°äº†è¿™ä¸€æ­¥ï¼Œä½•å¿…æŠŠ queue ä¸­çš„æ•°æ®å…¨éƒ¨è¯»å‡ºæ¥ï¼Œå­˜å…¥ Receiver çš„ cache å‘¢ï¼Ÿè¿™æ ·æ•ˆç‡å¤ªä½ï¼Œå¦‚æœèƒ½å¤Ÿç›´æ¥ swap ä¸¤ä¸ªç»“æ„å†…éƒ¨çš„æŒ‡é’ˆï¼Œè¿™æ ·ï¼Œå³ä¾¿é˜Ÿåˆ—ä¸­æœ‰å†å¤šçš„æ•°æ®ï¼Œä¹Ÿæ˜¯ä¸€ä¸ª O(1) çš„æ“ä½œã€‚

å—¯ï¼Œåˆ«æ€¥ï¼ŒRust æœ‰ç±»ä¼¼çš„ [std::mem::swap](https://doc.rust-lang.org/std/mem/fn.swap.html) æ–¹æ³•ã€‚æ¯”å¦‚ï¼ˆ[ä»£ç ](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=b68e503ae3413338f770fde2f6c7e861)ï¼‰ï¼š

```rust
use std::mem;

fn main() {
    let mut x = "hello world".to_string();
    let mut y = "goodbye world".to_string();
    
    mem::swap(&mut x, &mut y);
    
    assert_eq!("goodbye world", x);
    assert_eq!("hello world", y);
}
```

å¥½ï¼Œäº†è§£äº† swap æ–¹æ³•ï¼Œæˆ‘ä»¬çœ‹çœ‹å¦‚ä½•ä¿®æ”¹ Receiver çš„ recv() æ–¹æ³•æ¥æå‡æ€§èƒ½ï¼š

```rust
pub fn recv(&mut self) -> Result<T> {
    // æ— é” fast path
    if let Some(v) = self.cache.pop_front() {
        return Ok(v);
    }

    // æ‹¿åˆ°é˜Ÿåˆ—çš„é”
    let mut inner = self.shared.queue.lock().unwrap();
    loop {
        match inner.pop_front() {
            // è¯»åˆ°æ•°æ®è¿”å›ï¼Œé”è¢«é‡Šæ”¾
            Some(t) => {
                // å¦‚æœå½“å‰é˜Ÿåˆ—ä¸­è¿˜æœ‰æ•°æ®ï¼Œé‚£ä¹ˆå°±æŠŠæ¶ˆè´¹è€…è‡ªèº«ç¼“å­˜çš„é˜Ÿåˆ—ï¼ˆç©ºï¼‰å’Œå…±äº«é˜Ÿåˆ— swap ä¸€ä¸‹
                // è¿™æ ·ä¹‹åå†è¯»å–ï¼Œå°±å¯ä»¥ä» self.queue ä¸­æ— é”è¯»å–
                if !inner.is_empty() {
                    std::mem::swap(&mut self.cache, &mut inner);
                }
                return Ok(t);
            }
            // è¯»ä¸åˆ°æ•°æ®ï¼Œå¹¶ä¸”ç”Ÿäº§è€…éƒ½é€€å‡ºäº†ï¼Œé‡Šæ”¾é”å¹¶è¿”å›é”™è¯¯
            None if self.total_senders() == 0 => return Err(anyhow!("no sender left")),
            // è¯»ä¸åˆ°æ•°æ®ï¼ŒæŠŠé”æäº¤ç»™ available Condvarï¼Œå®ƒä¼šé‡Šæ”¾é”å¹¶æŒ‚èµ·çº¿ç¨‹ï¼Œç­‰å¾… notify
            None => {
                // å½“ Condvar è¢«å”¤é†’åä¼šè¿”å› MutexGuardï¼Œæˆ‘ä»¬å¯ä»¥ loop å›å»æ‹¿æ•°æ®
                // è¿™æ˜¯ä¸ºä»€ä¹ˆ Condvar è¦åœ¨ loop é‡Œä½¿ç”¨
                inner = self
                    .shared
                    .available
                    .wait(inner)
                    .map_err(|_| anyhow!("lock poisoned"))?;
            }
        }
    }
}
```

å½“ cache ä¸­æœ‰æ•°æ®æ—¶ï¼Œæ€»æ˜¯ä» cache ä¸­è¯»å–ï¼›å½“ cache ä¸­æ²¡æœ‰ï¼Œæˆ‘ä»¬æ‹¿åˆ°é˜Ÿåˆ—çš„é”ï¼Œè¯»å–ä¸€ä¸ªæ•°æ®ï¼Œç„¶åçœ‹çœ‹é˜Ÿåˆ—æ˜¯å¦è¿˜æœ‰æ•°æ®ï¼Œæœ‰çš„è¯ï¼Œå°± swap cache å’Œ queueï¼Œç„¶åè¿”å›ä¹‹å‰è¯»å–çš„æ•°æ®ã€‚

å¥½ï¼Œåšå®Œè¿™ä¸ªé‡æ„å’Œä¼˜åŒ–ï¼Œæˆ‘ä»¬å¯ä»¥è¿è¡Œ `cargo test`ï¼Œçœ‹çœ‹å·²æœ‰çš„æµ‹è¯•æ˜¯å¦æ­£å¸¸ã€‚å¦‚æœä½ é‡åˆ°æŠ¥é”™ï¼Œåº”è¯¥æ˜¯ cache æ²¡æœ‰åˆå§‹åŒ–ï¼Œä½ å¯ä»¥è‡ªè¡Œè§£å†³ï¼Œä¹Ÿå¯ä»¥å‚è€ƒï¼š

```rust
pub fn unbounded<T>() -> (Sender<T>, Receiver<T>) {
    let shared = Shared::default();
    let shared = Arc::new(shared);
    (
        Sender {
            shared: shared.clone(),
        },
        Receiver {
            shared,
            cache: VecDeque::with_capacity(INITIAL_SIZE),
        },
    )
}
```

è™½ç„¶ç°æœ‰çš„æµ‹è¯•å…¨æ•°é€šè¿‡ï¼Œä½†æˆ‘ä»¬å¹¶æ²¡æœ‰ä¸ºè¿™ä¸ªä¼˜åŒ–å†™æµ‹è¯•ï¼Œè¿™é‡Œè¡¥ä¸ªæµ‹è¯•ï¼š

```rust
#[test]
    fn channel_fast_path_should_work() {
    let (mut s, mut r) = unbounded();
    for i in 0..10usize {
        s.send(i).unwrap();
    }

    assert!(r.cache.is_empty());
    // è¯»å–ä¸€ä¸ªæ•°æ®ï¼Œæ­¤æ—¶åº”è¯¥ä¼šå¯¼è‡´ swapï¼Œcache ä¸­æœ‰æ•°æ®
    assert_eq!(0, r.recv().unwrap());
    // è¿˜æœ‰ 9 ä¸ªæ•°æ®åœ¨ cache ä¸­
    assert_eq!(r.cache.len(), 9);
    // åœ¨ queue é‡Œæ²¡æœ‰æ•°æ®äº†
    assert_eq!(s.total_queued_items(), 0);

    // ä» cache é‡Œè¯»å–å‰©ä¸‹çš„æ•°æ®
    for (idx, i) in r.into_iter().take(9).enumerate() {
        assert_eq!(idx + 1, i);
    }
}
```

è¿™ä¸ªæµ‹è¯•å¾ˆç®€å•ï¼Œè¯¦ç»†æ³¨é‡Šä¹Ÿéƒ½å†™ä¸Šäº†ã€‚

## å°ç»“

ä»Šå¤©æˆ‘ä»¬ä¸€èµ·ç ”ç©¶äº†å¦‚ä½•ä½¿ç”¨ atomics å’Œ Condvarï¼Œç»“åˆ VecDeque æ¥åˆ›å»ºä¸€ä¸ª MPSC unbounded channelã€‚å®Œæ•´çš„ä»£ç è§ [playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=042ee12817442a32bcfa05e31a1084f9)ï¼Œä½ ä¹Ÿå¯ä»¥åœ¨ GitHub repo è¿™ä¸€è®²çš„ç›®å½•ä¸­æ‰¾åˆ°ã€‚

ä¸åŒäºä»¥å¾€çš„å®æ“é¡¹ç›®ï¼Œè¿™ä¸€è®²ï¼Œæˆ‘ä»¬å®Œå…¨é¡ºç€éœ€æ±‚å†™æµ‹è¯•ï¼Œç„¶ååœ¨å†™æµ‹è¯•çš„è¿‡ç¨‹ä¸­è¿›è¡Œæ•°æ®ç»“æ„å’Œæ¥å£çš„è®¾è®¡ã€‚å’Œæ™®é€šçš„ TDD ä¸åŒçš„æ˜¯ï¼Œæˆ‘ä»¬**å…ˆä¸€å£æ°”æŠŠä¸»è¦éœ€æ±‚æ¶‰åŠçš„è¡Œä¸ºç”¨æµ‹è¯•æ¥è¡¨è¿°ï¼Œç„¶åé€šè¿‡è¿™ä¸ªè¡¨è¿°ï¼Œæ„å»ºåˆé€‚çš„æ¥å£ï¼Œä»¥åŠèƒ½å¤Ÿè¿è¡Œè¿™ä¸ªæ¥å£çš„æ•°æ®ç»“æ„**ã€‚

åœ¨å¼€å‘äº§å“çš„æ—¶å€™ï¼Œè¿™ä¹Ÿæ˜¯ä¸€ç§éå¸¸æœ‰æ•ˆçš„æ‰‹æ®µï¼Œå¯ä»¥è®©æˆ‘ä»¬é€šè¿‡æµ‹è¯•å®Œå–„è®¾è®¡ï¼Œæœ€ç»ˆå¾—åˆ°ä¸€ä¸ªèƒ½å¤Ÿè®©æµ‹è¯•ç¼–è¯‘é€šè¿‡çš„ã€å®Œå…¨æ²¡æœ‰å®ç°ä»£ç ã€åªæœ‰æ¥å£çš„ç‰ˆæœ¬ã€‚ä¹‹åï¼Œæˆ‘ä»¬å†ä¸€ä¸ªæ¥å£ä¸€ä¸ªæ¥å£å®ç°ï¼Œå…¨éƒ¨å®ç°å®Œæˆä¹‹åï¼Œè¿è¡Œæµ‹è¯•ï¼Œçœ‹çœ‹æ˜¯å¦å‡ºé—®é¢˜ã€‚

åœ¨å­¦ä¹ è¿™ä¸€è®²çš„å†…å®¹æ—¶ï¼Œä½ å¯ä»¥å¤šå¤šå…³æ³¨æ„å»ºæµ‹è¯•ç”¨ä¾‹çš„æŠ€å·§ã€‚ä¹‹å‰çš„è¯¾ç¨‹ä¸­ï¼Œæˆ‘åå¤å¼ºè°ƒè¿‡å•å…ƒæµ‹è¯•çš„é‡è¦æ€§ï¼Œä¹Ÿä»¥èº«ä½œåˆ™åœ¨å‡ ä¸ªé‡è¦çš„å®æ“ä¸­éƒ½æœ‰è¯¦å°½åœ°æµ‹è¯•ã€‚ä¸è¿‡ç›¸æ¯”ä¹‹å‰å†™çš„æµ‹è¯•ï¼Œè¿™ä¸€è®²ä¸­çš„æµ‹è¯•è¦æ›´éš¾å†™ä¸€äº›ï¼Œå°¤å…¶æ˜¯åœ¨å¹¶å‘åœºæ™¯ä¸‹é‚£äº›è¾¹è¾¹è§’è§’çš„åŠŸèƒ½æµ‹è¯•ã€‚

ä¸è¦å°çœ‹æµ‹è¯•ä»£ç ï¼Œæœ‰æ—¶å€™æ„é€ æµ‹è¯•ä»£ç æ¯”æ’°å†™åŠŸèƒ½ä»£ç è¿˜è¦çƒ§è„‘ã€‚ä½†æ˜¯ï¼Œå½“ä½ æœ‰äº†æ‰å®çš„å•å…ƒæµ‹è¯•è¦†ç›–åï¼Œå†åšé‡æ„ï¼Œæ¯”å¦‚æœ€åæˆ‘ä»¬åšå’Œæ€§èƒ½ç›¸å…³çš„é‡æ„ï¼Œå°±å˜å¾—è½»æ¾å¾ˆå¤šï¼Œ**å› ä¸ºåªè¦**`cargo test`**é€šè¿‡ï¼Œèµ·ç è¿™ä¸ªé‡æ„æ²¡æœ‰å¼•èµ·ä»»ä½•å›å½’é—®é¢˜ï¼ˆregression bugï¼‰**ã€‚

å½“ç„¶ï¼Œé‡æ„æ²¡æœ‰å¼•å…¥å›å½’é—®é¢˜ï¼Œå¹¶ä¸æ„å‘³ç€é‡æ„å®Œå…¨æ²¡æœ‰é—®é¢˜ï¼Œæˆ‘ä»¬è¿˜éœ€è¦è€ƒè™‘æ’°å†™æ–°çš„æµ‹è¯•ï¼Œè¦†ç›–é‡æ„å¸¦æ¥çš„æ”¹åŠ¨ã€‚

### æ€è€ƒé¢˜

æˆ‘ä»¬å®ç°äº†ä¸€ä¸ª unbounded MPSC channelï¼Œå¦‚æœè¦å°†å…¶ä¿®æ”¹ä¸º bounded MPSC channelï¼ˆé˜Ÿåˆ—å¤§å°æ˜¯å—é™çš„ï¼‰ï¼Œéœ€è¦æ€ä¹ˆåšï¼Ÿ

æ¬¢è¿åœ¨ç•™è¨€åŒºäº¤æµä½ çš„å­¦ä¹ å¿ƒå¾—å’Œæ€è€ƒï¼Œæ„Ÿè°¢ä½ çš„æ”¶å¬ï¼Œä»Šå¤©ä½ å·²ç»å®Œæˆäº†Rustå­¦ä¹ çš„ç¬¬35æ¬¡æ‰“å¡ã€‚å¦‚æœä½ è§‰å¾—æœ‰æ”¶è·ï¼Œä¹Ÿæ¬¢è¿ä½ åˆ†äº«ç»™èº«è¾¹çš„æœ‹å‹ï¼Œé‚€ä»–ä¸€èµ·è®¨è®ºã€‚æˆ‘ä»¬ä¸‹èŠ‚è¯¾è§ã€‚
<div><strong>ç²¾é€‰ç•™è¨€ï¼ˆ15ï¼‰</strong></div><ul>
<li><span>ä¹Œé¾™çŒ¹</span> ğŸ‘ï¼ˆ11ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>è¿™æ¸…æ™°çš„é€»è¾‘ï¼Œå®Œç¾è¯ é‡ŠTDD  æå‰é¢„å®šè€å¸ˆæœªæ¥æ¨å‡ºçš„ elixir è¯¾ç¨‹ </p>2021-11-17</li><br/><li><span>ç½—æ°</span> ğŸ‘ï¼ˆ5ï¼‰ ğŸ’¬ï¼ˆ2ï¼‰<p>è€å¸ˆåœ¨ä¸€ééçš„é‡å¤ TDDï¼Œç„¶åæˆ‘æŠŠ TDD ç”¨åœ¨äº†ç°åœ¨çš„ Go é¡¹ç›®ä¸­ï¼Œæ•ˆæœéå¸¸å¥½ï¼Œè™½ç„¶å¼€å‘çš„æ—¶é—´å¢é•¿äº†ï¼Œä½†æ˜¯ä»£ç è´¨é‡æ˜¾è‘—æé«˜äº†ã€‚</p>2021-11-17</li><br/><li><span>å½­äºšä¼¦</span> ğŸ‘ï¼ˆ1ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>ä¸€è¾¹è¿½è¿™æœ€æ–°çš„è¯¾ç¨‹æ›´æ–°, ä¸€è¾¹åå¤æ¸©ä¹ å‰é¢çš„è¯¾ç¨‹; 
ä¹‹å‰è¿½ã€Šwestworldã€‹éƒ½æ²¡è¿™ä¹ˆè¿‡ç˜¾è¿‡~</p>2021-11-17</li><br/><li><span>Colt</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>æœ€å–œæ¬¢è€å¸ˆçš„å®è·µè¯¾,ä¹Ÿè®¸rustçš„çŸ¥è¯†å­¦å¾—è¿˜ä¸€çŸ¥åŠè§£,ä½†æ˜¯è·Ÿç€è€å¸ˆçš„æ€è·¯æ•²ä»£ç æ„Ÿè§‰éå¸¸çˆ½,å¾ˆå¤šæ—¶å€™ä¸€ä¸ªé¡ºä¾¿å°±å®Œæˆäº†éœ€æ±‚</p>2021-12-05</li><br/><li><span>wowotuo</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>ä¹Ÿç‰¹åˆ«æœŸå¾…æŠŠå¼‚æ­¥tokioã€å…ƒç¼–ç¨‹è®²é€</p>2021-11-24</li><br/><li><span>wowotuo</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>è¿™ä¸ªå®æ“é¡¹ç›®éå¸¸æœ‰æ„ä¹‰ï¼Œè®©æˆ‘å¯¹è¿™å—æœ‰äº†ä¸€ä¸ªä½“ç³»æ€§ã€æ·±å…¥çš„è®¤çŸ¥ï¼Œå€¼å¾—å¤šè¯»å¤šçœ‹ã€‚</p>2021-11-24</li><br/><li><span>ç½—åŒå­¦</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ2ï¼‰<p>æˆ‘æƒ³è¯·é—®ä¸€ä¸‹ï¼Œå®ç°è¿™ä¸ªä¸»è¦æ˜¯ä¸ºäº†ç†è§£channel åŸç†ï¼Œè¿™ä¸ªæ¡ˆä¾‹å¯ä»¥ç”¨äºå®é™…ç”Ÿäº§ä¸ï¼Ÿè¿˜æ˜¯è¯´æ ‡å‡†åº“é‡Œçš„æ€§èƒ½ä¼šæ›´å¥½ä¸€ç‚¹</p>2021-11-18</li><br/><li><span>Enoch Tang</span> ğŸ‘ï¼ˆ1ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>ç›®å‰Sender çš„Dropå®ç°æœ‰bugï¼Œè€ƒè™‘ä»¥ä¸‹åœºæ™¯ï¼š
Receiver thread:
1. åŠ é”
2. åˆ¤æ–­ sender æ˜¯å¦ä¸º0ï¼›
3. ä½¿ç”¨CondVar wait

å‡è®¾åœ¨ Receiver thread æ‰§è¡Œå®Œ2ä¹‹ååˆ‡æ¢åˆ° å…¶ä»–çº¿ç¨‹æ‰§è¡Œ drop s çš„æ“ä½œï¼Œå…¶ä»–çº¿ç¨‹notify_allï¼Œæ­¤æ—¶ Receiver threadè¿˜æ²¡æœ‰è¿›å…¥åˆ°waitçš„çŠ¶æ€ï¼Œé‚£ä¹ˆåé¢Receiver threadè¿›å…¥åˆ°waitçŠ¶æ€åå†ä¹Ÿä¸ä¼šè¢«å”¤é†’äº†</p>2023-11-11</li><br/><li><span>Geek_zbvt62</span> ğŸ‘ï¼ˆ1ï¼‰ ğŸ’¬ï¼ˆ2ï¼‰<p>Drop for Sender&lt;T&gt;çš„å®ç°ä¸­ï¼Œnotify_allæ²¡æœ‰åœ¨Mutexçš„ä¿æŠ¤ä¸‹è¿›è¡Œã€‚è¿™æ˜¯å¦ä¼šå¯¼è‡´ä¸€ç§å¯èƒ½æ€§ï¼š
1. receiverå‘ç°senderä¸ä¸º0ï¼Œå‡†å¤‡è¿›å…¥wait
2. senderè¢«dropï¼Œå‡ä¸€ï¼Œä¸º0ï¼Œæ‰§è¡Œnotify_all
3. receiveræ‰§è¡Œwaitï¼Œé‡Šæ”¾é”ï¼Œé˜»å¡ä½
æ­¤æ—¶å·²ç»æ²¡æœ‰senderèƒ½å”¤é†’receiver

ï¼Ÿï¼Ÿï¼Ÿ</p>2022-11-02</li><br/><li><span>çˆ±å­¦ä¹ çš„å°è¿ª</span> ğŸ‘ï¼ˆ1ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>çœ‹è€å¸ˆçš„è¯¾ç¨‹çœŸçš„æ˜¯å¯ä»¥å­¦ä¹ åˆ°å¾ˆå¤šä¸œè¥¿å•Šï¼Œä¸æ­¢Rustã€‚å¤ªçˆ½äº†</p>2022-04-10</li><br/><li><span>åƒè—•å§å‰²å¾çˆ±</span> ğŸ‘ï¼ˆ1ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>receiver_should_be_blocked_when_nothing_to_read()æµ‹è¯•ä¸­ä¸»çº¿ç¨‹é€€å‡ºåï¼ŒSenderå…¨éƒ¨è¢«ææ„ï¼Œthread1ä¸­çš„è¿­ä»£å™¨å°±è¿”å›Noneäº†ï¼Œé‚£ä¸æ˜¯å°±ä¼šè¿è¡Œåˆ°assert!(false)è¿™å¥è¯äº†å—ï¼Ÿ</p>2022-04-02</li><br/><li><span>å°å¯çˆ±(`ã¸Â´*)ãƒ</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>è€å¸ˆçš„è¯¾å¤ªå¼ºäº†ï¼Œèƒ½å­¦åˆ°å¾ˆå¤šæ·±å…¥çš„ä¸œè¥¿</p>2022-11-16</li><br/><li><span>è¿›å‡»çš„Lancelot</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>æ€è€ƒé¢˜ï¼šå¯¹äº bounded_channel  çš„æµ‹è¯•å¦‚ä¸‹ï¼š
```rust
&#47;&#47; éœ€æ±‚6: å½“ channel æ»¡äº†çš„æ—¶å€™ï¼Œsender å‘é€ä¼šè¢«é˜»å¡
    #[test]
    fn sender_should_block_when_channel_is_full() {
        let ( s, mut r) = bounded(3);
        let mut s1 = s.clone();
        let cnt = Arc::new(AtomicUsize::new(0));
        let cnt_1 = Arc::clone(&amp;cnt);
        thread::spawn(move || {
            for i in 0..10 {
                s1.send(i).unwrap();
                cnt_1.fetch_add(1, Ordering::AcqRel);
            }
            unreachable!();
        });

        &#47;&#47; 1ms è¶³ä»¥è®© sender å‘é€å®Œ 3 ä¸ªæ¶ˆæ¯
        thread::sleep(Duration::from_millis(1));
        assert_eq!(3, cnt.load(Ordering::SeqCst));
        for i in 0..2 {
            assert_eq!(i, r.recv().unwrap());
        }
        &#47;&#47; 1ms è¶³ä»¥è®© sender å†å‘é€å®Œ 2 ä¸ªæ¶ˆæ¯
        thread::sleep(Duration::from_millis(1));
        assert_eq!(5, cnt.load(Ordering::SeqCst));
        assert_eq!(2, r.recv().unwrap());

        thread::sleep(Duration::from_millis(1));
        assert_eq!(s.total_queued_items(), 3);
    }
```
ç¡®å®šå¥½äº†æµ‹è¯•ç”¨ä¾‹ä¹‹åï¼Œå°±å¯ä»¥å¼€å§‹æ€è€ƒå®ç°æ–¹å¼ã€‚ä¸»è¦å°±æ˜¯ç»™ shared å¢åŠ ä¸€ä¸ª capacity çš„åŸå­å˜é‡ï¼Œåœ¨ send æ—¶å€™å‡ä¸€ï¼Œrecv çš„æ—¶å€™åŠ ä¸€ï¼Œå¹¶ä¸”åœ¨ send æ—¶å€™ï¼Œå¦‚æœ capacity ä¸º 0ï¼Œåˆ™éœ€è¦ block ä½ send æ‰€åœ¨çš„çº¿ç¨‹ã€‚ç”±äº bounded_channel åº•å±‚å®¹å™¨æœ‰å®¹é‡ä¸Šé™ï¼Œä½¿ç”¨ cache ä¼šå¯¼è‡´ä¸€äº›é—®é¢˜ï¼Œæ¯”å¦‚ï¼šæ˜æ˜è£…æ»¡äº† channel è¯»ä¸€æ¬¡åï¼Œå´åˆèƒ½ç»§ç»­å¾€é‡Œé¢ send æ•°æ®ï¼Œå®¹æ˜“è®©ç”¨æˆ·æ„Ÿåˆ°å›°æƒ‘ï¼Œå› æ­¤å–æ¶ˆäº† cache çš„ä¼˜åŒ–ã€‚ 
å…·ä½“å®Œæ•´ä»£ç å¯ä»¥å‚è€ƒï¼šhttps:&#47;&#47;play.rust-lang.org&#47;?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=facca5a34f7bd1d103a482da3a6c8d5e</p>2022-09-30</li><br/><li><span>zxk</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>è€å¸ˆï¼Œreceiver_shall_be_notified_when_all_senders_exit åº”è¯¥åªæ˜¯å¤§æ¦‚ç‡èƒ½æµ‹å‡ºé—®é¢˜å§ï¼Ÿ
```

#[test]
fn receiver_shall_be_notified_when_all_senders_exit() {
    let (s, mut r) = unbounded::&lt;usize&gt;();
    &#47;&#47; ç”¨äºä¸¤ä¸ªçº¿ç¨‹åŒæ­¥
    let (mut sender, mut receiver) = unbounded::&lt;usize&gt;();
    let t1 = thread::spawn(move || {
        &#47;&#47; ä¿è¯ r.recv() å…ˆäº t2 çš„ drop æ‰§è¡Œ
        sender.send(0).unwrap();
        assert!(r.recv().is_err());
    });

    thread::spawn(move || {
        receiver.recv().unwrap();
        drop(s);
    });

    t1.join().unwrap();
}
```
t1 çš„ sender.send(0).unwrap() ä¼šå”¤é†’ t2 ä¸­çš„ receiver.recv().unwrap()ï¼Œè¿™æ—¶å€™ t2 ä¸­çš„ drop(s) æ˜¯æœ‰å¯èƒ½åœ¨ t1 ä¸­çš„ assert!(r.recv().is_err()) ä¹‹å‰æ‰§è¡Œï¼Œå¯¼è‡´æ— æ³•æµ‹å‡ºé—®é¢˜ï¼Œè™½ç„¶æ¦‚ç‡éå¸¸å°ã€‚</p>2022-07-07</li><br/><li><span>Curricane</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ2ï¼‰<p>å®é™…é¡¹ç›®ä¸­ï¼Œä¼šæœ‰ç½‘ç»œè¯·æ±‚ï¼Œæ•°æ®åº“ï¼Œæˆ–è€…ä¸å…¶ä»–ç»„ä»¶äº¤äº’ï¼Œè¿™ä¸ªæ—¶å€™ï¼Œæ€ä¹ˆè¿›è¡Œ TDD å‘¢</p>2022-06-15</li><br/>
</ul>