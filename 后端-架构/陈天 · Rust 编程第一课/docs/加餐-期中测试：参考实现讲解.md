ä½ å¥½ï¼Œæˆ‘æ˜¯é™ˆå¤©ã€‚

ä¸Šä¸€è®²ç»™ä½ å¸ƒç½®äº†ä¸€ä»½ç®€å•çš„æœŸä¸­è€ƒè¯•ä¹ é¢˜ï¼Œä¸çŸ¥é“ä½ å®Œæˆçš„æ€ä¹ˆæ ·ã€‚ä»Šå¤©æˆ‘ä»¬æ¥ç®€å•è®²ä¸€è®²å®ç°ï¼Œä¾›ä½ å‚è€ƒã€‚

æ”¯æŒ grep å¹¶ä¸æ˜¯ä¸€ä»¶å¤æ‚çš„äº‹æƒ…ï¼Œç›¸ä¿¡ä½ åœ¨ä½¿ç”¨äº† clapã€globã€rayon å’Œ regex åï¼Œéƒ½èƒ½å†™å‡ºç±»ä¼¼çš„ä»£ç ï¼ˆä¼ªä»£ç ï¼‰ï¼š

```rust
/// Yet another simplified grep built with Rust.
#[derive(Clap, Debug)]
#[clap(version = "1.0", author = "Tyr Chen <tyr@chen.com>")]
#[clap(setting = AppSettings::ColoredHelp)]
pub struct GrepConfig {
    /// regex pattern to match against file contents
    pattern: String,
    /// Glob of file pattern
    glob: String,
}

impl GrepConfig {
    pub fn matches(&self) -> Result<()> {
        let regex = Regex::new(&self.pattern)?;
        let files: Vec<_> = glob::glob(&self.glob)?.collect();
        files.into_par_iter().for_each(|v| {
            if let Ok(filename) = v {
                if let Ok(file) = File::open(&filename) {
                    let reader = BufReader::new(file);
                    |-	for (lineno, line) in reader.lines().enumerate() {
                    |       if let Ok(line) = line {
                    |           if let Some(_) = pattern.find(&line) {
                    |               println!("{}: {}", lineno + 1, &line);
                    |           }
                    |       }
                    |-  }
                }
            }
        });
        Ok(())
    }
}
```

è¿™ä¸ªä»£ç æ’°å†™çš„æ„Ÿè§‰å’Œ Python å·®ä¸å¤šï¼Œé™¤äº†é˜…è¯»å‡ ä¸ªä¾èµ–èŠ±äº›æ—¶é—´å¤–ï¼Œå‡ ä¹æ²¡æœ‰éš¾åº¦ã€‚

ä¸è¿‡ï¼Œè¿™ä¸ªä»£ç ä¸å…·å¤‡å¯æµ‹è¯•æ€§ï¼Œä¼šç»™ä»¥åçš„ç»´æŠ¤å’Œæ‰©å±•å¸¦æ¥éº»çƒ¦ã€‚æˆ‘ä»¬æ¥çœ‹çœ‹å¦‚ä½•ä¼˜åŒ–ï¼Œä½¿è¿™æ®µä»£ç æ›´åŠ å®¹æ˜“æµ‹è¯•ã€‚

## å¦‚ä½•å†™å‡ºå¥½å®ç°

é¦–å…ˆï¼Œæˆ‘ä»¬è¦å‰¥ç¦»ä¸»è¦é€»è¾‘ã€‚

ä¸»è¦é€»è¾‘æ˜¯ä»€ä¹ˆï¼Ÿè‡ªç„¶æ˜¯å¯¹äºå•ä¸ªæ–‡ä»¶çš„ grepï¼Œä¹Ÿå°±æ˜¯ä»£ç ä¸­æ ‡è®°çš„éƒ¨åˆ†ã€‚æˆ‘ä»¬å¯ä»¥å°†å®ƒæŠ½ç¦»æˆä¸€ä¸ªå‡½æ•°ï¼š

```rust
fn process(reader: BufReader<File>)
```

å½“ç„¶ï¼Œä»æ¥å£çš„è§’åº¦æ¥è¯´ï¼Œè¿™ä¸ª process å‡½æ•°å®šä¹‰å¾—å¤ªæ­»ï¼Œå¦‚æœä¸æ˜¯ä» File ä¸­å–æ•°æ®ï¼Œæ”¹å¤©éœ€æ±‚å˜äº†ï¼Œä¹Ÿéœ€è¦æ”¯æŒä» stdio ä¸­å–æ•°æ®å‘¢ï¼Ÿå°±éœ€è¦æ”¹åŠ¨è¿™ä¸ªæ¥å£äº†ã€‚

æ‰€ä»¥å¯ä»¥**ä½¿ç”¨æ³›å‹**ï¼š

```rust
fn process<R: Read>(reader: BufReader<R>)
```

æ³›å‹å‚æ•° R åªéœ€è¦æ»¡è¶³ std::io::Read trait å°±å¯ä»¥ã€‚

è¿™ä¸ªæ¥å£è™½ç„¶æŠ½å–å‡ºæ¥äº†ï¼Œä½†å®ƒä¾æ—§ä¸å¯æµ‹ï¼Œå› ä¸ºå®ƒå†…éƒ¨ç›´æ¥ println!ï¼ŒæŠŠæ‰¾åˆ°çš„æ•°æ®ç›´æ¥æ‰“å°å‡ºæ¥äº†ã€‚æˆ‘ä»¬å½“ç„¶å¯ä»¥æŠŠè¦æ‰“å°çš„è¡Œæ”¾å…¥ä¸€ä¸ª Vec&lt;String&gt; è¿”å›ï¼Œè¿™æ ·å°±å¯ä»¥æµ‹è¯•äº†ã€‚

ä¸è¿‡ï¼Œè¿™æ˜¯ä¸ºäº†æµ‹è¯•è€Œæµ‹è¯•ï¼Œ**æ›´å¥½çš„æ–¹å¼æ˜¯æŠŠè¾“å‡ºçš„å¯¹è±¡ä» Stdout æŠ½è±¡æˆ Write**ã€‚ç°åœ¨ process çš„æ¥å£å˜ä¸ºï¼š

```rust
fn process<R: Read, W: Write>(reader: BufReader<R>, writer: &mut Writer)
```

è¿™æ ·ï¼Œæˆ‘ä»¬å°±å¯ä»¥ä½¿ç”¨å®ç°äº† Read trait çš„ &amp;\[u8] ä½œä¸ºè¾“å…¥ï¼Œä»¥åŠä½¿ç”¨å®ç°äº† Write trait çš„ Vec&lt;u8&gt;ä½œä¸ºè¾“å‡ºï¼Œè¿›è¡Œæµ‹è¯•äº†ã€‚è€Œåœ¨ rgrep çš„å®ç°æ—¶ï¼Œæˆ‘ä»¬ç”¨ File ä½œä¸ºè¾“å…¥ï¼ŒStdout ä½œä¸ºè¾“å‡ºã€‚è¿™æ ·æ—¢æ»¡è¶³äº†éœ€æ±‚ï¼Œè®©æ ¸å¿ƒé€»è¾‘å¯æµ‹ï¼Œè¿˜è®©æ¥å£è¶³å¤Ÿçµæ´»ï¼Œå¯ä»¥é€‚é…ä»»ä½•å®ç°äº† Read çš„è¾“å…¥ä»¥åŠå®ç°äº† Write çš„è¾“å‡ºã€‚

å¥½ï¼Œæœ‰äº†è¿™ä¸ªæ€è·¯ï¼Œæ¥çœ‹çœ‹æˆ‘æ˜¯æ€ä¹ˆå†™è¿™ä¸ª rgrep çš„ï¼Œä¾›ä½ å‚è€ƒã€‚

é¦–å…ˆ `cargo new rgrep` åˆ›å»ºä¸€ä¸ªæ–°çš„é¡¹ç›®ã€‚åœ¨ Cargo.toml ä¸­ï¼Œæ·»åŠ å¦‚ä¸‹ä¾èµ–ï¼š

```rust
[dependencies]
anyhow = "1"
clap = "3.0.0-beta.4" # æˆ‘ä»¬éœ€è¦ä½¿ç”¨æœ€æ–°çš„ 3.0.0-beta.4 æˆ–è€…æ›´é«˜ç‰ˆæœ¬
colored = "2"
glob = "0.3"
itertools = "0.10"
rayon = "1"
regex = "1"
thiserror = "1"
```

å¯¹äºå¤„ç†å‘½ä»¤è¡Œçš„ clapï¼Œæˆ‘ä»¬éœ€è¦ 3.0 çš„ç‰ˆæœ¬ã€‚ä¸è¦åœ¨æ„ VS Code æ’ä»¶æç¤ºä½ æœ€æ–°ç‰ˆæœ¬æ˜¯ 2.33ï¼Œé‚£æ˜¯å› ä¸º beta ä¸ç®—æ­£å¼ç‰ˆæœ¬ã€‚

ç„¶ååˆ›å»º src/lib.rs å’Œ src/error.rsï¼Œåœ¨ [error.rs](http://error.rs) ä¸­æ·»åŠ ä¸€äº›é”™è¯¯å®šä¹‰ï¼š

```rust
use thiserror::Error;

#[derive(Error, Debug)]
pub enum GrepError {
    #[error("Glob pattern error")]
    GlobPatternError(#[from] glob::PatternError),
    #[error("Regex pattern error")]
    RegexPatternError(#[from] regex::Error),
    #[error("I/O error")]
    IoError(#[from] std::io::Error),
}
```

å®ƒä»¬éƒ½æ˜¯éœ€è¦è¿›è¡Œè½¬æ¢çš„é”™è¯¯ã€‚thiserror èƒ½å¤Ÿé€šè¿‡å®å¸®æˆ‘ä»¬å®Œæˆé”™è¯¯ç±»å‹çš„è½¬æ¢ã€‚

åœ¨ src/lib.rs ä¸­ï¼Œæ·»å…¥å¦‚ä¸‹ä»£ç ï¼š

```rust
use clap::{AppSettings, Clap};
use colored::*;
use itertools::Itertools;
use rayon::iter::{IntoParallelIterator, ParallelIterator};
use regex::Regex;
use std::{
    fs::File,
    io::{self, BufRead, BufReader, Read, Stdout, Write},
    ops::Range,
    path::Path,
};

mod error;
pub use error::GrepError;

/// å®šä¹‰ç±»å‹ï¼Œè¿™æ ·ï¼Œåœ¨ä½¿ç”¨æ—¶å¯ä»¥ç®€åŒ–å¤æ‚ç±»å‹çš„ä¹¦å†™
pub type StrategyFn<W, R> = fn(&Path, BufReader<R>, &Regex, &mut W) -> Result<(), GrepError>;

/// ç®€åŒ–ç‰ˆæœ¬çš„ grepï¼Œæ”¯æŒæ­£åˆ™è¡¨è¾¾å¼å’Œæ–‡ä»¶é€šé…ç¬¦
#[derive(Clap, Debug)]
#[clap(version = "1.0", author = "Tyr Chen <tyr@chen.com>")]
#[clap(setting = AppSettings::ColoredHelp)]
pub struct GrepConfig {
    /// ç”¨äºæŸ¥æ‰¾çš„æ­£åˆ™è¡¨è¾¾å¼
    pattern: String,
    /// æ–‡ä»¶é€šé…ç¬¦
    glob: String,
}

impl GrepConfig {
    /// ä½¿ç”¨ç¼ºçœç­–ç•¥æ¥æŸ¥æ‰¾åŒ¹é…
    pub fn match_with_default_strategy(&self) -> Result<(), GrepError> {
        self.match_with(default_strategy)
    }

    /// ä½¿ç”¨æŸä¸ªç­–ç•¥å‡½æ•°æ¥æŸ¥æ‰¾åŒ¹é…
    pub fn match_with(&self, strategy: StrategyFn<Stdout, File>) -> Result<(), GrepError> {
        let regex = Regex::new(&self.pattern)?;
        // ç”Ÿæˆæ‰€æœ‰ç¬¦åˆé€šé…ç¬¦çš„æ–‡ä»¶åˆ—è¡¨
        let files: Vec<_> = glob::glob(&self.glob)?.collect();
        // å¹¶è¡Œå¤„ç†æ‰€æœ‰æ–‡ä»¶
        files.into_par_iter().for_each(|v| {
            if let Ok(filename) = v {
                if let Ok(file) = File::open(&filename) {
                    let reader = BufReader::new(file);
                    let mut stdout = io::stdout();

                    if let Err(e) = strategy(filename.as_path(), reader, &regex, &mut stdout) {
                        println!("Internal error: {:?}", e);
                    }
                }
            }
        });
        Ok(())
    }
}

/// ç¼ºçœç­–ç•¥ï¼Œä»å¤´åˆ°å°¾ä¸²è¡ŒæŸ¥æ‰¾ï¼Œæœ€åè¾“å‡ºåˆ° writer
pub fn default_strategy<W: Write, R: Read>(
    path: &Path,
    reader: BufReader<R>,
    pattern: &Regex,
    writer: &mut W,
) -> Result<(), GrepError> {
    let matches: String = reader
        .lines()
        .enumerate()
        .map(|(lineno, line)| {
            line.ok()
                .map(|line| {
                    pattern
                        .find(&line)
                        .map(|m| format_line(&line, lineno + 1, m.range()))
                })
                .flatten()
        })
        .filter_map(|v| v.ok_or(()).ok())
        .join("\n");

    if !matches.is_empty() {
        writer.write(path.display().to_string().green().as_bytes())?;
        writer.write(b"\n")?;
        writer.write(matches.as_bytes())?;
        writer.write(b"\n")?;
    }

    Ok(())
}

/// æ ¼å¼åŒ–è¾“å‡ºåŒ¹é…çš„è¡Œï¼ŒåŒ…å«è¡Œå·ã€åˆ—å·å’Œå¸¦æœ‰é«˜äº®çš„ç¬¬ä¸€ä¸ªåŒ¹é…é¡¹
pub fn format_line(line: &str, lineno: usize, range: Range<usize>) -> String {
    let Range { start, end } = range;
    let prefix = &line[..start];
    format!(
        "{0: >6}:{1: <3} {2}{3}{4}",
        lineno.to_string().blue(),
        // æ‰¾åˆ°åŒ¹é…é¡¹çš„èµ·å§‹ä½ç½®ï¼Œæ³¨æ„å¯¹æ±‰å­—ç­‰é ascii å­—ç¬¦ï¼Œæˆ‘ä»¬ä¸èƒ½ä½¿ç”¨ prefix.len()
        // è¿™æ˜¯ä¸€ä¸ª O(n) çš„æ“ä½œï¼Œä¼šæ‹–ç´¯æ•ˆç‡ï¼Œè¿™é‡Œåªæ˜¯ä¸ºäº†æ¼”ç¤ºçš„æ•ˆæœ
        (prefix.chars().count() + 1).to_string().cyan(),
        prefix,
        &line[start..end].red(),
        &line[end..]
    )
}
```

å’Œåˆšæ‰çš„æ€è·¯ç¨æœ‰ä¸åŒçš„æ˜¯ï¼Œprocess å‡½æ•°å« default\_strategy()ã€‚å¦å¤–æˆ‘ä»¬**ä¸º GrepConfig æä¾›äº†ä¸¤ä¸ªæ–¹æ³•**ï¼Œä¸€ä¸ªæ˜¯ match\_with\_default\_strategy()ï¼Œå¦ä¸€ä¸ªæ˜¯ match\_with()ï¼Œè°ƒç”¨è€…å¯ä»¥è‡ªå·±ä¼ å…¥ä¸€ä¸ªå‡½æ•°æˆ–è€…é—­åŒ…ï¼Œå¯¹ç»™å®šçš„ BufReader è¿›è¡Œå¤„ç†ã€‚è¿™æ˜¯ä¸€ç§å¸¸ç”¨çš„è§£è€¦çš„å¤„ç†æ–¹æ³•ã€‚

åœ¨ src/lib.rs é‡Œï¼Œç»§ç»­æ’°å†™å•å…ƒæµ‹è¯•ï¼š

```rust
#[cfg(test)]
mod tests {

    use super::*;

    #[test]
    fn format_line_should_work() {
        let result = format_line("Hello, Tyr~", 1000, 7..10);
        let expected = format!(
            "{0: >6}:{1: <3} Hello, {2}~",
            "1000".blue(),
            "7".cyan(),
            "Tyr".red()
        );
        assert_eq!(result, expected);
    }

    #[test]
    fn default_strategy_should_work() {
        let path = Path::new("src/main.rs");
        let input = b"hello world!\nhey Tyr!";
        let reader = BufReader::new(&input[..]);
        let pattern = Regex::new(r"he\\w+").unwrap();
        let mut writer = Vec::new();
        default_strategy(path, reader, &pattern, &mut writer).unwrap();
        let result = String::from_utf8(writer).unwrap();
        let expected = [
            String::from("src/main.rs"),
            format_line("hello world!", 1, 0..5),
            format_line("hey Tyr!\n", 2, 0..3),
        ];

        assert_eq!(result, expected.join("\n"));
    }
}
```

ä½ å¯ä»¥é‡ç‚¹å…³æ³¨æµ‹è¯•æ˜¯å¦‚ä½•ä½¿ç”¨ default\_strategy() å‡½æ•°ï¼Œè€Œ match\_with() æ–¹æ³•åˆæ˜¯å¦‚ä½•ä½¿ç”¨å®ƒçš„ã€‚è¿è¡Œ `cargo test`ï¼Œä¸¤ä¸ªæµ‹è¯•éƒ½èƒ½é€šè¿‡ã€‚

æœ€åï¼Œåœ¨ src/main.rs ä¸­æ·»åŠ å‘½ä»¤è¡Œå¤„ç†é€»è¾‘ï¼š

```rust
use anyhow::Result;
use clap::Clap;
use rgrep::*;

fn main() -> Result<()> {
    let config: GrepConfig = GrepConfig::parse();
    config.match_with_default_strategy()?;

    Ok(())
}
```

åœ¨å‘½ä»¤è¡Œä¸‹è¿è¡Œï¼š`cargo run --quiet -- "Re[^\\s]+" "src/*.rs"` ï¼Œä¼šå¾—åˆ°ç±»ä¼¼å¦‚ä¸‹è¾“å‡ºã€‚æ³¨æ„ï¼Œæ–‡ä»¶è¾“å‡ºçš„é¡ºåºå¯èƒ½ä¸å®Œå…¨ä¸€æ ·ï¼Œå› ä¸º rayon æ˜¯å¤šä¸ªçº¿ç¨‹å¹¶è¡Œæ‰§è¡Œçš„ã€‚  
![å›¾ç‰‡](https://static001.geekbang.org/resource/image/79/aa/79c56964b55dede4ce0ec7c5c4cfe9aa.png?wh=1920x797)

## å°ç»“

rgrep æ˜¯ä¸€ä¸ªç®€å•çš„å‘½ä»¤è¡Œå·¥å…·ï¼Œä»…ä»…å†™äº†ä¸Šç™¾è¡Œä»£ç ï¼Œå°±å®Œæˆäº†ä¸€ä¸ªæ€§èƒ½ç›¸å½“ä¸é”™çš„ç®€åŒ–ç‰ˆ grepã€‚åœ¨ä¸åšå¤æ‚çš„æ¥å£è®¾è®¡æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥ä¸ç”¨ç”Ÿå‘½å‘¨æœŸï¼Œä¸ç”¨æ³›å‹ï¼Œç”šè‡³ä¸ç”¨å¤ªå…³å¿ƒæ‰€æœ‰æƒï¼Œå°±å¯ä»¥å†™å‡ºéå¸¸ç±»ä¼¼è„šæœ¬è¯­è¨€çš„ä»£ç ã€‚

ä»è¿™ä¸ªæ„ä¹‰ä¸Šè®²ï¼Œ**Rust ç”¨æ¥åšä¸€æ¬¡æ€§çš„ã€å³ç”¨å³æŠ›å‹çš„ä»£ç ï¼Œæˆ–è€…è¯´ï¼Œå†™ä¸ªå¿«é€ŸåŸå‹ï¼Œä¹Ÿæœ‰ç”¨æ­¦ä¹‹åœ°**ï¼›å½“æˆ‘ä»¬éœ€è¦æ›´å¥½çš„ä»£ç è´¨é‡ã€æ›´é«˜çš„æŠ½è±¡åº¦ã€æ›´çµæ´»çš„è®¾è®¡æ—¶ï¼ŒRust æä¾›äº†è¶³å¤Ÿå¤šçš„å·¥å…·ï¼Œè®©æˆ‘ä»¬å°†åŸå‹è¿›åŒ–æˆæ›´æˆç†Ÿçš„ä»£ç ã€‚

ç›¸ä¿¡åœ¨åš rgrep çš„è¿‡ç¨‹ä¸­ï¼Œä½ èƒ½æ„Ÿå—åˆ°ç”¨ Rust å¼€å‘è½¯ä»¶çš„æ„‰æ‚¦ã€‚

ä»Šå¤©æˆ‘ä»¬å°±ä¸å¸ƒç½®æ€è€ƒé¢˜äº†ï¼Œä½ å¯ä»¥å¤šå¤šä½“ä¼šKV serverå’Œrgrepå·¥å…·çš„å®ç°ã€‚æ­å–œä½ å®Œæˆäº†RuståŸºç¡€ç¯‡çš„å­¦ä¹ ï¼Œè¿›åº¦æ¡è¿‡åŠï¼Œæˆ‘ä»¬ä¸‹èŠ‚è¯¾è¿›é˜¶ç¯‡è§ã€‚

æ¬¢è¿ä½ åˆ†äº«ç»™èº«è¾¹çš„æœ‹å‹ï¼Œé‚€ä»–ä¸€èµ·è®¨è®ºã€‚

### å»¶ä¼¸é˜…è¯»

åœ¨ YouTube ä¸Šï¼Œæœ‰ä¸€ä¸ªæ–°é²œå‡ºç‚‰çš„è§†é¢‘ï¼š[Visualizing memory layout of Rustâ€™s data types](https://www.youtube.com/watch?v=rDoqT-a6UFg)ï¼Œç”¨ 40 åˆ†é’Ÿçš„æ—¶é—´ï¼Œæ€»ç»“äº†æˆ‘ä»¬å‰é¢åŸºç¡€ç¯‡äºŒåè®²é‡Œæåˆ°çš„ä¸»è¦æ•°æ®ç»“æ„çš„å†…å­˜å¸ƒå±€ã€‚æˆ‘ä¸ªäººéå¸¸å–œæ¬¢è¿™ä¸ªè§†é¢‘ï¼Œå› ä¸ºå®ƒå’Œæˆ‘ä¸€ç›´å€¡å¯¼çš„â€œå˜æ¸…æ•°æ®æ˜¯å¦‚ä½•åœ¨å †å’Œæ ˆä¸Šå­˜å‚¨â€çš„æ€è·¯ä¸è°‹è€Œåˆï¼Œåœ¨è¿™é‡Œä¹Ÿæ¨èç»™ä½ ã€‚å¦‚æœä½ æƒ³å¿«é€Ÿå¤ä¹ ä¸€ä¸‹ï¼ŒæŸ¥æ¼è¡¥ç¼ºï¼Œé‚£ä¹ˆéå¸¸å»ºè®®ä½ èŠ±ä¸Šä¸€ä¸ªå°æ—¶æ—¶é—´ä»”ç»†çœ‹ä¸€ä¸‹è¿™ä¸ªè§†é¢‘ã€‚
<div><strong>ç²¾é€‰ç•™è¨€ï¼ˆ10ï¼‰</strong></div><ul>
<li><span>Bitstream</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>è€å¸ˆæœ‰æ²¡æœ‰é‡åˆ°rust-analyzerä¸‹ï¼Œ`use thiserror::`æ— æ³•æç¤ºè¡¥å…¨çš„æƒ…å†µï¼Ÿ</p>2021-11-27</li><br/><li><span>dva</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>è¿™å‡ ç¯‡æ–‡ç« çœ‹ä¸‹æ¥ï¼Œç»“æ„è®¾è®¡ç›¸å…³çŸ¥è¯†ä¹Ÿæ”¶è·è‰¯å¤šï¼Œæ„Ÿè°¢è€å¸ˆ</p>2021-11-19</li><br/><li><span>è€å®äººHoney</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>https:&#47;&#47;github.com&#47;clap-rs&#47;clap&#47;issues&#47;2917
clap v3.0.0-beta.4 break changeäº†ï¼Œè¦è°ƒæ•´ä¸€ä¸‹</p>2021-11-08</li><br/><li><span>linuxfish</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ3ï¼‰<p>writer.write(path.display().to_string().green().as_bytes())?;

è¿™ä¸€è¡Œçš„è®¾ç½®é¢œè‰²è²Œä¼¼æ²¡æœ‰èµ·ä½œç”¨ï¼Œæ¢äº†å…¶å®ƒé¢œè‰²ä¹Ÿæ˜¯æ²¡æ•ˆæœ</p>2021-11-01</li><br/><li><span>é‡å±±é—¨</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>çœ‹å®Œäº†é™„å¸¦çš„è§†é¢‘ï¼Œå¯¹æ•°æ®ç±»å‹çš„å†…å­˜ç»“æ„æœ‰ä¸€ä¸ªæ¸…æ™°çš„è®¤è¯†ã€‚æ„Ÿè°¢ï¼</p>2021-10-28</li><br/><li><span>è®°äº‹æœ¬</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ3ï¼‰<p>è€å¸ˆ,å¿…é¡»æ”¹æˆè¿™æ ·æ‰å¯ä»¥æ¢è¡Œç”Ÿæ•ˆå•Š         writer.write(b&quot;\n&quot;)?;
</p>2021-10-16</li><br/><li><span>è®°äº‹æœ¬</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ7ï¼‰<p>use std::io::self  selfåœ¨è¿™é‡ŒæŒ‡çš„æ˜¯ä»€ä¹ˆå•Š</p>2021-10-15</li><br/><li><span>Simon</span> ğŸ‘ï¼ˆ4ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>è€å¸ˆ, æ–‡ä»¶è·¯å¾„çš„é¢œè‰²ä¸èƒ½æ­£å¸¸æ˜¾ç¤º
æˆ‘ä¿®å¤äº†ä¸€ä¸‹, è§PR
https:&#47;&#47;github.com&#47;tyrchen&#47;geektime-rust&#47;pull&#47;10</p>2022-04-28</li><br/><li><span>æ²ˆç•…</span> ğŸ‘ï¼ˆ2ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>è¿™ä¸ªé¢˜å®Œå…¨ä¸ä¼šåšï¼Œè¿˜å¾—å­¦å„ç§åº“å•Š</p>2022-08-12</li><br/><li><span>woJA1wCgAA14JCXna23FAiisVJJCYYyA</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>`stdout` è¾“å‡ºè¿™é‡Œä¼šä¸ä¼šæœ‰å¤šä¸ªçº¿ç¨‹åŒæ—¶å†™ `io` ï¼Œå¯¼è‡´ `path` å’Œ `matches` äº¤é”™è¾“å‡ºçš„æƒ…å†µå‘€</p>2022-03-26</li><br/>
</ul>