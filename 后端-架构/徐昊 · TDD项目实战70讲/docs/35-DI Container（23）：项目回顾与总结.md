ä½ å¥½ï¼Œæˆ‘æ˜¯å¾æ˜Šã€‚ä»Šå¤©æˆ‘ä»¬æ¥å›é¡¾ä¸€ä¸‹ç¬¬äºŒä¸ªå®æˆ˜é¡¹ç›®çš„æ•´ä¸ªè¿‡ç¨‹ã€‚

## æœ€ç»ˆçš„å®Œæˆå½¢æ€

é¦–å…ˆï¼Œè®©æˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹æœ€ç»ˆçš„å®Œæˆå½¢æ€ï¼š

## é¡¹ç›®å›é¡¾ä¸æ€»ç»“

é¦–å…ˆæ˜¯ä»»åŠ¡åˆ†è§£ã€‚åœ¨é¡¹ç›®åˆšå¼€å§‹çš„æ—¶å€™ï¼Œæˆ‘ä»¬æ²¡æœ‰æ„æƒ³ä»»ä½•çš„æ¶æ„æ„¿æ™¯ï¼Œè€Œæ˜¯ç›´æ¥é‡‡ç”¨ç»å…¸æ¨¡å¼ï¼Œä»åŠŸèƒ½ç‚¹å‡ºå‘è¿›è¡ŒTDDå¼€å‘ã€‚ä¸€å¼€å§‹è¿›å±•æ˜¯å¾ˆé¡ºåˆ©çš„ï¼Œä»ä»»åŠ¡åˆ—è¡¨ä¸Šçœ‹ï¼Œé™¤äº†å¶æœ‰é—è½çš„åŠŸèƒ½ç‚¹ï¼ŒåŸºæœ¬ä¸Šæ˜¯æŒ‰ç…§ä»»åŠ¡åˆ—è¡¨é¡ºç•…è¿›è¡Œçš„ã€‚

ç¬¬ä¸€ä¸ªè½¬æŠ˜ç‚¹å‡ºç°åœ¨æˆ‘ä»¬ç¬¬ä¸€æ¬¡é‡æ„ä¹‹åï¼Œæˆ‘ä»¬å°†InjectionProviderä»ContextConfigä¸­åˆ†ç¦»äº†å‡ºæ¥ã€‚å¹¶å°†ä¾èµ–çš„æ£€æŸ¥ä»è¿è¡ŒæœŸæ£€æŸ¥ï¼Œå˜æˆäº†åœ¨ContextConfig.getContextæ—¶é¢„å…ˆæ£€æŸ¥ã€‚

ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬çš„**æ¶æ„æ„¿æ™¯**åœ¨æ­¤æ—¶å‘ç”Ÿäº†æ”¹å˜ï¼šåªè¦Contextèƒ½å¤Ÿè¢«æ„å»ºå‡ºæ¥ï¼Œå…¶ä¸­å°±ä¸å­˜åœ¨æ— æ•ˆç»„ä»¶å’Œæ— æ•ˆçš„ç»„ä»¶å…³ç³»ï¼ˆå¾ªç¯ä¾èµ–ã€ä¾èµ–ç¼ºå¤±ï¼‰ã€‚

è¿™ä¸ªæ¶æ„æ„¿æ™¯æ”¹å˜çš„ç›´æ¥å½±å“ï¼Œå°±æ˜¯è®©æˆ‘ä»¬**åˆ†è§£ä»»åŠ¡çš„æ–¹å¼**å‘ç”Ÿäº†å˜åŒ–ã€‚ä½“ç°åœ¨ä»»åŠ¡åˆ—è¡¨ä¸Šä¸ºï¼š

- æ–¹æ³•æ³¨å…¥ï¼ˆæ”¹å˜å‰ï¼‰
  
  - é€šè¿‡Injectæ ‡æ³¨çš„æ–¹æ³•ï¼Œå…¶å‚æ•°ä¸ºä¾èµ–ç»„ä»¶
  - é€šè¿‡Injectæ ‡æ³¨çš„æ— å‚æ•°æ–¹æ³•ï¼Œä¼šè¢«è°ƒç”¨
  - æŒ‰ç…§å­ç±»ä¸­çš„è§„åˆ™ï¼Œè¦†ç›–çˆ¶ç±»ä¸­çš„Injectæ–¹æ³•
  - å¦‚æœç»„ä»¶éœ€è¦çš„ä¾èµ–ä¸å­˜åœ¨ï¼Œåˆ™æŠ›å‡ºå¼‚å¸¸
  - å¦‚æœæ–¹æ³•å®šä¹‰ç±»å‹å‚æ•°ï¼Œåˆ™æŠ›å‡ºå¼‚å¸¸
  - å¦‚æœç»„ä»¶é—´å­˜åœ¨å¾ªç¯ä¾èµ–ï¼Œåˆ™æŠ›å‡ºå¼‚å¸¸
- æ–¹æ³•æ³¨å…¥ï¼ˆæ”¹å˜åï¼‰
  
  - é€šè¿‡Injectæ ‡æ³¨çš„æ–¹æ³•ï¼Œå…¶å‚æ•°ä¸ºä¾èµ–ç»„ä»¶
  - é€šè¿‡Injectæ ‡æ³¨çš„æ— å‚æ•°æ–¹æ³•ï¼Œä¼šè¢«è°ƒç”¨
  - æŒ‰ç…§å­ç±»ä¸­çš„è§„åˆ™ï¼Œè¦†ç›–çˆ¶ç±»ä¸­çš„Injectæ–¹æ³•
  - å¦‚æœæ–¹æ³•å®šä¹‰ç±»å‹å‚æ•°ï¼Œåˆ™æŠ›å‡ºå¼‚å¸¸
  - ä¾èµ–ä¸­åº”åŒ…å«Inject Methodå£°æ˜çš„ä¾èµ–

ä¹Ÿå°±æ˜¯è¯´ï¼Œåœ¨è¿™ä¸€åˆ»ï¼Œé™¤äº†åŠŸèƒ½ç‚¹ä¹‹å¤–ï¼Œæˆ‘ä»¬å‡ºç°äº†ä¸¤ä¸ªåŠŸèƒ½ä¸Šä¸‹æ–‡ï¼šComponentProviderå’ŒContextConfigã€‚å¾ˆè‡ªç„¶åœ°ï¼Œè¿å¸¦ç€åˆ†è§£ä»»åŠ¡çš„æ–¹å¼ä¹Ÿå‘ç”Ÿäº†æ”¹å˜ã€‚å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š

![](https://static001.geekbang.org/resource/image/4d/1a/4d1a32142d699ce14f770fc35ac5331a.jpg?wh=2284x1212)  
åŒæ—¶ï¼Œæˆ‘ä»¬çš„é¡¹ç›®è¿˜å‘ç”Ÿè¿‡ä¸¤æ¬¡é‡å¤§çš„**æ¨¡å‹è°ƒæ•´**ï¼š

- ç¬¬ä¸€æ¬¡æ˜¯åœ¨å¼•å…¥Provideræ¥å£çš„æ—¶å€™ã€‚ä¹Ÿå°±æ˜¯é™¤äº†èƒ½å¤Ÿç›´æ¥å¯¹ç»„ä»¶ä¾èµ–å¤–ï¼Œè¿˜å¯ä»¥é€šè¿‡Providerè·å–ç»„ä»¶çš„å·¥å‚ã€‚
- ç¬¬äºŒæ¬¡åˆ™æ˜¯åœ¨å¼•å…¥Qualifierçš„æ—¶å€™ã€‚

ç¬¬ä¸€æ¬¡æ¨¡å‹è°ƒæ•´çš„æ—¶å€™ï¼Œæˆ‘ä»¬å‘ç°ä¹‹å‰éƒ½ä»¥Class&lt;?&gt;ä½œä¸ºè·å–ç»„ä»¶çš„æ ‡è¯†ã€‚è€Œå½“å¼•å…¥Providerä¹‹åï¼Œæˆ‘ä»¬å°±éœ€è¦é€šè¿‡Typeä½œä¸ºè·å–ç»„ä»¶çš„æ ‡è¯†ã€‚æˆ‘ä»¬ä¿®æ”¹äº†ComponentProviderçš„æ¥å£ä½“ç°äº†è¿™ç§å˜åŒ–ï¼š

```
å¼•å…¥Providerä¹‹å‰ï¼š

    public interface ComponentProvider<T> {
        T get(Context context);
        
        default List<Class<?>> getDependencies() {
            return List.of();
        }
    }

å¼•å…¥Providerä¹‹åï¼š

    public interface ComponentProvider<T> {
        T get(Context context);
        
        default List<Type> getDependencies() {
            return List.of();
        }
    }
```

ç¬¬äºŒæ¬¡**æ¨¡å‹è°ƒæ•´**çš„æ—¶å€™ï¼Œæˆ‘ä»¬éœ€è¦å°†Typeå’ŒQualifieræ ‡æ³¨ç»„åˆåœ¨ä¸€èµ·ã€‚äºæ˜¯æˆ‘ä»¬å¼•å…¥äº†ComponentRefï¼ˆæœ€å¼€å§‹å«Refï¼‰å¯¹è±¡ï¼Œä½œä¸ºè·å–ç»„ä»¶çš„æ ‡è¯†ã€‚æˆ‘ä»¬å†æ¬¡ä¿®æ”¹äº†ComponentProviderçš„æ¥å£ï¼š

```
public interface ComponentProvider<T> {
    T get(Context context);
    
    default List<ComponentRef<?>> getDependencies() {
        return List.of();
    }
}
```

**æ¨¡å‹è°ƒæ•´**ä¹‹åï¼ŒContextä¸­çš„ç»„ä»¶å°±ä»å®ä¾‹ç»„ä»¶ï¼ˆInstanceï¼‰å’Œæ³¨å…¥ç»„ä»¶ï¼ˆInjectable Componentï¼‰ï¼Œå˜æˆå®ä¾‹ç»„ä»¶ã€æ³¨å…¥ç»„ä»¶ã€å¸¦Qualifierçš„å®ä¾‹ç»„ä»¶ã€å¸¦Qualifierçš„æ³¨å…¥ç»„ä»¶ä»¥åŠå®ƒä»¬å¯¹åº”çš„Providerå½¢å¼**ç­‰å…«ç§**ã€‚

è¿™ä¹Ÿè¿›ä¸€æ­¥å¸®åŠ©æˆ‘ä»¬ç†è§£äº†è½¯ä»¶çš„éœ€æ±‚ï¼Œå¸®åŠ©æˆ‘ä»¬è¿›ä¸€æ­¥æœ‰æ•ˆç‡åœ°åˆ†è§£äº†ä»»åŠ¡ã€‚å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š

![](https://static001.geekbang.org/resource/image/f7/aa/f7b358b01a14b6407ab2f88f3f1102aa.jpg?wh=2284x1210)  
å¸¦æ¥çš„ç»“æœæ˜¯ï¼Œä»»åŠ¡åˆ—è¡¨å‘ç”Ÿäº†æ›´ä¸ºå‰§çƒˆçš„æ”¹å˜ï¼š

- è‡ªå®šä¹‰Qualifierçš„ä¾èµ–ï¼ˆæœ€å¼€å§‹çš„ä»»åŠ¡ï¼‰
  
  - æ³¨å†Œç»„ä»¶æ—¶ï¼Œå¯é¢å¤–æŒ‡å®šQualifier
  - æ³¨å†Œç»„ä»¶æ—¶ï¼Œå¯ä»ç±»å¯¹è±¡ä¸Šæå–Qualifier
  - å¯»æ‰¾ä¾èµ–æ—¶ï¼Œéœ€åŒæ—¶æ»¡è¶³ç±»å‹ä¸è‡ªå®šä¹‰Qualifieræ ‡æ³¨
  - æ”¯æŒé»˜è®¤Qualifierâ€”â€”Named
- è‡ªå®šä¹‰Qualifierçš„ä¾èµ–ï¼ˆå®é™…å®Œæˆçš„ä»»åŠ¡ï¼‰
  
  - æ³¨å†Œç»„ä»¶æ—¶ï¼Œå¯é¢å¤–æŒ‡å®šQualifier
    
    - é’ˆå¯¹instanceæŒ‡å®šä¸€ä¸ªQualifieriï¼ˆæ–°å¢ä»»åŠ¡ï¼‰
    - é’ˆå¯¹ç»„ä»¶æŒ‡å®šä¸€ä¸ªQualiiferï¼ˆæ–°å¢ä»»åŠ¡ï¼‰
    - é’ˆå¯¹instanceæŒ‡å®šå¤šä¸ªQualifieriï¼ˆæ–°å¢ä»»åŠ¡ï¼‰
    - é’ˆå¯¹ç»„ä»¶æŒ‡å®šå¤šä¸ªQualiiferï¼ˆæ–°å¢ä»»åŠ¡ï¼‰
  - æ³¨å†Œç»„ä»¶æ—¶ï¼Œå¦‚æœä¸æ˜¯åˆæ³•çš„Qualifierï¼Œåˆ™ä¸æ¥å—ç»„ä»¶æ³¨å†Œï¼ˆæ–°å¢ä»»åŠ¡ï¼‰
  - å¯»æ‰¾ä¾èµ–æ—¶ï¼Œéœ€åŒæ—¶æ»¡è¶³ç±»å‹ä¸è‡ªå®šä¹‰Qualifieræ ‡æ³¨
    
    - åœ¨æ£€æŸ¥ä¾èµ–æ—¶ä½¿ç”¨Qualifierï¼ˆæ–°å¢ä»»åŠ¡ï¼‰
    - åœ¨æ£€æŸ¥å¾ªç¯ä¾èµ–æ—¶ä½¿ç”¨Qualifierï¼ˆæ–°å¢ä»»åŠ¡ï¼‰
    - æ„é€ å‡½æ•°æ³¨å…¥å¯ä»¥ä½¿ç”¨Qualifierå£°æ˜ä¾èµ–ï¼ˆæ–°å¢ä»»åŠ¡ï¼‰
      
      - ä¾èµ–ä¸­åŒ…å«Qualifierï¼ˆæ–°å¢ä»»åŠ¡ï¼‰
      - å¦‚æœä¸æ˜¯åˆæ³•çš„Qualifierï¼Œåˆ™ç»„ä»¶éæ³•
    - å­—æ®µæ³¨å…¥å¯ä»¥ä½¿ç”¨Qualifierå£°æ˜ä¾èµ–ï¼ˆæ–°å¢ä»»åŠ¡ï¼‰
      
      - ä¾èµ–ä¸­åŒ…å«Qualifierï¼ˆæ–°å¢ä»»åŠ¡ï¼‰
      - å¦‚æœä¸æ˜¯åˆæ³•çš„Qualifierï¼Œåˆ™ç»„ä»¶éæ³•
    - å‡½æ•°æ³¨å…¥å¯ä»¥ä½¿ç”¨Qualifierå£°æ˜ä¾èµ–ï¼ˆæ–°å¢ä»»åŠ¡ï¼‰
      
      - ä¾èµ–ä¸­åŒ…å«Qualifierï¼ˆæ–°å¢ä»»åŠ¡ï¼‰
      - å¦‚æœä¸æ˜¯åˆæ³•çš„Qualifierï¼Œåˆ™ç»„ä»¶éæ³•
  - æ”¯æŒé»˜è®¤Qualifierâ€”â€”Namedï¼ˆä¸éœ€è¦ï¼‰
  - æ³¨å†Œç»„ä»¶æ—¶ï¼Œå¯ä»ç±»å¯¹è±¡ä¸Šæå–Qualifierï¼ˆä¸éœ€è¦ï¼‰

æˆ‘ä»¬é€šè¿‡**é‡ç»„æµ‹è¯•**ï¼Œä»ç»“æ„ä¸Šæ¢³ç†å¹¶è®°å½•äº†è¿™äº›æ”¹å˜ã€‚å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š

![](https://static001.geekbang.org/resource/image/e0/9c/e09ce21672d1639fec4c51b11fb11a9c.jpeg?wh=1920x1080)

è¿™ç§å¯¹äºæ ¸å¿ƒæ¨¡å‹çš„è°ƒæ•´æ˜¯**ç—›è‹¦çš„**ï¼Œåœ¨å¾ˆå¤šæƒ…å†µä¸‹ï¼Œæ„å‘³ç€è½¯ä»¶éœ€è¦é‡å†™ã€‚æˆ‘ä»¬å±•ç¤ºäº†å¦‚ä½•é€šè¿‡**é‡æ„**æ¥å®Œæˆè¿™ç§æ”¹å†™ï¼Œæ‰€ä»¥è¯·**é‡ç‚¹å›çœ‹**ä¸é‡æ„æœ‰å…³çš„ç« èŠ‚ï¼Œ**åæ€**æˆ‘ä»¬æ˜¯å¦‚ä½•åšåˆ°çš„ã€‚

æœ€åï¼Œæˆ‘çš„ä»£ç æ˜¯è¿™æ ·çš„ï¼š

```
ComponentProvider.java

package geektime.tdd.di;
import java.util.List;
public interface ComponentProvider<T> {
    T get(Context context);
    default List<ComponentRef<?>> getDependencies() {
        return List.of();
    }
}

ComponentRef.java

package geektime.tdd.di;
import java.lang.annotation.Annotation;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.util.Objects;
public class ComponentRef<ComponentType> {
    public static <ComponentType> ComponentRef<ComponentType> of(Class<ComponentType> component) {
        return new ComponentRef<>(component, null);
    }
    public static <ComponentType> ComponentRef<ComponentType> of(Class<ComponentType> component, Annotation qualifier) {
        return new ComponentRef<>(component, qualifier);
    }
    public static ComponentRef<?> of(Type type, Annotation qualifier) {
        return new ComponentRef<>(type, qualifier);
    }
    private Type container;
    private ContextConfig.Component component;
    ComponentRef(Type type, Annotation qualifier) {
        init(type, qualifier);
    }
    protected ComponentRef() {
        this(null);
    }
    protected ComponentRef(Annotation qualifier) {
        Type type = ((ParameterizedType) getClass().getGenericSuperclass()).getActualTypeArguments()[0];
        init(type, qualifier);
    }
    private void init(Type type, Annotation qualifier) {
        if (type instanceof ParameterizedType container) {
            this.container = container.getRawType();
            this.component = new ContextConfig.Component((Class<ComponentType>) container.getActualTypeArguments()[0], qualifier);
        } else
            this.component = new ContextConfig.Component((Class<ComponentType>) type, qualifier);
    }
    public Type getContainer() {
        return container;
    }
    public boolean isContainer() {
        return container != null;
    }
    ContextConfig.Component component() {
        return component;
    }
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        ComponentRef<?> that = (ComponentRef<?>) o;
        return Objects.equals(container, that.container) && component.equals(that.component);
    }
    @Override
    public int hashCode() {
        return Objects.hash(container, component);
    }
}
    
Config.java
 
package geektime.tdd.di;
import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
public interface Config {
    @Documented
    @Retention(RUNTIME)
    @Target({ElementType.FIELD})
    @interface Export {
        Class<?> value();
    }
}
    
Context.java
    
package geektime.tdd.di;
import java.util.Optional;
public interface Context {
    <ComponentType> Optional<ComponentType> get(ComponentRef<ComponentType> ref);
}
    
ContextConfig.java
    
package geektime.tdd.di;
import geektime.tdd.di.ContextConfig.Component;
import jakarta.inject.Provider;
import jakarta.inject.Qualifier;
import jakarta.inject.Scope;
import jakarta.inject.Singleton;
import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.text.MessageFormat;
import java.util.*;
import java.util.function.Function;
import java.util.stream.Stream;
import static geektime.tdd.di.ContextConfigError.circularDependencies;
import static geektime.tdd.di.ContextConfigError.unsatisfiedResolution;
import static geektime.tdd.di.ContextConfigException.illegalAnnotation;
import static java.util.Arrays.spliterator;
import static java.util.Arrays.stream;
import static java.util.stream.Collectors.*;
public class ContextConfig {
    private final Map<Component, ComponentProvider<?>> components = new HashMap<>();
    private final Map<Class<?>, ScopeProvider> scopes = new HashMap<>();
    public ContextConfig() {
        scope(Singleton.class, SingletonProvider::new);
    }
    public <Type> void instance(Class<Type> type, Type instance) {
        bind(new Component(type, null), context -> instance);
    }
    public <Type> void instance(Class<Type> type, Type instance, Annotation... annotations) {
        bindInstance(type, instance, annotations);
    }
    public <Type, Implementation extends Type>
    void component(Class<Type> type, Class<Implementation> implementation, Annotation... annotations) {
        bindComponent(type, implementation, annotations);
    }
    public <ScopeType extends Annotation> void scope(Class<ScopeType> scope, ScopeProvider provider) {
        scopes.put(scope, provider);
    }
    public void from(Config config) {
        new DSL(config).bind();
    }
    public Context getContext() {
        components.keySet().forEach(component -> checkDependencies(component, new Stack<>()));
        HashMap<Component, ComponentProvider<?>> context = new HashMap<>(components);
        return new Context() {
            @Override
            public <ComponentType> Optional<ComponentType> get(ComponentRef<ComponentType> ref) {
                if (ref.isContainer()) {
                    if (ref.getContainer() != Provider.class) return Optional.empty();
                    return (Optional<ComponentType>) Optional.ofNullable(getProvider(ref))
                            .map(provider -> (Provider<Object>) () -> provider.get(this));
                }
                return Optional.ofNullable(getProvider(ref)).map(provider -> (ComponentType) provider.get(this));
            }
            private <ComponentType> ComponentProvider<?> getProvider(ComponentRef<ComponentType> ref) {
                return context.get(ref.component());
            }
        };
    }
    private void bindComponent(Class<?> type, Class<?> implementation, Annotation... annotations) {
        Bindings bindings = Bindings.component(implementation, annotations);
        bind(type, bindings.qualifiers(), provider(implementation, bindings.scope()));
    }
    private void bindInstance(Class<?> type, Object instance, Annotation[] annotations) {
        bind(type, Bindings.instance(type, annotations).qualifiers(), context -> instance);
    }
    private <Type> void bind(Class<Type> type, List<Annotation> qualifiers, ComponentProvider<?> provider) {
        if (qualifiers.isEmpty()) bind(new Component(type, null), provider);
        for (Annotation qualifier : qualifiers)
            bind(new Component(type, qualifier), provider);
    }
    private void bind(Component component, ComponentProvider<?> provider) {
        if (components.containsKey(component)) throw ContextConfigException.duplicated(component);
        components.put(component, provider);
    }
    private <Type> ComponentProvider<?> provider(Class<Type> implementation, Optional<Annotation> scope) {
        ComponentProvider<?> injectionProvider = new InjectionProvider<>(implementation);
        return scope.<ComponentProvider<?>>map(s -> scoped(s, injectionProvider)).orElse(injectionProvider);
    }
    private ComponentProvider<?> scoped(Annotation scope, ComponentProvider<?> provider) {
        if (!scopes.containsKey(scope.annotationType()))
            throw ContextConfigException.unknownScope(scope.annotationType());
        return scopes.get(scope.annotationType()).create(provider);
    }
    private void checkDependencies(Component component, Stack<Component> visiting) {
        for (ComponentRef<?> dependency : components.get(component).getDependencies()) {
            if (!components.containsKey(dependency.component()))
                throw unsatisfiedResolution(component, dependency.component());
            if (!dependency.isContainer()) {
                if (visiting.contains(dependency.component()))
                    throw circularDependencies(visiting, dependency.component());
                visiting.push(dependency.component());
                checkDependencies(dependency.component(), visiting);
                visiting.pop();
            }
        }
    }
    record Component(Class<?> type, Annotation qualifier) {
    }
    static class Bindings {
        public static Bindings component(Class<?> component, Annotation... annotations) {
            return new Bindings(component, annotations, Qualifier.class, Scope.class);
        }
        public static Bindings instance(Class<?> instance, Annotation... annotations) {
            return new Bindings(instance, annotations, Qualifier.class);
        }
        Class<?> type;
        Map<Class<?>, List<Annotation>> group;
        public Bindings(Class<?> type, Annotation[] annotations, Class<? extends Annotation>... allowed) {
            this.type = type;
            this.group = parse(type, annotations, allowed);
        }
        private static Map<Class<?>, List<Annotation>> parse(Class<?> type, Annotation[] annotations, Class<? extends Annotation>... allowed) {
            Map<Class<?>, List<Annotation>> annotationGroups = stream(annotations).collect(groupingBy(allow(allowed), toList()));
            if (annotationGroups.containsKey(Illegal.class))
                throw illegalAnnotation(type, annotationGroups.get(Illegal.class));
            return annotationGroups;
        }
        private static Function<Annotation, Class<?>> allow(Class<? extends Annotation>... annotations) {
            return annotation -> Stream.of(annotations).filter(annotation.annotationType()::isAnnotationPresent)
                    .findFirst().orElse(Illegal.class);
        }
        private @interface Illegal {
        }
        Optional<Annotation> scope() {
            List<Annotation> scopes = group.getOrDefault(Scope.class, from(type, Scope.class));
            if (scopes.size() > 1) throw illegalAnnotation(type, scopes);
            return scopes.stream().findFirst();
        }
        List<Annotation> qualifiers() {
            return group.getOrDefault(Qualifier.class, List.of());
        }
        private static List<Annotation> from(Class<?> implementation, Class<? extends Annotation> annotation) {
            return stream(implementation.getAnnotations()).filter(a -> a.annotationType().isAnnotationPresent(annotation)).toList();
        }
    }
    class DSL {
        private Config config;
        public DSL(Config config) {
            this.config = config;
        }
        void bind() {
            for (Declaration declaration : declarations())
                declaration.value().ifPresentOrElse(declaration::bindInstance, declaration::bindComponent);
        }
        private List<Declaration> declarations() {
            return stream(config.getClass().getDeclaredFields()).filter(f -> !f.isSynthetic()).map(Declaration::new).toList();
        }
        class Declaration {
            private Field field;
            Declaration(Field field) {
                this.field = field;
            }
            void bindInstance(Object instance) {
                ContextConfig.this.bindInstance(type(), instance, annotations());
            }
            void bindComponent() {
                ContextConfig.this.bindComponent(type(), field.getType(), annotations());
            }
            private Optional<Object> value() {
                try {
                    return Optional.ofNullable(field.get(config));
                } catch (IllegalAccessException e) {
                    throw new RuntimeException(e);
                }
            }
            private Class<?> type() {
                Config.Export export = field.getAnnotation(Config.Export.class);
                return export != null ? export.value() : field.getType();
            }
            private Annotation[] annotations() {
                return stream(field.getAnnotations()).filter(a -> a.annotationType() != Config.Export.class).toArray(Annotation[]::new);
            }
        }
    }
}
    
class ContextConfigError extends Error {
    public static ContextConfigError unsatisfiedResolution(Component component, Component dependency) {
        return new ContextConfigError(MessageFormat.format("Unsatisfied resolution: {1} for {0} ", component, dependency));
    }
    public static ContextConfigError circularDependencies(Collection<Component> path, Component circular) {
        return new ContextConfigError(MessageFormat.format("Circular dependencies: {0} -> [{1}]",
                path.stream().map(Objects::toString).collect(joining(" -> ")), circular));
    }
    ContextConfigError(String message) {
        super(message);
    }
}
class ContextConfigException extends RuntimeException {
    static ContextConfigException illegalAnnotation(Class<?> type, List<Annotation> annotations) {
        return new ContextConfigException(MessageFormat.format("Unqualified annotations: {0} of {1}",
                String.join(" , ", annotations.stream().map(Object::toString).toList()), type));
    }
    static ContextConfigException unknownScope(Class<? extends Annotation> annotationType) {
        return new ContextConfigException(MessageFormat.format("Unknown scope: {0}", annotationType));
    }
    static ContextConfigException duplicated(Component component) {
        return new ContextConfigException(MessageFormat.format("Duplicated: {0}", component));
    }
    ContextConfigException(String message) {
        super(message);
    }
}
    
InjectionProvider.java
    
package geektime.tdd.di;
import jakarta.inject.Inject;
import jakarta.inject.Qualifier;
import java.lang.annotation.Annotation;
import java.lang.reflect.*;
import java.text.MessageFormat;
import java.util.*;
import java.util.function.BiFunction;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import static geektime.tdd.di.ComponentError.*;
import static java.util.Arrays.stream;
import static java.util.stream.Stream.concat;
class InjectionProvider<T> implements ComponentProvider<T> {
    private final Injectable<Constructor<T>> injectConstructor;
    private final Map<Class<?>, List<Injectable<Method>>> injectMethods;
    private final Map<Class<?>, List<Injectable<Field>>> injectFields;
    private final Collection<Class<?>> superClasses;
    private final List<ComponentRef<?>> dependencies;
    public InjectionProvider(Class<T> component) {
        this.injectConstructor = getInjectConstructor(component);
        this.superClasses = allSuperClass(component);
        var injectFields = getInjectFields(component);
        var injectMethods = getInjectMethods(component);
        this.dependencies = concat(concat(Stream.of(injectConstructor), injectFields.stream()), injectMethods.stream())
                .map(Injectable::required).flatMap(Arrays::stream).toList();
        this.injectFields = groupByClass(injectFields);
        this.injectMethods = groupByClass(injectMethods);
    }
    @Override
    public T get(Context context) {
        try {
            T instance = injectConstructor.element().newInstance(injectConstructor.toDependencies(context));
            for (Class<?> c : superClasses) {
                for (Injectable<Field> field : injectFields.getOrDefault(c, List.of()))
                    field.element().set(instance, field.toDependencies(context)[0]);
                for (Injectable<Method> method : injectMethods.getOrDefault(c, List.of()))
                    method.element().invoke(instance, method.toDependencies(context));
            }
            return instance;
        } catch (InvocationTargetException | InstantiationException | IllegalAccessException e) {
            throw new RuntimeException(e);
        }
    }
    @Override
    public List<ComponentRef<?>> getDependencies() {
        return dependencies;
    }
    record Injectable<Element extends AccessibleObject>(Element element, ComponentRef<?>[] required) {
        Object[] toDependencies(Context context) {
            return stream(required).map(context::get).map(Optional::get).toArray();
        }
        static <Element extends Executable> Injectable<Element> of(Element element) {
            element.setAccessible(true);
            return new Injectable<>(element, stream(element.getParameters()).map(Injectable::toComponentRef).toArray(ComponentRef<?>[]::new));
        }
        static Injectable<Field> of(Field field) {
            field.setAccessible(true);
            return new Injectable<>(field, new ComponentRef<?>[]{toComponentRef(field)});
        }
        private static ComponentRef<?> toComponentRef(Field field) {
            return ComponentRef.of(field.getGenericType(), getQualifier(field));
        }
        private static ComponentRef<?> toComponentRef(Parameter parameter) {
            return ComponentRef.of(parameter.getParameterizedType(), getQualifier(parameter));
        }
        private static Annotation getQualifier(AnnotatedElement element) {
            List<Annotation> qualifiers = stream(element.getAnnotations())
                    .filter(a -> a.annotationType().isAnnotationPresent(Qualifier.class)).toList();
            if (qualifiers.size() > 1) throw ComponentError.ambiguousQualifiers(element, qualifiers);
            return qualifiers.stream().findFirst().orElse(null);
        }
    }
    private static <T> List<Injectable<Method>> getInjectMethods(Class<T> component) {
        List<Method> injectMethods = traverse(component, (methods, current) -> injectable(current.getDeclaredMethods())
                .filter(m -> isOverrideByInjectMethod(methods, m))
                .filter(m -> isOverrideByNoInjectMethod(component, m)).toList());
        List<Injectable<Method>> injectableMethods = injectMethods.stream().map(Injectable::of).toList();
        return check(component, injectableMethods, InjectionProvider::noTypeParameter, ComponentError::injectMethodsWithTypeParameter);
    }
    private static <T> List<Injectable<Field>> getInjectFields(Class<T> component) {
        List<Injectable<Field>> injectableFields = InjectionProvider.<Field>traverse(component, (fields, current) -> injectable(current.getDeclaredFields()).toList())
                .stream().map(Injectable::of).toList();
        return check(component, injectableFields, InjectionProvider::notFinal, ComponentError::finalInjectFields);
    }
    private static <Type> Injectable<Constructor<Type>> getInjectConstructor(Class<Type> implementation) {
        if (Modifier.isAbstract(implementation.getModifiers())) throw abstractComponent(implementation);
        List<Constructor<?>> injectConstructors = injectable(implementation.getDeclaredConstructors()).toList();
        if (injectConstructors.size() > 1) throw ambiguousInjectableConstructors(implementation);
        return Injectable.of((Constructor<Type>) injectConstructors.stream().findFirst().orElseGet(() -> defaultConstructor(implementation)));
    }
    private static <Type> Constructor<Type> defaultConstructor(Class<Type> implementation) {
        try {
            return implementation.getDeclaredConstructor();
        } catch (NoSuchMethodException e) {
            throw noDefaultConstructor(implementation);
        }
    }
    private static <E extends AccessibleObject> Map<Class<?>, List<Injectable<E>>> groupByClass(List<Injectable<E>> injectFields) {
        return injectFields.stream().collect(Collectors.groupingBy(i -> ((Member)i.element()).getDeclaringClass(), Collectors.toList()));
    }
    private static Collection<Class<?>> allSuperClass(Class<?> component) {
        List<Class<?>> result = new ArrayList<>();
        for (Class superClass = component;
             superClass != Object.class;
             superClass = superClass.getSuperclass())
            result.add(0, superClass);
        return result;
    }
    private static <T> List<T> traverse(Class<?> component, BiFunction<List<T>, Class<?>, List<T>> finder) {
        List<T> members = new ArrayList<>();
        Class<?> current = component;
        while (current != Object.class) {
            members.addAll(finder.apply(members, current));
            current = current.getSuperclass();
        }
        return members;
    }
    private static <T extends AnnotatedElement> Stream<T> injectable(T[] declaredFields) {
        return stream(declaredFields).filter(f -> f.isAnnotationPresent(Inject.class));
    }
    private static boolean isOverride(Method m, Method o) {
        boolean visible;
        if (m.getDeclaringClass().getPackageName().equals(o.getDeclaringClass().getPackageName()))
            visible = !Modifier.isPrivate(o.getModifiers()) && !Modifier.isPrivate(m.getModifiers());
        else visible = (Modifier.isPublic(o.getModifiers()) || Modifier.isProtected(o.getModifiers()))
                && (Modifier.isPublic(m.getModifiers()) || Modifier.isProtected(m.getModifiers()));
        return visible && o.getName().equals(m.getName()) && Arrays.equals(o.getParameterTypes(), m.getParameterTypes());
    }
    private static <T> boolean isOverrideByNoInjectMethod(Class<T> component, Method m) {
        return stream(component.getDeclaredMethods()).filter(m1 -> !m1.isAnnotationPresent(Inject.class)).noneMatch(o -> isOverride(m, o));
    }
    private static boolean isOverrideByInjectMethod(List<Method> injectMethods, Method m) {
        return injectMethods.stream().noneMatch(o -> isOverride(m, o));
    }
    private static <Element extends AccessibleObject> List<Injectable<Element>> check(Class<?> component, List<Injectable<Element>> target, Predicate<Element> predicate,
                                                                                      BiFunction<Class<?>, List<Element>, ComponentError> error) {
        List<Element> found = target.stream().map(Injectable::element).filter(predicate).toList();
        if (found.size() > 0) throw error.apply(component, found.stream().toList());
        return target;
    }
    private static boolean notFinal(Field field) {
        return Modifier.isFinal(field.getModifiers());
    }
    private static boolean noTypeParameter(Method method) {
        return method.getTypeParameters().length != 0;
    }
}
class ComponentError extends Error {
    public static ComponentError abstractComponent(Class<?> component) {
        return new ComponentError(MessageFormat.format("Can not be abstract: {0}", component));
    }
    public static ComponentError finalInjectFields(Class<?> component, Collection<Field> fields) {
        return new ComponentError(MessageFormat.format("Injectable field can not be final: {0} in {1}",
                String.join(" , ", fields.stream().map(Field::getName).toList()), component));
    }
    public static ComponentError injectMethodsWithTypeParameter(Class<?> component, Collection<Method> fields) {
        return new ComponentError(MessageFormat.format("Injectable method can not have type parameter: {0} in {1}",
                String.join(" , ", fields.stream().map(Method::getName).toList()), component));
    }
    public static ComponentError ambiguousInjectableConstructors(Class<?> component) {
        return new ComponentError(MessageFormat.format("Ambiguous injectable constructors: {0}", component));
    }
    public static ComponentError noDefaultConstructor(Class<?> component) {
        return new ComponentError(MessageFormat.format("No default constructors: {0}", component));
    }
    public static ComponentError ambiguousQualifiers(AnnotatedElement element, List<Annotation> qualifiers) {
        Class<?> component;
        if (element instanceof Parameter p) component = p.getDeclaringExecutable().getDeclaringClass();
        else component = ((Field) element).getDeclaringClass();
        return new ComponentError(MessageFormat.format("Ambiguous qualifiers: {0} on {1} of {2}",
                String.join(" , ", qualifiers.stream().map(Object::toString).toList()), element, component));
    }
    ComponentError(String message) {
        super(message);
    }
}
    
ScopeProvider.java
    
package geektime.tdd.di;
public interface ScopeProvider {
    ComponentProvider<?> create(ComponentProvider<?> provider);
}
   
SingletonProvider.java
    
package geektime.tdd.di;
import java.util.List;
class SingletonProvider<T> implements ComponentProvider<T> {
    private T singleton;
    private ComponentProvider<T> provider;
    public SingletonProvider(ComponentProvider<T> provider) {
        this.provider = provider;
    }
    @Override
    public T get(Context context) {
        if (singleton == null) singleton = provider.get(context);
        return singleton;
    }
    @Override
    public List<ComponentRef<?>> getDependencies() {
        return provider.getDependencies();
    }
}
```

## æ€è€ƒé¢˜

åœ¨è¿›å…¥ä¸‹èŠ‚è¯¾ä¹‹å‰ï¼Œå¸Œæœ›ä½ èƒ½è®¤çœŸæ€è€ƒå¦‚ä¸‹ä¸¤ä¸ªé—®é¢˜ã€‚

1. è¯·å¢åŠ staticæ³¨å…¥ï¼Œå¹¶é€šè¿‡Jakarta Inject TCKã€‚
2. è¯·å›é¡¾æ•´ä¸ªé¡¹ç›®å®è·µï¼Œçœ‹çœ‹è·Ÿæœ€å¼€å§‹å­¦ä¹ TDDç›¸æ¯”ï¼Œéƒ½æœ‰å“ªäº›è¿›æ­¥å’Œæ”¹å˜ã€‚

ä¸æˆ‘ä»¬å®é™…å·¥ä½œä¸­çš„é¡¹ç›®ç›¸æ¯”ï¼ŒDI Containerè¿™ä¸ªæ¡†æ¶çº§å®æˆ˜çš„å¤æ‚åº¦è¦ç•¥å¾®é«˜ä¸€äº›ã€‚ç»è¿‡è¿™ä¸‰ä¸ªæœˆçš„å­¦ä¹ ï¼Œé™¤äº†æå‡ä½ çš„æŠ€æœ¯èƒ½åŠ›å¤–ï¼Œç›¸ä¿¡å¯¹ä½ çš„å­¦ä¹ èƒ½åŠ›ä¹Ÿæœ‰ä¸å°çš„ç£¨ç»ƒã€‚æ‰€ä»¥ï¼ŒåšæŒåˆ°è¿™ä¸€ç«™çš„åŒå­¦ä»¬ï¼Œè¯·ä¸ºè‡ªå·±ç‚¹ä¸ªèµå§ï¼
<div><strong>ç²¾é€‰ç•™è¨€ï¼ˆ4ï¼‰</strong></div><ul>
<li><span>å¼ é“æ—</span> ğŸ‘ï¼ˆ2ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>ä¸»è¦è¿˜æ˜¯å¼€é˜”äº†çœ¼ç•Œï¼Œç”¨TDDæ¥åšä¸€ä¸ªç›¸å¯¹å¤æ‚çš„åŠŸèƒ½ï¼Œä¸åƒå¾ˆå¤škataé‚£æ ·ï¼ŒçŸ­çŸ­å‡ åè¡Œä»£ç é‡ï¼Œä½“ä¼šä¸åˆ°ä¸æ–­çš„é‡æ„å’Œæ·±è¿›ã€‚</p>2022-06-04</li><br/><li><span>aoe</span> ğŸ‘ï¼ˆ1ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>è¿™æ¬¡è¦æ±‚ä¸­æœ€å®¹æ˜“åšåˆ°çš„å°±æ˜¯ä¸ºè‡ªå·±ç‚¹ä¸ªèµï¼Œæˆ‘å·²ç»ç‚¹äº†ï¼
æœ€å¼€å§‹å­¦ä¹  TDD ç›¸æ¯”ï¼šå­¦ä¼šä½¿ç”¨ @Nested æ ‡ç­¾ï¼›å­¦ä¼šäº†æ³›å‹ä¸­ ?ã€T ä¹‹ç±»çš„å«ä¹‰ï¼›æœ‰æµ‹è¯•åšä¿éšœæƒ³é‡æ„å°±é‡æ„</p>2022-06-02</li><br/><li><span>æ«ä¸­çš„åˆ€å‰‘</span> ğŸ‘ï¼ˆ2ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>ç¬¬ä¸€æ¬¡é™è·ç¦»è§‚å¯Ÿä¸€ä¸ªå®Œæ•´é¡¹ç›®çš„TDDè¿‡ç¨‹ï¼Œæ„Ÿå—è¿˜æ˜¯æŒºæ·±çš„ã€‚ç‰¹åˆ«æ˜¯ç¬¬ä¸€æ¬¡æ¥è§¦åˆ°æµ‹è¯•é‡ç»„ã€æµ‹è¯•æ–‡æ¡£åŒ–çš„æ—¶å€™æœ‰ç§çœ¼å‰ä¸€äº®çš„æ„Ÿè§‰ã€‚è€Œå…¶ä¸­ComponentRef æ¨¡å‹å’Œ Qualifier æ¨¡å‹è°ƒæ•´çš„é‡æ„è¿‡ç¨‹æ›´åŠ è®©äººèµå¿ƒæ‚¦ç›®ã€‚æ–°çš„æ¨¡å‹å¼•å…¥æ‹“å±•äº†çŸ¥è¯†ï¼Œå¸¦æ¥ä¸ªæ›´åŠ æ˜ç¡®çš„åŠŸèƒ½ä¸Šä¸‹æ–‡åˆ’åˆ†ã€‚è€ŒåŸæœ‰æ•´ä½“çš„ç»“æ„å´æ²¡æœ‰å‘ç”Ÿå¤ªå¤šçš„å˜åŒ–ã€‚è¿™ç§ä¸€ç‚¹ç‚¹è¿›æ­¥æ˜¯èƒ½å¤Ÿå¾ˆæ¸…æ¥šçš„æ„Ÿå—åˆ°çš„ã€‚

æœ€ååœ¨é™„ä¸Šé¡¹ç›®é“¾æ¥ï¼šhttps:&#47;&#47;github.com&#47;maplestoryJin&#47;DiContainer  
åŒ…æ‹¬ static æ³¨å…¥å®ç°ã€‚</p>2022-06-10</li><br/><li><span>ä¸´é£</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>æœ‰ä¸ªå…³äºbindçš„å®ç°é—®é¢˜ï¼Œä¸€èˆ¬æƒ…å†µéƒ½æ˜¯bind(Component.class, Instance.class)æˆ–è€…bind(Component.class, Provider&lt;Instance.class&gt;)ã€‚å¦‚æœç›´æ¥bind(Instance.class, Instance.class)ï¼Œé‚£ä¹ˆget(Component.class)è¿˜èƒ½æ‰¾åˆ°å—ï¼Ÿ
å¦å¤–ï¼Œæ— è®ºbindçš„æ˜¯Intanceè¿˜æ˜¯Providerï¼Œå½“éœ€è¦æ³¨å…¥Providerç±»å‹çš„æ—¶å€™ï¼Œæ˜¯éƒ½éœ€è¦æ”¯æŒå—ï¼Ÿ
è¿™äº›è§„èŒƒçš„ä¸œè¥¿æˆ‘å¯ä»¥å»å“ªé‡Œæ‰¾åˆ°ï¼Œå¸Œæœ›è€å¸ˆèƒ½è§£ç­”ä¸€ä¸‹ã€‚</p>2022-06-06</li><br/>
</ul>