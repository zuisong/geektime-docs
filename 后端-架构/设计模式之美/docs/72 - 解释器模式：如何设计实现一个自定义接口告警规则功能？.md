ä¸Šä¸€èŠ‚è¯¾ï¼Œæˆ‘ä»¬å­¦ä¹ äº†å‘½ä»¤æ¨¡å¼ã€‚å‘½ä»¤æ¨¡å¼å°†è¯·æ±‚å°è£…æˆå¯¹è±¡ï¼Œæ–¹ä¾¿ä½œä¸ºå‡½æ•°å‚æ•°ä¼ é€’å’Œèµ‹å€¼ç»™å˜é‡ã€‚å®ƒä¸»è¦çš„åº”ç”¨åœºæ™¯æ˜¯ç»™å‘½ä»¤çš„æ‰§è¡Œé™„åŠ åŠŸèƒ½ï¼Œæ¢å¥è¯è¯´ï¼Œå°±æ˜¯æ§åˆ¶å‘½ä»¤çš„æ‰§è¡Œï¼Œæ¯”å¦‚ï¼Œæ’é˜Ÿã€å¼‚æ­¥ã€å»¶è¿Ÿæ‰§è¡Œå‘½ä»¤ã€ç»™å‘½ä»¤æ‰§è¡Œè®°å½•æ—¥å¿—ã€æ’¤é”€é‡åšå‘½ä»¤ç­‰ç­‰ã€‚æ€»ä½“ä¸Šæ¥è®²ï¼Œå‘½ä»¤æ¨¡å¼çš„åº”ç”¨èŒƒå›´å¹¶ä¸å¹¿ã€‚

ä»Šå¤©ï¼Œæˆ‘ä»¬æ¥å­¦ä¹ è§£é‡Šå™¨æ¨¡å¼ï¼Œå®ƒç”¨æ¥æè¿°å¦‚ä½•æ„å»ºä¸€ä¸ªç®€å•çš„â€œè¯­è¨€â€è§£é‡Šå™¨ã€‚æ¯”èµ·å‘½ä»¤æ¨¡å¼ï¼Œè§£é‡Šå™¨æ¨¡å¼æ›´åŠ å°ä¼—ï¼Œåªåœ¨ä¸€äº›ç‰¹å®šçš„é¢†åŸŸä¼šè¢«ç”¨åˆ°ï¼Œæ¯”å¦‚ç¼–è¯‘å™¨ã€è§„åˆ™å¼•æ“ã€æ­£åˆ™è¡¨è¾¾å¼ã€‚æ‰€ä»¥ï¼Œè§£é‡Šå™¨æ¨¡å¼ä¹Ÿä¸æ˜¯æˆ‘ä»¬å­¦ä¹ çš„é‡ç‚¹ï¼Œä½ ç¨å¾®äº†è§£ä¸€ä¸‹å°±å¯ä»¥äº†ã€‚

è¯ä¸å¤šè¯´ï¼Œè®©æˆ‘ä»¬æ­£å¼å¼€å§‹ä»Šå¤©çš„å­¦ä¹ å§ï¼

## è§£é‡Šå™¨æ¨¡å¼çš„åŸç†å’Œå®ç°

è§£é‡Šå™¨æ¨¡å¼çš„è‹±æ–‡ç¿»è¯‘æ˜¯Interpreter Design Patternã€‚åœ¨GoFçš„ã€Šè®¾è®¡æ¨¡å¼ã€‹ä¸€ä¹¦ä¸­ï¼Œå®ƒæ˜¯è¿™æ ·å®šä¹‰çš„ï¼š

> Interpreter pattern is used to defines a grammatical representation for a language and provides an interpreter to deal with this grammar.

ç¿»è¯‘æˆä¸­æ–‡å°±æ˜¯ï¼šè§£é‡Šå™¨æ¨¡å¼ä¸ºæŸä¸ªè¯­è¨€å®šä¹‰å®ƒçš„è¯­æ³•ï¼ˆæˆ–è€…å«æ–‡æ³•ï¼‰è¡¨ç¤ºï¼Œå¹¶å®šä¹‰ä¸€ä¸ªè§£é‡Šå™¨ç”¨æ¥å¤„ç†è¿™ä¸ªè¯­æ³•ã€‚

çœ‹äº†å®šä¹‰ï¼Œä½ ä¼°è®¡ä¼šä¸€å¤´é›¾æ°´ï¼Œå› ä¸ºè¿™é‡Œé¢æœ‰å¾ˆå¤šæˆ‘ä»¬å¹³æ—¶å¼€å‘ä¸­å¾ˆå°‘æ¥è§¦çš„æ¦‚å¿µï¼Œæ¯”å¦‚â€œè¯­è¨€â€â€œè¯­æ³•â€â€œè§£é‡Šå™¨â€ã€‚å®é™…ä¸Šï¼Œè¿™é‡Œçš„â€œè¯­è¨€â€ä¸ä»…ä»…æŒ‡æˆ‘ä»¬å¹³æ—¶è¯´çš„ä¸­ã€è‹±ã€æ—¥ã€æ³•ç­‰å„ç§è¯­è¨€ã€‚ä»å¹¿ä¹‰ä¸Šæ¥è®²ï¼Œåªè¦æ˜¯èƒ½æ‰¿è½½ä¿¡æ¯çš„è½½ä½“ï¼Œæˆ‘ä»¬éƒ½å¯ä»¥ç§°ä¹‹ä¸ºâ€œè¯­è¨€â€ï¼Œæ¯”å¦‚ï¼Œå¤ä»£çš„ç»“ç»³è®°äº‹ã€ç›²æ–‡ã€å“‘è¯­ã€æ‘©æ–¯å¯†ç ç­‰ã€‚

è¦æƒ³äº†è§£â€œè¯­è¨€â€è¡¨è¾¾çš„ä¿¡æ¯ï¼Œæˆ‘ä»¬å°±å¿…é¡»å®šä¹‰ç›¸åº”çš„è¯­æ³•è§„åˆ™ã€‚è¿™æ ·ï¼Œä¹¦å†™è€…å°±å¯ä»¥æ ¹æ®è¯­æ³•è§„åˆ™æ¥ä¹¦å†™â€œå¥å­â€ï¼ˆä¸“ä¸šç‚¹çš„å«æ³•åº”è¯¥æ˜¯â€œè¡¨è¾¾å¼â€ï¼‰ï¼Œé˜…è¯»è€…æ ¹æ®è¯­æ³•è§„åˆ™æ¥é˜…è¯»â€œå¥å­â€ï¼Œè¿™æ ·æ‰èƒ½åšåˆ°ä¿¡æ¯çš„æ­£ç¡®ä¼ é€’ã€‚è€Œæˆ‘ä»¬è¦è®²çš„è§£é‡Šå™¨æ¨¡å¼ï¼Œå…¶å®å°±æ˜¯ç”¨æ¥å®ç°æ ¹æ®è¯­æ³•è§„åˆ™è§£è¯»â€œå¥å­â€çš„è§£é‡Šå™¨ã€‚

ä¸ºäº†è®©ä½ æ›´å¥½åœ°ç†è§£å®šä¹‰ï¼Œæˆ‘ä¸¾ä¸€ä¸ªæ¯”è¾ƒè´´è¿‘ç”Ÿæ´»çš„ä¾‹å­æ¥è§£é‡Šä¸€ä¸‹ã€‚

å®é™…ä¸Šï¼Œç†è§£è¿™ä¸ªæ¦‚å¿µï¼Œæˆ‘ä»¬å¯ä»¥ç±»æ¯”ä¸­è‹±æ–‡ç¿»è¯‘ã€‚æˆ‘ä»¬çŸ¥é“ï¼ŒæŠŠè‹±æ–‡ç¿»è¯‘æˆä¸­æ–‡æ˜¯æœ‰ä¸€å®šè§„åˆ™çš„ã€‚è¿™ä¸ªè§„åˆ™å°±æ˜¯å®šä¹‰ä¸­çš„â€œè¯­æ³•â€ã€‚æˆ‘ä»¬å¼€å‘ä¸€ä¸ªç±»ä¼¼Google Translateè¿™æ ·çš„ç¿»è¯‘å™¨ï¼Œè¿™ä¸ªç¿»è¯‘å™¨èƒ½å¤Ÿæ ¹æ®è¯­æ³•è§„åˆ™ï¼Œå°†è¾“å…¥çš„ä¸­æ–‡ç¿»è¯‘æˆè‹±æ–‡ã€‚è¿™é‡Œçš„ç¿»è¯‘å™¨å°±æ˜¯è§£é‡Šå™¨æ¨¡å¼å®šä¹‰ä¸­çš„â€œè§£é‡Šå™¨â€ã€‚

åˆšåˆšç¿»è¯‘å™¨è¿™ä¸ªä¾‹å­æ¯”è¾ƒè´´è¿‘ç”Ÿæ´»ï¼Œç°åœ¨ï¼Œæˆ‘ä»¬å†ä¸¾ä¸ªæ›´åŠ è´´è¿‘ç¼–ç¨‹çš„ä¾‹å­ã€‚

å‡è®¾æˆ‘ä»¬å®šä¹‰äº†ä¸€ä¸ªæ–°çš„åŠ å‡ä¹˜é™¤è®¡ç®—â€œè¯­è¨€â€ï¼Œè¯­æ³•è§„åˆ™å¦‚ä¸‹ï¼š

- è¿ç®—ç¬¦åªåŒ…å«åŠ ã€å‡ã€ä¹˜ã€é™¤ï¼Œå¹¶ä¸”æ²¡æœ‰ä¼˜å…ˆçº§çš„æ¦‚å¿µï¼›
- è¡¨è¾¾å¼ï¼ˆä¹Ÿå°±æ˜¯å‰é¢æåˆ°çš„â€œå¥å­â€ï¼‰ä¸­ï¼Œå…ˆä¹¦å†™æ•°å­—ï¼Œåä¹¦å†™è¿ç®—ç¬¦ï¼Œç©ºæ ¼éš”å¼€ï¼›
- æŒ‰ç…§å…ˆåé¡ºåºï¼Œå–å‡ºä¸¤ä¸ªæ•°å­—å’Œä¸€ä¸ªè¿ç®—ç¬¦è®¡ç®—ç»“æœï¼Œç»“æœé‡æ–°æ”¾å…¥æ•°å­—çš„æœ€å¤´éƒ¨ä½ç½®ï¼Œå¾ªç¯ä¸Šè¿°è¿‡ç¨‹ï¼Œç›´åˆ°åªå‰©ä¸‹ä¸€ä¸ªæ•°å­—ï¼Œè¿™ä¸ªæ•°å­—å°±æ˜¯è¡¨è¾¾å¼æœ€ç»ˆçš„è®¡ç®—ç»“æœã€‚

æˆ‘ä»¬ä¸¾ä¸ªä¾‹å­æ¥è§£é‡Šä¸€ä¸‹ä¸Šé¢çš„è¯­æ³•è§„åˆ™ã€‚

æ¯”å¦‚â€œ 8 3 2 4 - + * â€è¿™æ ·ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œæˆ‘ä»¬æŒ‰ç…§ä¸Šé¢çš„è¯­æ³•è§„åˆ™æ¥å¤„ç†ï¼Œå–å‡ºæ•°å­—â€œ8 3â€å’Œâ€œ-â€è¿ç®—ç¬¦ï¼Œè®¡ç®—å¾—åˆ°5ï¼Œäºæ˜¯è¡¨è¾¾å¼å°±å˜æˆäº†â€œ 5 2 4 + * â€ã€‚ç„¶åï¼Œæˆ‘ä»¬å†å–å‡ºâ€œ 5 2 â€å’Œâ€œ + â€è¿ç®—ç¬¦ï¼Œè®¡ç®—å¾—åˆ°7ï¼Œè¡¨è¾¾å¼å°±å˜æˆäº†â€œ 7 4 * â€ã€‚æœ€åï¼Œæˆ‘ä»¬å–å‡ºâ€œ 7 4â€å’Œâ€œ * â€è¿ç®—ç¬¦ï¼Œæœ€ç»ˆå¾—åˆ°çš„ç»“æœå°±æ˜¯28ã€‚

çœ‹æ‡‚äº†ä¸Šé¢çš„è¯­æ³•è§„åˆ™ï¼Œæˆ‘ä»¬å°†å®ƒç”¨ä»£ç å®ç°å‡ºæ¥ï¼Œå¦‚ä¸‹æ‰€ç¤ºã€‚ä»£ç éå¸¸ç®€å•ï¼Œç”¨æˆ·æŒ‰ç…§ä¸Šé¢çš„è§„åˆ™ä¹¦å†™è¡¨è¾¾å¼ï¼Œä¼ é€’ç»™interpret()å‡½æ•°ï¼Œå°±å¯ä»¥å¾—åˆ°æœ€ç»ˆçš„è®¡ç®—ç»“æœã€‚

```
public class ExpressionInterpreter {
  private Deque<Long> numbers = new LinkedList<>();

  public long interpret(String expression) {
    String[] elements = expression.split(" ");
    int length = elements.length;
    for (int i = 0; i < (length+1)/2; ++i) {
      numbers.addLast(Long.parseLong(elements[i]));
    }

    for (int i = (length+1)/2; i < length; ++i) {
      String operator = elements[i];
      boolean isValid = "+".equals(operator) || "-".equals(operator)
              || "*".equals(operator) || "/".equals(operator);
      if (!isValid) {
        throw new RuntimeException("Expression is invalid: " + expression);
      }

      long number1 = numbers.pollFirst();
      long number2 = numbers.pollFirst();
      long result = 0;
      if (operator.equals("+")) {
        result = number1 + number2;
      } else if (operator.equals("-")) {
        result = number1 - number2;
      } else if (operator.equals("*")) {
        result = number1 * number2;
      } else if (operator.equals("/")) {
        result = number1 / number2;
      }
      numbers.addFirst(result);
    }

    if (numbers.size() != 1) {
      throw new RuntimeException("Expression is invalid: " + expression);
    }

    return numbers.pop();
  }
}
```

åœ¨ä¸Šé¢çš„ä»£ç å®ç°ä¸­ï¼Œè¯­æ³•è§„åˆ™çš„è§£æé€»è¾‘ï¼ˆç¬¬23ã€25ã€27ã€29è¡Œï¼‰éƒ½é›†ä¸­åœ¨ä¸€ä¸ªå‡½æ•°ä¸­ï¼Œå¯¹äºç®€å•çš„è¯­æ³•è§„åˆ™çš„è§£æï¼Œè¿™æ ·çš„è®¾è®¡å°±è¶³å¤Ÿäº†ã€‚ä½†æ˜¯ï¼Œå¯¹äºå¤æ‚çš„è¯­æ³•è§„åˆ™çš„è§£æï¼Œé€»è¾‘å¤æ‚ï¼Œä»£ç é‡å¤šï¼Œæ‰€æœ‰çš„è§£æé€»è¾‘éƒ½è€¦åˆåœ¨ä¸€ä¸ªå‡½æ•°ä¸­ï¼Œè¿™æ ·æ˜¾ç„¶æ˜¯ä¸åˆé€‚çš„ã€‚è¿™ä¸ªæ—¶å€™ï¼Œæˆ‘ä»¬å°±è¦è€ƒè™‘æ‹†åˆ†ä»£ç ï¼Œå°†è§£æé€»è¾‘æ‹†åˆ†åˆ°ç‹¬ç«‹çš„å°ç±»ä¸­ã€‚

è¯¥æ€ä¹ˆæ‹†åˆ†å‘¢ï¼Ÿæˆ‘ä»¬å¯ä»¥å€ŸåŠ©è§£é‡Šå™¨æ¨¡å¼ã€‚

è§£é‡Šå™¨æ¨¡å¼çš„ä»£ç å®ç°æ¯”è¾ƒçµæ´»ï¼Œæ²¡æœ‰å›ºå®šçš„æ¨¡æ¿ã€‚æˆ‘ä»¬å‰é¢ä¹Ÿè¯´è¿‡ï¼Œåº”ç”¨è®¾è®¡æ¨¡å¼ä¸»è¦æ˜¯åº”å¯¹ä»£ç çš„å¤æ‚æ€§ï¼Œå®é™…ä¸Šï¼Œè§£é‡Šå™¨æ¨¡å¼ä¹Ÿä¸ä¾‹å¤–ã€‚å®ƒçš„ä»£ç å®ç°çš„æ ¸å¿ƒæ€æƒ³ï¼Œå°±æ˜¯å°†è¯­æ³•è§£æçš„å·¥ä½œæ‹†åˆ†åˆ°å„ä¸ªå°ç±»ä¸­ï¼Œä»¥æ­¤æ¥é¿å…å¤§è€Œå…¨çš„è§£æç±»ã€‚ä¸€èˆ¬çš„åšæ³•æ˜¯ï¼Œå°†è¯­æ³•è§„åˆ™æ‹†åˆ†æˆä¸€äº›å°çš„ç‹¬ç«‹çš„å•å…ƒï¼Œç„¶åå¯¹æ¯ä¸ªå•å…ƒè¿›è¡Œè§£æï¼Œæœ€ç»ˆåˆå¹¶ä¸ºå¯¹æ•´ä¸ªè¯­æ³•è§„åˆ™çš„è§£æã€‚

å‰é¢å®šä¹‰çš„è¯­æ³•è§„åˆ™æœ‰ä¸¤ç±»è¡¨è¾¾å¼ï¼Œä¸€ç±»æ˜¯æ•°å­—ï¼Œä¸€ç±»æ˜¯è¿ç®—ç¬¦ï¼Œè¿ç®—ç¬¦åˆåŒ…æ‹¬åŠ å‡ä¹˜é™¤ã€‚åˆ©ç”¨è§£é‡Šå™¨æ¨¡å¼ï¼Œæˆ‘ä»¬æŠŠè§£æçš„å·¥ä½œæ‹†åˆ†åˆ°NumberExpressionã€AdditionExpressionã€SubstractionExpressionã€MultiplicationExpressionã€DivisionExpressionè¿™æ ·äº”ä¸ªè§£æç±»ä¸­ã€‚

æŒ‰ç…§è¿™ä¸ªæ€è·¯ï¼Œæˆ‘ä»¬å¯¹ä»£ç è¿›è¡Œé‡æ„ï¼Œé‡æ„ä¹‹åçš„ä»£ç å¦‚ä¸‹æ‰€ç¤ºã€‚å½“ç„¶ï¼Œå› ä¸ºåŠ å‡ä¹˜é™¤è¡¨è¾¾å¼çš„è§£ææ¯”è¾ƒç®€å•ï¼Œåˆ©ç”¨è§£é‡Šå™¨æ¨¡å¼çš„è®¾è®¡æ€è·¯ï¼Œçœ‹èµ·æ¥æœ‰ç‚¹è¿‡åº¦è®¾è®¡ã€‚ä¸è¿‡å‘¢ï¼Œè¿™é‡Œæˆ‘ä¸»è¦æ˜¯ä¸ºäº†è§£é‡ŠåŸç†ï¼Œä½ æ˜ç™½æ„æ€å°±å¥½ï¼Œä¸ç”¨è¿‡åº¦ç»†ç©¶è¿™ä¸ªä¾‹å­ã€‚

```
public interface Expression {
  long interpret();
}

public class NumberExpression implements Expression {
  private long number;

  public NumberExpression(long number) {
    this.number = number;
  }

  public NumberExpression(String number) {
    this.number = Long.parseLong(number);
  }

  @Override
  public long interpret() {
    return this.number;
  }
}

public class AdditionExpression implements Expression {
  private Expression exp1;
  private Expression exp2;

  public AdditionExpression(Expression exp1, Expression exp2) {
    this.exp1 = exp1;
    this.exp2 = exp2;
  }

  @Override
  public long interpret() {
    return exp1.interpret() + exp2.interpret();
  }
}
// SubstractionExpression/MultiplicationExpression/DivisionExpressionä¸AdditionExpressionä»£ç ç»“æ„ç±»ä¼¼ï¼Œè¿™é‡Œå°±çœç•¥äº†

public class ExpressionInterpreter {
  private Deque<Expression> numbers = new LinkedList<>();

  public long interpret(String expression) {
    String[] elements = expression.split(" ");
    int length = elements.length;
    for (int i = 0; i < (length+1)/2; ++i) {
      numbers.addLast(new NumberExpression(elements[i]));
    }

    for (int i = (length+1)/2; i < length; ++i) {
      String operator = elements[i];
      boolean isValid = "+".equals(operator) || "-".equals(operator)
              || "*".equals(operator) || "/".equals(operator);
      if (!isValid) {
        throw new RuntimeException("Expression is invalid: " + expression);
      }

      Expression exp1 = numbers.pollFirst();
      Expression exp2 = numbers.pollFirst();
      Expression combinedExp = null;
      if (operator.equals("+")) {
        combinedExp = new AdditionExpression(exp1, exp2);
      } else if (operator.equals("-")) {
        combinedExp = new AdditionExpression(exp1, exp2);
      } else if (operator.equals("*")) {
        combinedExp = new AdditionExpression(exp1, exp2);
      } else if (operator.equals("/")) {
        combinedExp = new AdditionExpression(exp1, exp2);
      }
      long result = combinedExp.interpret();
      numbers.addFirst(new NumberExpression(result));
    }

    if (numbers.size() != 1) {
      throw new RuntimeException("Expression is invalid: " + expression);
    }

    return numbers.pop().interpret();
  }
}
```

## è§£é‡Šå™¨æ¨¡å¼å®æˆ˜ä¸¾ä¾‹

æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å†æ¥çœ‹ä¸€ä¸ªæ›´åŠ æ¥è¿‘å®æˆ˜çš„ä¾‹å­ï¼Œä¹Ÿå°±æ˜¯å’±ä»¬ä»Šå¤©æ ‡é¢˜ä¸­çš„é—®é¢˜ï¼šå¦‚ä½•å®ç°ä¸€ä¸ªè‡ªå®šä¹‰æ¥å£å‘Šè­¦è§„åˆ™åŠŸèƒ½ï¼Ÿ

åœ¨æˆ‘ä»¬å¹³æ—¶çš„é¡¹ç›®å¼€å‘ä¸­ï¼Œç›‘æ§ç³»ç»Ÿéå¸¸é‡è¦ï¼Œå®ƒå¯ä»¥æ—¶åˆ»ç›‘æ§ä¸šåŠ¡ç³»ç»Ÿçš„è¿è¡Œæƒ…å†µï¼ŒåŠæ—¶å°†å¼‚å¸¸æŠ¥å‘Šç»™å¼€å‘è€…ã€‚æ¯”å¦‚ï¼Œå¦‚æœæ¯åˆ†é’Ÿæ¥å£å‡ºé”™æ•°è¶…è¿‡100ï¼Œç›‘æ§ç³»ç»Ÿå°±é€šè¿‡çŸ­ä¿¡ã€å¾®ä¿¡ã€é‚®ä»¶ç­‰æ–¹å¼å‘é€å‘Šè­¦ç»™å¼€å‘è€…ã€‚

ä¸€èˆ¬æ¥è®²ï¼Œç›‘æ§ç³»ç»Ÿæ”¯æŒå¼€å‘è€…è‡ªå®šä¹‰å‘Šè­¦è§„åˆ™ï¼Œæ¯”å¦‚æˆ‘ä»¬å¯ä»¥ç”¨ä¸‹é¢è¿™æ ·ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œæ¥è¡¨ç¤ºä¸€ä¸ªå‘Šè­¦è§„åˆ™ï¼Œå®ƒè¡¨è¾¾çš„æ„æ€æ˜¯ï¼šæ¯åˆ†é’ŸAPIæ€»å‡ºé”™æ•°è¶…è¿‡100æˆ–è€…æ¯åˆ†é’ŸAPIæ€»è°ƒç”¨æ•°è¶…è¿‡10000å°±è§¦å‘å‘Šè­¦ã€‚

```
api_error_per_minute > 100 || api_count_per_minute > 10000
```

åœ¨ç›‘æ§ç³»ç»Ÿä¸­ï¼Œå‘Šè­¦æ¨¡å—åªè´Ÿè´£æ ¹æ®ç»Ÿè®¡æ•°æ®å’Œå‘Šè­¦è§„åˆ™ï¼Œåˆ¤æ–­æ˜¯å¦è§¦å‘å‘Šè­¦ã€‚è‡³äºæ¯åˆ†é’ŸAPIæ¥å£å‡ºé”™æ•°ã€æ¯åˆ†é’Ÿæ¥å£è°ƒç”¨æ•°ç­‰ç»Ÿè®¡æ•°æ®çš„è®¡ç®—ï¼Œæ˜¯ç”±å…¶ä»–æ¨¡å—æ¥è´Ÿè´£çš„ã€‚å…¶ä»–æ¨¡å—å°†ç»Ÿè®¡æ•°æ®æ”¾åˆ°ä¸€ä¸ªMapä¸­ï¼ˆæ•°æ®çš„æ ¼å¼å¦‚ä¸‹æ‰€ç¤ºï¼‰ï¼Œå‘é€ç»™å‘Šè­¦æ¨¡å—ã€‚æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬åªå…³æ³¨å‘Šè­¦æ¨¡å—ã€‚

```
Map<String, Long> apiStat = new HashMap<>();
apiStat.put("api_error_per_minute", 103);
apiStat.put("api_count_per_minute", 987);
```

ä¸ºäº†ç®€åŒ–è®²è§£å’Œä»£ç å®ç°ï¼Œæˆ‘ä»¬å‡è®¾è‡ªå®šä¹‰çš„å‘Šè­¦è§„åˆ™åªåŒ…å«â€œ||ã€&amp;&amp;ã€&gt;ã€&lt;ã€==â€è¿™äº”ä¸ªè¿ç®—ç¬¦ï¼Œå…¶ä¸­ï¼Œâ€œ&gt;ã€&lt;ã€==â€è¿ç®—ç¬¦çš„ä¼˜å…ˆçº§é«˜äºâ€œ||ã€&amp;&amp;â€è¿ç®—ç¬¦ï¼Œâ€œ&amp;&amp;â€è¿ç®—ç¬¦ä¼˜å…ˆçº§é«˜äºâ€œ||â€ã€‚åœ¨è¡¨è¾¾å¼ä¸­ï¼Œä»»æ„å…ƒç´ ä¹‹é—´éœ€è¦é€šè¿‡ç©ºæ ¼æ¥åˆ†éš”ã€‚é™¤æ­¤ä¹‹å¤–ï¼Œç”¨æˆ·å¯ä»¥è‡ªå®šä¹‰è¦ç›‘æ§çš„keyï¼Œæ¯”å¦‚å‰é¢çš„api\_error\_per\_minuteã€api\_count\_per\_minuteã€‚

é‚£å¦‚ä½•å®ç°ä¸Šé¢çš„éœ€æ±‚å‘¢ï¼Ÿæˆ‘å†™äº†ä¸€ä¸ªéª¨æ¶ä»£ç ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼Œå…¶ä¸­çš„æ ¸å¿ƒçš„å®ç°æˆ‘æ²¡æœ‰ç»™å‡ºï¼Œä½ å¯ä»¥å½“ä½œé¢è¯•é¢˜ï¼Œè‡ªå·±è¯•ç€å»è¡¥å…¨ä¸€ä¸‹ï¼Œç„¶åå†çœ‹æˆ‘çš„è®²è§£ã€‚

```
public class AlertRuleInterpreter {

  // key1 > 100 && key2 < 1000 || key3 == 200
  public AlertRuleInterpreter(String ruleExpression) {
    //TODO:ç”±ä½ æ¥å®Œå–„
  }

  //<String, Long> apiStat = new HashMap<>();
  //apiStat.put("key1", 103);
  //apiStat.put("key2", 987);
  public boolean interpret(Map<String, Long> stats) {
    //TODO:ç”±ä½ æ¥å®Œå–„
  }

}

public class DemoTest {
  public static void main(String[] args) {
    String rule = "key1 > 100 && key2 < 30 || key3 < 100 || key4 == 88";
    AlertRuleInterpreter interpreter = new AlertRuleInterpreter(rule);
    Map<String, Long> stats = new HashMap<>();
    stats.put("key1", 101l);
    stats.put("key3", 121l);
    stats.put("key4", 88l);
    boolean alert = interpreter.interpret(stats);
    System.out.println(alert);
  }
}
```

å®é™…ä¸Šï¼Œæˆ‘ä»¬å¯ä»¥æŠŠè‡ªå®šä¹‰çš„å‘Šè­¦è§„åˆ™ï¼Œçœ‹ä½œä¸€ç§ç‰¹æ®Šâ€œè¯­è¨€â€çš„è¯­æ³•è§„åˆ™ã€‚æˆ‘ä»¬å®ç°ä¸€ä¸ªè§£é‡Šå™¨ï¼Œèƒ½å¤Ÿæ ¹æ®è§„åˆ™ï¼Œé’ˆå¯¹ç”¨æˆ·è¾“å…¥çš„æ•°æ®ï¼Œåˆ¤æ–­æ˜¯å¦è§¦å‘å‘Šè­¦ã€‚åˆ©ç”¨è§£é‡Šå™¨æ¨¡å¼ï¼Œæˆ‘ä»¬æŠŠè§£æè¡¨è¾¾å¼çš„é€»è¾‘æ‹†åˆ†åˆ°å„ä¸ªå°ç±»ä¸­ï¼Œé¿å…å¤§è€Œå¤æ‚çš„å¤§ç±»çš„å‡ºç°ã€‚æŒ‰ç…§è¿™ä¸ªå®ç°æ€è·¯ï¼Œæˆ‘æŠŠåˆšåˆšçš„ä»£ç è¡¥å…¨ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼Œä½ å¯ä»¥æ‹¿ä½ å†™çš„ä»£ç è·Ÿæˆ‘å†™çš„å¯¹æ¯”ä¸€ä¸‹ã€‚

```
public interface Expression {
  boolean interpret(Map<String, Long> stats);
}

public class GreaterExpression implements Expression {
  private String key;
  private long value;

  public GreaterExpression(String strExpression) {
    String[] elements = strExpression.trim().split("\\s+");
    if (elements.length != 3 || !elements[1].trim().equals(">")) {
      throw new RuntimeException("Expression is invalid: " + strExpression);
    }
    this.key = elements[0].trim();
    this.value = Long.parseLong(elements[2].trim());
  }

  public GreaterExpression(String key, long value) {
    this.key = key;
    this.value = value;
  }

  @Override
  public boolean interpret(Map<String, Long> stats) {
    if (!stats.containsKey(key)) {
      return false;
    }
    long statValue = stats.get(key);
    return statValue > value;
  }
}

// LessExpression/EqualExpressionè·ŸGreaterExpressionä»£ç ç±»ä¼¼ï¼Œè¿™é‡Œå°±çœç•¥äº†

public class AndExpression implements Expression {
  private List<Expression> expressions = new ArrayList<>();

  public AndExpression(String strAndExpression) {
    String[] strExpressions = strAndExpression.split("&&");
    for (String strExpr : strExpressions) {
      if (strExpr.contains(">")) {
        expressions.add(new GreaterExpression(strExpr));
      } else if (strExpr.contains("<")) {
        expressions.add(new LessExpression(strExpr));
      } else if (strExpr.contains("==")) {
        expressions.add(new EqualExpression(strExpr));
      } else {
        throw new RuntimeException("Expression is invalid: " + strAndExpression);
      }
    }
  }

  public AndExpression(List<Expression> expressions) {
    this.expressions.addAll(expressions);
  }

  @Override
  public boolean interpret(Map<String, Long> stats) {
    for (Expression expr : expressions) {
      if (!expr.interpret(stats)) {
        return false;
      }
    }
    return true;
  }

}

public class OrExpression implements Expression {
  private List<Expression> expressions = new ArrayList<>();

  public OrExpression(String strOrExpression) {
    String[] andExpressions = strOrExpression.split("\\|\\|");
    for (String andExpr : andExpressions) {
      expressions.add(new AndExpression(andExpr));
    }
  }

  public OrExpression(List<Expression> expressions) {
    this.expressions.addAll(expressions);
  }

  @Override
  public boolean interpret(Map<String, Long> stats) {
    for (Expression expr : expressions) {
      if (expr.interpret(stats)) {
        return true;
      }
    }
    return false;
  }
}

public class AlertRuleInterpreter {
  private Expression expression;

  public AlertRuleInterpreter(String ruleExpression) {
    this.expression = new OrExpression(ruleExpression);
  }

  public boolean interpret(Map<String, Long> stats) {
    return expression.interpret(stats);
  }
} 
```

## é‡ç‚¹å›é¡¾

å¥½äº†ï¼Œä»Šå¤©çš„å†…å®¹åˆ°æ­¤å°±è®²å®Œäº†ã€‚æˆ‘ä»¬ä¸€å—æ¥æ€»ç»“å›é¡¾ä¸€ä¸‹ï¼Œä½ éœ€è¦é‡ç‚¹æŒæ¡çš„å†…å®¹ã€‚

è§£é‡Šå™¨æ¨¡å¼ä¸ºæŸä¸ªè¯­è¨€å®šä¹‰å®ƒçš„è¯­æ³•ï¼ˆæˆ–è€…å«æ–‡æ³•ï¼‰è¡¨ç¤ºï¼Œå¹¶å®šä¹‰ä¸€ä¸ªè§£é‡Šå™¨ç”¨æ¥å¤„ç†è¿™ä¸ªè¯­æ³•ã€‚å®é™…ä¸Šï¼Œè¿™é‡Œçš„â€œè¯­è¨€â€ä¸ä»…ä»…æŒ‡æˆ‘ä»¬å¹³æ—¶è¯´çš„ä¸­ã€è‹±ã€æ—¥ã€æ³•ç­‰å„ç§è¯­è¨€ã€‚ä»å¹¿ä¹‰ä¸Šæ¥è®²ï¼Œåªè¦æ˜¯èƒ½æ‰¿è½½ä¿¡æ¯çš„è½½ä½“ï¼Œæˆ‘ä»¬éƒ½å¯ä»¥ç§°ä¹‹ä¸ºâ€œè¯­è¨€â€ï¼Œæ¯”å¦‚ï¼Œå¤ä»£çš„ç»“ç»³è®°äº‹ã€ç›²æ–‡ã€å“‘è¯­ã€æ‘©æ–¯å¯†ç ç­‰ã€‚

è¦æƒ³äº†è§£â€œè¯­è¨€â€è¦è¡¨è¾¾çš„ä¿¡æ¯ï¼Œæˆ‘ä»¬å°±å¿…é¡»å®šä¹‰ç›¸åº”çš„è¯­æ³•è§„åˆ™ã€‚è¿™æ ·ï¼Œä¹¦å†™è€…å°±å¯ä»¥æ ¹æ®è¯­æ³•è§„åˆ™æ¥ä¹¦å†™â€œå¥å­â€ï¼ˆä¸“ä¸šç‚¹çš„å«æ³•åº”è¯¥æ˜¯â€œè¡¨è¾¾å¼â€ï¼‰ï¼Œé˜…è¯»è€…æ ¹æ®è¯­æ³•è§„åˆ™æ¥é˜…è¯»â€œå¥å­â€ï¼Œè¿™æ ·æ‰èƒ½åšåˆ°ä¿¡æ¯çš„æ­£ç¡®ä¼ é€’ã€‚è€Œæˆ‘ä»¬è¦è®²çš„è§£é‡Šå™¨æ¨¡å¼ï¼Œå…¶å®å°±æ˜¯ç”¨æ¥å®ç°æ ¹æ®è¯­æ³•è§„åˆ™è§£è¯»â€œå¥å­â€çš„è§£é‡Šå™¨ã€‚

è§£é‡Šå™¨æ¨¡å¼çš„ä»£ç å®ç°æ¯”è¾ƒçµæ´»ï¼Œæ²¡æœ‰å›ºå®šçš„æ¨¡æ¿ã€‚æˆ‘ä»¬å‰é¢è¯´è¿‡ï¼Œåº”ç”¨è®¾è®¡æ¨¡å¼ä¸»è¦æ˜¯åº”å¯¹ä»£ç çš„å¤æ‚æ€§ï¼Œè§£é‡Šå™¨æ¨¡å¼ä¹Ÿä¸ä¾‹å¤–ã€‚å®ƒçš„ä»£ç å®ç°çš„æ ¸å¿ƒæ€æƒ³ï¼Œå°±æ˜¯å°†è¯­æ³•è§£æçš„å·¥ä½œæ‹†åˆ†åˆ°å„ä¸ªå°ç±»ä¸­ï¼Œä»¥æ­¤æ¥é¿å…å¤§è€Œå…¨çš„è§£æç±»ã€‚ä¸€èˆ¬çš„åšæ³•æ˜¯ï¼Œå°†è¯­æ³•è§„åˆ™æ‹†åˆ†ä¸€äº›å°çš„ç‹¬ç«‹çš„å•å…ƒï¼Œç„¶åå¯¹æ¯ä¸ªå•å…ƒè¿›è¡Œè§£æï¼Œæœ€ç»ˆåˆå¹¶ä¸ºå¯¹æ•´ä¸ªè¯­æ³•è§„åˆ™çš„è§£æã€‚

## è¯¾å ‚è®¨è®º

1.åœ¨ä½ è¿‡å¾€çš„é¡¹ç›®ç»å†æˆ–é˜…è¯»æºç çš„æ—¶å€™ï¼Œæœ‰æ²¡æœ‰ç”¨åˆ°æˆ–è€…è§è¿‡è§£é‡Šå™¨æ¨¡å¼å‘¢ï¼Ÿ  
2.åœ¨å‘Šè­¦è§„åˆ™è§£æçš„ä¾‹å­ä¸­ï¼Œå¦‚æœæˆ‘ä»¬è¦åœ¨è¡¨è¾¾å¼ä¸­æ”¯æŒæ‹¬å·â€œï¼ˆï¼‰â€ï¼Œé‚£å¦‚ä½•å¯¹ä»£ç è¿›è¡Œé‡æ„å‘¢ï¼Ÿä½ å¯ä»¥æŠŠå®ƒå½“ä½œç»ƒä¹ ï¼Œè¯•ç€ç¼–å†™ä¸€ä¸‹ä»£ç ã€‚

æ¬¢è¿ç•™è¨€å’Œæˆ‘åˆ†äº«ä½ çš„æƒ³æ³•ã€‚å¦‚æœæœ‰æ”¶è·ï¼Œä¹Ÿæ¬¢è¿ä½ æŠŠè¿™ç¯‡æ–‡ç« åˆ†äº«ç»™ä½ çš„æœ‹å‹ã€‚
<div><strong>ç²¾é€‰ç•™è¨€ï¼ˆ15ï¼‰</strong></div><ul>
<li><span>èŠ±å„¿å°‘å¹´</span> ğŸ‘ï¼ˆ11ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>ç±»ä¼¼äºè§„åˆ™å¼•æ“æ˜¯ä¸æ˜¯ä¹Ÿæ˜¯ä¸ªè§£é‡Šå™¨ï¼Œåªä¸è¿‡æ˜¯ä¸ªå¤æ‚å¾ˆå¤šçš„è§£é‡Šå™¨</p>2020-04-27</li><br/><li><span>Panmax</span> ğŸ‘ï¼ˆ68ï¼‰ ğŸ’¬ï¼ˆ8ï¼‰<p>ç¬¬äºŒä¸ªä»£ç ç¤ºä¾‹ä¸­çš„ä»£ç æ®µï¼š
  if (operator.equals(&quot;+&quot;)) {
    combinedExp = new AdditionExpression(exp1, exp2);
  } else if (operator.equals(&quot;-&quot;)) {
    combinedExp = new AdditionExpression(exp1, exp2);
  } else if (operator.equals(&quot;*&quot;)) {
    combinedExp = new AdditionExpression(exp1, exp2);
  } else if (operator.equals(&quot;&#47;&quot;)) {
    combinedExp = new AdditionExpression(exp1, exp2);
  }
åº”æ”¹ä¸ºï¼š
  if (operator.equals(&quot;+&quot;)) {
    combinedExp = new AdditionExpression(exp1, exp2);
  } else if (operator.equals(&quot;-&quot;)) {
    combinedExp = new SubstractionExpression(exp1, exp2);
  } else if (operator.equals(&quot;*&quot;)) {
    combinedExp = new MultiplicationExpression(exp1, exp2);
  } else if (operator.equals(&quot;&#47;&quot;)) {
    combinedExp = new DivisionExpression(exp1, exp2);
  }</p>2020-04-18</li><br/><li><span>LiuHu</span> ğŸ‘ï¼ˆ42ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>SpELï¼ˆSpring Expression Language )  å°±æ˜¯å…¸å‹çš„è§£é‡Šå™¨æ¨¡å¼å®ç°ã€‚
åœ¨é¡¹ç›®ä¸­å®ç°ç®€å•çš„è‡ªåŠ¨åŒ–è§„åˆ™è¿‡æ»¤å™¨ï¼Œå°±æ˜¯å°†è¿‡æ»¤å™¨é…ç½®ç¿»è¯‘æˆ SpEL è¡¨è¾¾å¼æ‰§è¡Œçš„</p>2020-05-05</li><br/><li><span>javaadu</span> ğŸ‘ï¼ˆ21ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>æˆ‘æ˜¯åšé£æ§æŠ€æœ¯çš„ï¼Œå‘ç°è¿™ä¸ªæ¨¡å¼å¯¹æˆ‘ç†è§£è§„åˆ™å¼•æ“çš„è®¾è®¡å¾ˆæœ‰å¸®åŠ©</p>2020-04-29</li><br/><li><span>è¿·ç¾Š</span> ğŸ‘ï¼ˆ16ï¼‰ ğŸ’¬ï¼ˆ3ï¼‰<p>å› ä¸ºåšçš„æ˜¯æ•°æ®ç±»å‹çš„é¡¹ç›®ï¼Œå°±æ˜¯æ ¹æ®è‡ªå®šä¹‰çš„SQLæ¥åˆ›å»ºAPIä»¥ä¾›å¯ä»¥é€šè¿‡httpå½¢å¼ç›´æ¥è°ƒç”¨ï¼Œé¡¹ç›®ä¸­å°±æ˜¯ç”¨Druidæ¥è§£æSQLçš„ï¼Œç”¨çš„å°±æ˜¯è§£é‡Šå™¨æ¨¡å¼ï¼ŒSQLè¯­å¥ä¸­çš„æ¯ä¸ªå­—ç¬¦å¯¹åº”ä¸€ä¸ªè¡¨è¾¾å¼ã€‚</p>2020-04-18</li><br/><li><span>kylexy_0817</span> ğŸ‘ï¼ˆ11ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>ESä¸­çš„å„ç§åˆ†è¯å™¨</p>2020-04-25</li><br/><li><span>Kenå¼ äº‘å¿ </span> ğŸ‘ï¼ˆ11ï¼‰ ğŸ’¬ï¼ˆ2ï¼‰<p>Javaä¸­æ³¨è§£å¤„ç†å™¨åšçš„å°±æ˜¯è§£é‡Šçš„åŠŸèƒ½ï¼Œä»¥åŠå‰ç«¯ç¼–è¯‘æ—¶çš„è¯­æ³•åˆ†æã€è¯­ä¹‰åˆ†æï¼Œåç«¯ç¼–è¯‘æ—¶ç”Ÿæˆçš„ä¸­é—´è¡¨è¾¾å¼ï¼Œç”¨æ¥è§¦å‘æ›´å¤šä¼˜åŒ–ï¼Œä¼˜åŒ–çš„å¤„ç†å¯ä»¥ç†è§£ä¸ºé«˜æ•ˆçš„è§£é‡Šï¼Œæœ€ç»ˆç”Ÿæˆæœºå™¨å¯ä»¥æ‰§è¡Œçš„æ±‡ç¼–æŒ‡ä»¤ã€‚</p>2020-04-17</li><br/><li><span>é²¨é±¼è¾£æ¤’</span> ğŸ‘ï¼ˆ10ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>å®šæ—¶ä»»åŠ¡ä¸­çš„cronè¡¨è¾¾å¼</p>2020-05-20</li><br/><li><span>è¾£ä¹ˆå¤§</span> ğŸ‘ï¼ˆ10ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>å…³äºé—®é¢˜ä¸€ï¼Œä½¿ç”¨è¿‡ã€‚åå‘ç§‘ç ”ï¼Œè‡ªå®šä¹‰ä¸€é—¨è¯­è¨€ï¼Œç„¶åé€šè¿‡è¯­æ³•è§£æå™¨åˆ†æè¯»å…¥ã€‚
ä¾‹å¦‚ä½¿ç”¨RDDL(Relational Domain Definition Language)å…³ç³»é¢†åŸŸå®šä¹‰è¯­è¨€æè¿°é©¬å°”å¯å¤«å†³ç­–è¿‡ç¨‹ã€‚
domain prop_dbn {
  	
	requirements = { reward-deterministic };
      	
	pvariables { 
		p : { state-fluent,  bool, default = false };
		q : { state-fluent,  bool, default = false };
		r : { state-fluent,  bool, default = false }; 
		a : { action-fluent, bool, default = false }; 
	};
  
	cpfs {
		&#47;&#47; Some standard Bernoulli conditional probability tables
		p&#39; = if (p ^ r) then Bernoulli(.9) else Bernoulli(.3);
						
		q&#39; = if (q ^ r) then Bernoulli(.9) 
						else if (a) then Bernoulli(.3) else Bernoulli(.8);

		&#47;&#47; KronDelta is like a DiracDelta, but for discrete data (boolean or int)
		r&#39; = if (~q) then KronDelta(r) else KronDelta(r &lt;=&gt; q);										
	};
    
	&#47;&#47; A boolean functions as a 0&#47;1 integer when a numerical value is needed	
	reward = p + q - r; &#47;&#47; a boolean functions as a 0&#47;1 integer when a numerical value is needed
}
        
instance inst_dbn {

	domain = prop_dbn;	
	init-state { 
		p = true;  &#47;&#47; could also just say &#39;p&#39; by itself 
		q = false; &#47;&#47; default so unnecessary, could also say &#39;~q&#39; by itself
		r;         &#47;&#47; same as r = true
	};
  
	max-nondef-actions = 1;
	horizon  = 20;
	discount = 0.9;
}</p>2020-04-17</li><br/><li><span>test</span> ğŸ‘ï¼ˆ7ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>åŠ æ‹¬å·çš„è¯ï¼Œè¦åŠ ä¸€ä¸ªExpressionManagerï¼Œåœ¨manageré‡Œé¢ç”¨æ‹¬å·æŠŠè¡¨è¾¾å¼åˆ’åˆ†ä¸ºå‡ æ®µï¼Œå†æ ¹æ®è¡¨è¾¾å¼é—´æ˜¯ ä¸ è¿˜æ˜¯ æˆ– æ¥æ·»åŠ æœ€ä¸Šé¢é‚£ä¸€å±‚çš„è¡¨è¾¾å¼</p>2020-04-17</li><br/><li><span>æç¨³</span> ğŸ‘ï¼ˆ6ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>è¾“å…¥è§„åˆ™ï¼Œè§£æè§„åˆ™ï¼Œè¾“å…¥æ•°æ®ï¼Œä½¿ç”¨è§„åˆ™åˆ¤æ–­æ•°æ®</p>2020-04-17</li><br/><li><span>è‹—</span> ğŸ‘ï¼ˆ5ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>ä½¿ç”¨è¿‡nutzå¼€æºé¡¹ç›®çš„è¡¨è¾¾å¼å¼•æ“ï¼Œå¯ä»¥æ‰©å±•å„ç§æ“ä½œç¬¦ã€‚</p>2020-04-29</li><br/><li><span>é©¬çƒå…ˆç”Ÿ</span> ğŸ‘ï¼ˆ5ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>å‘Šè­¦è§„åˆ™çš„ä»£ç  çœŸæ˜¯è¯»äº†åŠå¤©æ‰çœ‹æ‡‚ğŸ˜‚</p>2020-04-18</li><br/><li><span>Heaven</span> ğŸ‘ï¼ˆ5ï¼‰ ğŸ’¬ï¼ˆ3ï¼‰<p>https:&#47;&#47;github.com&#47;HeavenXin&#47;MonitorExpressionTest
å…³äºç¬¬äºŒé“é¢˜,è¶ç€ä¸­åˆå†™äº†å†™,å¤§å®¶å¯ä»¥å‚è€ƒä¸€ä¸‹</p>2020-04-17</li><br/><li><span>å—å±±</span> ğŸ‘ï¼ˆ3ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>è¿˜çœŸæœ‰é¡¹ç›®æœ‰è¿™ç§åœºæ™¯ï¼ŒåŠ¨æ€è¡¨å•çš„å€¼æ ¡éªŒï¼Œå¯ä»¥è‡ªå®šä¹‰æ ¡éªŒï¼Œæ ¡éªŒä¹‹é—´è¿˜å¯ä»¥ç›¸äº’ç»„åˆã€‚ä½†æ˜¯ç”¨çš„æ˜¯ç»„åˆæ¨¡å¼ï¼Œåé¢æ€è€ƒä¸€ä¸‹è§£é‡Šå™¨æ¨¡å¼å¦‚ä½•ä½¿ç”¨ï¼Œè²Œä¼¼æ›´é€‚åˆ~</p>2020-04-21</li><br/>
</ul>