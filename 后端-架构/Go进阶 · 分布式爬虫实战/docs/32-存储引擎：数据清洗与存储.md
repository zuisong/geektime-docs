ä½ å¥½ï¼Œæˆ‘æ˜¯éƒ‘å»ºå‹‹ã€‚

çˆ¬è™«é¡¹ç›®çš„ä¸€ä¸ªé‡è¦çš„ç¯èŠ‚å°±æ˜¯æŠŠæœ€ç»ˆçš„æ•°æ®æŒä¹…åŒ–å­˜å‚¨èµ·æ¥ï¼Œæ•°æ®å¯èƒ½ä¼šè¢«å­˜å‚¨åˆ°MySQLã€MongoDBã€Kafkaã€Excelç­‰å¤šç§æ•°æ®åº“ã€ä¸­é—´ä»¶æˆ–è€…æ˜¯æ–‡ä»¶ä¸­ã€‚

è¦è¾¾åˆ°è¿™ä¸ªç›®çš„ï¼Œæˆ‘ä»¬å¾ˆå®¹æ˜“æƒ³åˆ°ä½¿ç”¨æ¥å£æ¥å®ç°æ¨¡å—é—´çš„è§£è€¦ã€‚æˆ‘ä»¬è¿˜è¦è§£å†³æ•°æ®çš„ç¼“å†²åŒºé—®é¢˜ã€‚æœ€åï¼Œç”±äºçˆ¬è™«çš„æ•°æ®å¯èƒ½æ˜¯å¤šç§å¤šæ ·çš„ï¼Œå¦‚ä½•å¯¹æœ€ç»ˆæ•°æ®è¿›è¡Œåˆç†çš„æŠ½è±¡ä¹Ÿæ˜¯æˆ‘ä»¬éœ€è¦é¢ä¸´çš„é—®é¢˜ã€‚

è¿™èŠ‚è¯¾ï¼Œæˆ‘ä»¬å°†ä¹¦å†™ä¸€ä¸ªå­˜å‚¨å¼•æ“ï¼Œç”¨å®ƒæ¥å¤„ç†æ•°æ®çš„å­˜å‚¨é—®é¢˜ã€‚

## çˆ¬å–ç»“æ„åŒ–æ•°æ®

ä¹‹å‰æˆ‘ä»¬çˆ¬å–çš„æ¡ˆä¾‹æ¯”è¾ƒç®€å•ï¼Œåƒæ˜¯ç§Ÿæˆ¿ç½‘ç«™çš„ä¿¡æ¯ç­‰ã€‚ä½†æ˜¯å®é™…æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬çš„çˆ¬è™«ä»»åŠ¡é€šå¸¸éœ€è¦è·å–ç»“æ„åŒ–çš„æ•°æ®ã€‚ä¾‹å¦‚ä¸€æœ¬ä¹¦çš„ä¿¡æ¯å°±åŒ…å«ä¹¦åã€ä»·æ ¼ã€å‡ºç‰ˆç¤¾ã€ç®€ä»‹ã€è¯„åˆ†ç­‰ã€‚ä¸ºäº†ç”Ÿæˆç»“æ„åŒ–çš„æ•°æ®ï¼Œæˆ‘ä»¥[è±†ç“£å›¾ä¹¦](https://book.douban.com/)ä¸ºä¾‹ä¹¦å†™æˆ‘ä»¬çš„ä»»åŠ¡è§„åˆ™ã€‚

**ç¬¬ä¸€æ­¥ï¼Œä»é¦–é¡µä¸­å³ä¾§è·å–çƒ­é—¨æ ‡ç­¾çš„ä¿¡æ¯ã€‚**

![å›¾ç‰‡](https://static001.geekbang.org/resource/image/73/65/73df9e84cc9937555326b92b4e448865.png?wh=1920x1257)

```plain
const regexpStr = `<a href="([^"]+)" class="tag">([^<]+)</a>`
func ParseTag(ctx *collect.Context) (collect.ParseResult, error) {
	re := regexp.MustCompile(regexpStr)

	matches := re.FindAllSubmatch(ctx.Body, -1)
	result := collect.ParseResult{}

	for _, m := range matches {
		result.Requesrts = append(
			result.Requesrts, &collect.Request{
				Method:   "GET",
				Task:     ctx.Req.Task,
				Url:      "<https://book.douban.com>" + string(m[1]),
				Depth:    ctx.Req.Depth + 1,
				RuleName: "ä¹¦ç±åˆ—è¡¨",
			})
	}
	return result, nil
}
```

è¿›å…¥æ ‡ç­¾é¡µé¢åï¼Œæˆ‘ä»¬å¯ä»¥è¿›ä¸€æ­¥è·å–åˆ°å›¾ä¹¦çš„åˆ—è¡¨ã€‚

![å›¾ç‰‡](https://static001.geekbang.org/resource/image/1b/ce/1b947f73808yy752af826b0bebf4d9ce.png?wh=1920x2229)

è§£æå›¾ç‰‡åˆ—è¡¨çš„ä»£ç å¦‚ä¸‹ï¼š

```plain
const BooklistRe = `<a.*?href="([^"]+)" title="([^"]+)"`

func ParseBookList(ctx *collect.Context) (collect.ParseResult, error) {
	re := regexp.MustCompile(BooklistRe)
	matches := re.FindAllSubmatch(ctx.Body, -1)
	result := collect.ParseResult{}
	for _, m := range matches {
		req := &collect.Request{
			Method:   "GET",
			Task:     ctx.Req.Task,
			Url:      string(m[1]),
			Depth:    ctx.Req.Depth + 1,
			RuleName: "ä¹¦ç±ç®€ä»‹",
		}
		req.TmpData = &collect.Temp{}
		req.TmpData.Set("book_name", string(m[2]))
		result.Requesrts = append(result.Requesrts, req)
	}

	return result, nil
}
```

æ³¨æ„ï¼Œè¿™é‡Œæˆ‘è·å–åˆ°ä¹¦åä¹‹åï¼Œå°†ä¹¦åç¼“å­˜åˆ°äº†ä¸´æ—¶çš„tmpç»“æ„ä¸­ä¾›ä¸‹ä¸€ä¸ªé˜¶æ®µè¯»å–ã€‚è¿™æ˜¯å› ä¸ºæˆ‘ä»¬å¸Œæœ›å¾—åˆ°çš„æŸäº›ä¿¡æ¯æ˜¯åœ¨ä¹‹å‰çš„é˜¶æ®µè·å¾—çš„ã€‚åœ¨è¿™é‡Œæˆ‘å°†ç¼“å­˜ç»“æ„å®šä¹‰ä¸ºäº†ä¸€ä¸ªå“ˆå¸Œè¡¨ï¼Œå¹¶å°è£…äº†Getä¸Setä¸¤ä¸ªå‡½æ•°æ¥è·å–å’Œè®¾ç½®è¯·æ±‚ä¸­çš„ç¼“å­˜ã€‚

```plain
type Temp struct {
	data map[string]interface{}
}

// è¿”å›ä¸´æ—¶ç¼“å­˜æ•°æ®
func (t *Temp) Get(key string) interface{} {
	return t.data[key]
}

func (t *Temp) Set(key string, value interface{}) error {
	if t.data == nil {
		t.data = make(map[string]interface{}, 8)
	}
	t.data[key] = value
	return nil
}
```

æœ€åï¼Œç‚¹å‡»å›¾ä¹¦çš„è¯¦æƒ…é¡µï¼Œå¯ä»¥çœ‹åˆ°å›¾ä¹¦çš„ä½œè€…ã€å‡ºç‰ˆç¤¾ã€é¡µæ•°ã€å®šä»·ã€å¾—åˆ†ã€ä»·æ ¼ã€ç®€ä»‹ç­‰ä¿¡æ¯ã€‚

![å›¾ç‰‡](https://static001.geekbang.org/resource/image/8c/23/8c0ba5f76yyffdc7ac5f11f7aab1f523.png?wh=1920x1880)

è§£æå›¾ä¹¦è¯¦ç»†ä¿¡æ¯çš„ä»£ç å¦‚ä¸‹ï¼š

```plain
var autoRe = regexp.MustCompile(`<span class="pl"> ä½œè€…</span>:[\d\D]*?<a.*?>([^<]+)</a>`)
var public = regexp.MustCompile(`<span class="pl">å‡ºç‰ˆç¤¾:</span>([^<]+)<br/>`)
var pageRe = regexp.MustCompile(`<span class="pl">é¡µæ•°:</span> ([^<]+)<br/>`)
var priceRe = regexp.MustCompile(`<span class="pl">å®šä»·:</span>([^<]+)<br/>`)
var scoreRe = regexp.MustCompile(`<strong class="ll rating_num " property="v:average">([^<]+)</strong>`)
var intoRe = regexp.MustCompile(`<div class="intro">[\d\D]*?<p>([^<]+)</p></div>`)

func ParseBookDetail(ctx *collect.Context) (collect.ParseResult, error) {
	bookName := ctx.Req.TmpData.Get("book_name")
	page, _ := strconv.Atoi(ExtraString(ctx.Body, pageRe))

	book := map[string]interface{}{
		"ä¹¦å":  bookName,
		"ä½œè€…":  ExtraString(ctx.Body, autoRe),
		"é¡µæ•°":  page,
		"å‡ºç‰ˆç¤¾": ExtraString(ctx.Body, public),
		"å¾—åˆ†":  ExtraString(ctx.Body, scoreRe),
		"ä»·æ ¼":  ExtraString(ctx.Body, priceRe),
		"ç®€ä»‹":  ExtraString(ctx.Body, intoRe),
	}
	data := ctx.Output(book)

	result := collect.ParseResult{
		Items: []interface{}{data},
	}

	return result, nil
}

func ExtraString(contents []byte, re *regexp.Regexp) string {

	match := re.FindSubmatch(contents)

	if len(match) >= 2 {
		return string(match[1])
	} else {
		return ""
	}
}
```

å…¶ä¸­ï¼Œä¹¦åæ˜¯ä»ç¼“å­˜ä¸­å¾—åˆ°çš„ã€‚è¿™é‡Œä»ç„¶ä½¿ç”¨äº†æ­£åˆ™è¡¨è¾¾å¼ä½œä¸ºæ¼”ç¤ºï¼Œä½ ä¹Ÿå¯ä»¥æ”¹ä¸ºä½¿ç”¨æ›´åˆé€‚çš„CSSé€‰æ‹©å™¨ã€‚

å®Œæ•´çš„ä»»åŠ¡è§„åˆ™å¦‚ä¸‹æ‰€ç¤ºï¼š

```plain
var DoubanBookTask = &collect.Task{
	Property: collect.Property{
		Name:     "douban_book_list",
		WaitTime: 1 * time.Second,
		MaxDepth: 5,
		Cookie:   "xxx"
},
	Rule: collect.RuleTree{
		Root: func() ([]*collect.Request, error) {
			roots := []*collect.Request{
				&collect.Request{
					Priority: 1,
					Url:      "<https://book.douban.com>",
					Method:   "GET",
					RuleName: "æ•°æ®tag",
				},
			}
			return roots, nil
		},
		Trunk: map[string]*collect.Rule{
			"æ•°æ®tag": &collect.Rule{ParseFunc: ParseTag},
			"ä¹¦ç±åˆ—è¡¨":  &collect.Rule{ParseFunc: ParseBookList},
			"ä¹¦ç±ç®€ä»‹": &collect.Rule{
				ItemFields: []string{
					"ä¹¦å",
					"ä½œè€…",
					"é¡µæ•°",
					"å‡ºç‰ˆç¤¾",
					"å¾—åˆ†",
					"ä»·æ ¼",
					"ç®€ä»‹",
				},
				ParseFunc: ParseBookDetail,
			},
		},
	},
}
```

åœ¨é‡‡é›†è§„åˆ™èŠ‚ç‚¹ä¸­ï¼Œæˆ‘ä»¬åŠ å…¥äº†ä¸€ä¸ªæ–°çš„å­—æ®µ ItemFields æ¥è¡¨æ˜å½“å‰è¾“å‡ºæ•°æ®çš„å­—æ®µåï¼Œåé¢æˆ‘ä»¬è¿˜ä¼šçœ‹åˆ°å®ƒçš„ç”¨é€”ã€‚

```plain
type Rule struct {
	ItemFields []string
	ParseFunc  func(*Context) (ParseResult, error) // å†…å®¹è§£æå‡½æ•°
}
```

ä¸Šè¿°ä»£ç ä½äº[v0.2.6](https://github.com/dreamerjackson/crawler)ä¸­ï¼Œæ‰§è¡Œç¨‹åºåï¼Œè¾“å‡ºç»“æœå¦‚ä¸‹ï¼š

```plain
{"level":"INFO","ts":"2022-11-19T11:19:23.720+0800","caller":"crawler/main.go:16","msg":"log init end"}
{"level":"INFO","ts":"2022-11-19T11:19:28.119+0800","caller":"engine/schedule.go:301","msg":"get result: &{map[Data:map[ä¹¦å:é•¿å®‰çš„è”æ ä»·æ ¼: 45.00å…ƒ ä½œè€…:é©¬ä¼¯åº¸ å‡ºç‰ˆç¤¾: å¾—åˆ†: 8.5  ç®€ä»‹:â€”â€”é™•è¥¿å¸ˆèŒƒå¤§å­¦å†å²æ–‡åŒ–å­¦é™¢æ•™æˆ äºèµ“å“² é¡µæ•°:224] Rus://book.douban.com/subject/36104107/]}"}
```

ç°åœ¨æˆ‘ä»¬å°±èƒ½å¤Ÿçˆ¬å–ç»“æ„åŒ–çš„å›¾ä¹¦ä¿¡æ¯äº†ã€‚

## æ•°æ®å­˜å‚¨

### æ•°æ®æŠ½è±¡

çˆ¬å–åˆ°è¶³å¤Ÿçš„ä¿¡æ¯ä¹‹åï¼Œä¸ºäº†å°†æ•°æ®å­˜å‚¨èµ·æ¥ï¼Œé¦–å…ˆæˆ‘ä»¬éœ€è¦å®Œæˆå¯¹æ•°æ®çš„æŠ½è±¡ã€‚åœ¨è¿™é‡Œæˆ‘å°†æ¯ä¸€æ¡è¦å­˜å‚¨çš„æ•°æ®éƒ½æŠ½è±¡ä¸ºäº†DataCellç»“æ„ã€‚æˆ‘ä»¬å¯ä»¥æŠŠDataCellæƒ³è±¡ä¸ºMySQLä¸­çš„ä¸€è¡Œæ•°æ®ã€‚

```plain
type DataCell struct {
	Data map[string]interface{}
}
```

æˆ‘ä»¬è§„å®šï¼ŒDataCellä¸­çš„Keyä¸ºâ€œTaskâ€çš„æ•°æ®å­˜å‚¨äº†å½“å‰çš„ä»»åŠ¡åï¼ŒKeyä¸ºâ€œRuleâ€çš„æ•°æ®å­˜å‚¨äº†å½“å‰çš„è§„åˆ™åï¼ŒKeyä¸ºâ€œUrlâ€çš„æ•°æ®å­˜å‚¨äº†å½“å‰çš„ç½‘å€ï¼ŒKeyä¸ºâ€œTimeâ€çš„æ•°æ®å­˜å‚¨äº†å½“å‰çš„æ—¶é—´ã€‚è€Œæœ€é‡è¦çš„Keyä¸ºâ€œDataâ€çš„æ•°æ®å­˜å‚¨äº†å½“å‰æ ¸å¿ƒçš„æ•°æ®ï¼Œå³å½“å‰ä¹¦ç±çš„è¯¦ç»†ä¿¡æ¯ã€‚

åœ¨è§£æå›¾ä¹¦è¯¦ç»†ä¿¡æ¯çš„è§„åˆ™ä¸­ï¼Œæˆ‘ä»¬å®šä¹‰â€œDataâ€å¯¹åº”çš„æ•°æ®ç»“æ„åˆæ˜¯ä¸€ä¸ªå“ˆå¸Œè¡¨map\[string]interface{}ã€‚åœ¨è¿™ä¸ªå“ˆå¸Œè¡¨ä¸­ï¼ŒKeyä¸ºâ€œä¹¦åâ€â€œè¯„åˆ†â€ç­‰å­—æ®µåï¼ŒValueä¸ºå­—æ®µå¯¹åº”çš„å€¼ã€‚è¦æ³¨æ„çš„æ˜¯ï¼Œè¿™é‡ŒDataå¯¹åº”çš„Valueä¸ä¸€å®šéœ€è¦æ˜¯map\[string]interface{}ï¼Œåªè¦æˆ‘ä»¬åœ¨åé¢èƒ½å¤Ÿçµæ´»åœ°å¤„ç†ä¸åŒçš„ç±»å‹å°±å¯ä»¥äº†ã€‚

```plain
func (c *Context) Output(data interface{}) *collector.DataCell {
	res := &collector.DataCell{}
	res.Data = make(map[string]interface{})
	res.Data["Task"] = c.Req.Task.Name
	res.Data["Rule"] = c.Req.RuleName
	res.Data["Data"] = data
	res.Data["Url"] = c.Req.Url
	res.Data["Time"] = time.Now().Format("2006-01-02 15:04:05")
	return res
}
```

å®Œæˆäº†æ•°æ®çš„æŠ½è±¡ä¹‹åï¼Œå°±å¯ä»¥å°†æœ€ç»ˆçš„æ•°æ®å­˜å‚¨åˆ°Itemsä¸­ï¼Œä¾›æˆ‘ä»¬ä¸“é—¨çš„åç¨‹å»å¤„ç†äº†ã€‚

```plain
type ParseResult struct {
	Requesrts []*Request
	Items     []interface{}
}
```

### æ•°æ®åº•å±‚å­˜å‚¨

åœ¨ä¹‹å‰æˆ‘ä»¬ä¸€ç›´æœ‰ä¸€ä¸ªæœªå®Œæˆé¡¹ï¼Œå°±æ˜¯åœ¨HandleResultæ–¹æ³•ä¸­å¯¹è§£æåçš„æ•°æ®è¿›è¡Œå­˜å‚¨ï¼Œç°åœ¨æˆ‘ä»¬å°±å¯ä»¥å°†å®ƒå¤„ç†å®Œæ•´äº†ã€‚ç°åœ¨æˆ‘ä»¬è¦å¾ªç¯éå†Itemsï¼Œåˆ¤æ–­å…¶ä¸­çš„æ•°æ®ç±»å‹ï¼Œå¦‚æœæ•°æ®ç±»å‹ä¸ºDataCellï¼Œæˆ‘ä»¬å°±è¦ç”¨ä¸“é—¨çš„å­˜å‚¨å¼•æ“å°†è¿™äº›æ•°æ®å­˜å‚¨èµ·æ¥ã€‚ï¼ˆå­˜å‚¨å¼•æ“æ˜¯å’Œæ¯ä¸€ä¸ªçˆ¬è™«ä»»åŠ¡ç»‘å®šåœ¨ä¸€èµ·çš„ï¼Œä¸åŒçš„çˆ¬è™«ä»»åŠ¡å¯èƒ½ä¼šæœ‰ä¸åŒçš„å­˜å‚¨å¼•æ“ã€‚ï¼‰

```plain
func (s *Crawler) HandleResult() {
	for {
		select {
		case result := <-s.out:
			for _, item := range result.Items {
				switch d := item.(type) {
				case *collector.DataCell:
					name := d.GetTaskName()
					task := Store.Hash[name]
					task.Storage.Save(d)
				}
				s.Logger.Sugar().Info("get result: ", item)
			}
		}
	}
}
```

æˆ‘é€‰æ‹©ä½¿ç”¨æ¯”è¾ƒå¸¸è§çš„MySQLæ•°æ®åº“ä½œä¸ºè¿™ä¸ªç¤ºä¾‹çš„å­˜å‚¨å¼•æ“ã€‚åœ¨è¿™é‡Œï¼Œæˆ‘åˆ›å»ºäº†ä¸€ä¸ªæ¥å£Storageä½œä¸ºæ•°æ®å­˜å‚¨çš„æ¥å£ï¼ŒStorageä¸­åŒ…å«äº†Saveæ–¹æ³•ï¼Œä»»ä½•å®ç°äº†Saveæ–¹æ³•çš„åç«¯å¼•æ“éƒ½å¯ä»¥å­˜å‚¨æ•°æ®ã€‚

```plain
type Storage interface {
	Save(datas ...*DataCell) error
}
```

ä¸è¿‡æˆ‘ä»¬è¿˜éœ€è¦å®Œæˆä¸€è½®æŠ½è±¡ï¼Œå› ä¸ºåç«¯å¼•æ“ä¼šå¤„ç†çš„äº‹åŠ¡æ¯”è¾ƒç¹çï¼Œå®ƒä¸ä»…ä»…åŒ…å«äº†å­˜å‚¨ï¼Œè¿˜åŒ…å«äº†ç¼“å­˜ã€å¯¹è¡¨å¤´çš„æ‹¼æ¥ã€æ•°æ®çš„å¤„ç†ç­‰ã€‚æ‰€ä»¥ï¼Œæˆ‘ä»¬è¦åˆ›å»ºä¸€ä¸ªæ›´åŠ åº•å±‚çš„æ¨¡å—ï¼Œåªè¿›è¡Œæ•°æ®çš„å­˜å‚¨ã€‚

è¿™ä¸ªåº•å±‚æŠ½è±¡çš„å¥½å¤„åœ¨äºï¼Œæˆ‘ä»¬å¯ä»¥æ¯”è¾ƒçµæ´»åœ°æ›¿æ¢åº•å±‚çš„å­˜å‚¨æ¨¡å—ï¼Œæˆ‘åœ¨è¿™ä¸ªä¾‹å­ä¸­ä½¿ç”¨äº†åŸç”Ÿçš„MySQLè¯­å¥æ¥ä¸æ•°æ®åº“äº¤äº’ã€‚ä½ ä¹Ÿå¯ä»¥ä½¿ç”¨Xormä¸Gormè¿™æ ·çš„åº“æ¥æ“ä½œæ•°æ®åº“ã€‚

æ–°å»ºä¸€ä¸ªæ–‡ä»¶å¤¹mysqldbï¼Œè®¾ç½®æ“ä½œæ•°æ®åº“çš„æ¥å£DBerï¼Œé‡Œé¢çš„ä¸¤ä¸ªæ ¸å¿ƒå‡½æ•°åˆ†åˆ«æ˜¯CreateTableï¼ˆåˆ›å»ºè¡¨ï¼‰ä»¥åŠInsertï¼ˆæ’å…¥æ•°æ®ï¼‰ã€‚

```plain

type DBer interface {
	CreateTable(t TableData) error
	Insert(t TableData) error
}
type Field struct {
	Title string
	Type  string
}
type TableData struct {
	TableName   string
	ColumnNames []Field       // æ ‡é¢˜å­—æ®µ
	Args        []interface{} // æ•°æ®
	DataCount   int           // æ’å…¥æ•°æ®çš„æ•°é‡
	AutoKey     bool
}
```

å‚æ•°TableDataåŒ…å«äº†è¡¨çš„å…ƒæ•°æ®ï¼ŒTableNameä¸ºè¡¨åï¼ŒColumnNamesåŒ…å«äº†å­—æ®µåå’Œå­—æ®µçš„å±æ€§ ï¼ŒArgsä¸ºè¦æ’å…¥çš„æ•°æ®ï¼ŒDataCountä¸ºæ’å…¥æ•°æ®çš„ä¸ªæ•°ï¼ŒAutoKeyæ ‡è¯†æ˜¯å¦ä¸ºè¡¨åˆ›å»ºè‡ªå¢ä¸»é”®ã€‚  
ä¸‹é¢è¿™æ®µä»£ç ï¼Œæˆ‘ä»¬ä½¿ç”¨optionæ¨¡å¼ç”Ÿæˆäº†SqlDBç»“æ„ä½“ï¼Œå®ç°äº†DBeræ¥å£ã€‚Sqldb.OpenDBæ–¹æ³•ç”¨äºä¸æ•°æ®åº“å»ºç«‹è¿æ¥ï¼Œéœ€è¦ä»å¤–éƒ¨ä¼ å…¥è¿œç¨‹MySQLæ•°æ®åº“çš„è¿æ¥åœ°å€ã€‚

```plain
type Sqldb struct {
	options
	db *sql.DB
}

func New(opts ...Option) (*Sqldb, error) {
	options := defaultOptions
	for _, opt := range opts {
		opt(&options)
	}
	d := &Sqldb{}
	d.options = options
	if err := d.OpenDB(); err != nil {
		return nil, err
	}
	return d, nil
}

func (d *Sqldb) OpenDB() error {
	db, err := sql.Open("mysql", d.sqlUrl)
	if err != nil {
		return err
	}
	db.SetMaxOpenConns(2048)
	db.SetMaxIdleConns(2048)
	if err = db.Ping(); err != nil {
		return err
	}
	d.db = db
	return nil
}
```

ä¸¤ä¸ªæ ¸å¿ƒçš„æ–¹æ³•CreateTable ä¸ Insert ä¼šæ‹¼æ¥ MySQLè¯­å¥ï¼Œå¹¶åˆ†åˆ«æ‰§è¡Œåˆ›å»ºè¡¨ä¸æ’å…¥æ•°æ®çš„ä»æ“ä½œã€‚

```plain
func (d *Sqldb) CreateTable(t TableData) error {
	if len(t.ColumnNames) == 0 {
		return errors.New("Column can not be empty")
	}
	sql := `CREATE TABLE IF NOT EXISTS ` + t.TableName + " ("
	if t.AutoKey {
		sql += `id INT(12) NOT NULL PRIMARY KEY AUTO_INCREMENT,`
	}
	for _, t := range t.ColumnNames {
		sql += t.Title + ` ` + t.Type + `,`
	}
	sql = sql[:len(sql)-1] + `) ENGINE=MyISAM DEFAULT CHARSET=utf8;`

	d.logger.Debug("crate table", zap.String("sql", sql))

	_, err := d.db.Exec(sql)
	return err
}

func (d *Sqldb) Insert(t TableData) error {
	if len(t.ColumnNames) == 0 {
		return errors.New("empty column")
	}
	sql := `INSERT INTO ` + t.TableName + `(`

	for _, v := range t.ColumnNames {
		sql += v.Title + ","
	}

	sql = sql[:len(sql)-1] + `) VALUES `

	blank := ",(" + strings.Repeat(",?", len(t.ColumnNames))[1:] + ")"
	sql += strings.Repeat(blank, t.DataCount)[1:] + `;`
	d.logger.Debug("insert table", zap.String("sql", sql))
	_, err := d.db.Exec(sql, t.Args...)
	return err
}
```

### å­˜å‚¨å¼•æ“å®ç°

æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å†çœ‹çœ‹å¦‚ä½•å®ç°å­˜å‚¨å¼•æ“Storageã€‚

```plain
type SqlStore struct {
	dataDocker  []*collector.DataCell //åˆ†æ‰¹è¾“å‡ºç»“æœç¼“å­˜
	columnNames []sqldb.Field         // æ ‡é¢˜å­—æ®µ
	db          sqldb.DBer
	Table       map[string]struct{}
	options
}

func New(opts ...Option) (*SqlStore, error) {
	options := defaultOptions
	for _, opt := range opts {
		opt(&options)
	}
	s := &SqlStore{}
	s.options = options
	s.Table = make(map[string]struct{})
	var err error
	s.db, err = sqldb.New(
		sqldb.WithConnUrl(s.sqlUrl),
		sqldb.WithLogger(s.logger),
	)
	if err != nil {
		return nil, err
	}

	return s, nil
}
```

SqlStoreæ˜¯å¯¹Storageæ¥å£çš„å®ç°ï¼ŒSqlStoreå®ç°äº†optionæ¨¡å¼ï¼ŒåŒæ—¶å®ƒçš„å†…éƒ¨åŒ…å«äº†æ“ä½œæ•°æ®åº“çš„DBeræ¥å£ã€‚è®©æˆ‘ä»¬æ¥çœ‹çœ‹SqlStoreå¦‚ä½•å®ç°DBeræ¥å£ä¸­çš„Saveæ–¹æ³•ï¼Œå®ƒä¸»è¦å®ç°äº†ä¸‰ä¸ªåŠŸèƒ½ï¼š

- å¾ªç¯éå†è¦å­˜å‚¨çš„DataCellï¼Œå¹¶åˆ¤æ–­å½“å‰DataCellå¯¹åº”çš„æ•°æ®åº“è¡¨æ˜¯å¦å·²ç»è¢«åˆ›å»ºã€‚å¦‚æœè¡¨æ ¼æ²¡æœ‰è¢«åˆ›å»ºï¼Œåˆ™è°ƒç”¨CreateTableåˆ›å»ºè¡¨æ ¼ã€‚åœ¨å­˜å‚¨æ•°æ®æ—¶ï¼ŒgetFieldsç”¨äºè·å–å½“å‰æ•°æ®çš„è¡¨å­—æ®µä¸å­—æ®µç±»å‹ï¼Œè¿™æ˜¯ä»é‡‡é›†è§„åˆ™èŠ‚ç‚¹çš„ `ItemFields` æ•°ç»„ä¸­è·å¾—çš„ã€‚ä½ å¯èƒ½æƒ³é—®ï¼Œé‚£æˆ‘ä»¬ä¸ºä»€ä¹ˆä¸ç›´æ¥ç”¨DataCellä¸­Dataå¯¹åº”çš„å“ˆå¸Œè¡¨ä¸­çš„Keyç”Ÿæˆå­—æ®µåå‘¢ï¼Ÿè¿™ä¸€æ–¹é¢æ˜¯å› ä¸ºå®ƒçš„é€Ÿåº¦å¤ªæ…¢ï¼Œå¦å¤–ä¸€æ–¹é¢æ˜¯å› ä¸ºGoä¸­çš„å“ˆå¸Œè¡¨åœ¨éå†æ—¶çš„é¡ºåºæ˜¯éšæœºçš„ï¼Œè€Œç”Ÿæˆçš„å­—æ®µåˆ—è¡¨éœ€è¦é¡ºåºå›ºå®šã€‚

```plain
func getFields(cell *collector.DataCell) []sqldb.Field {
	taskName := cell.Data["Task"].(string)
	ruleName := cell.Data["Rule"].(string)
	fields := engine.GetFields(taskName, ruleName)

	var columnNames []sqldb.Field
	for _, field := range fields {
		columnNames = append(columnNames, sqldb.Field{
			Title: field,
			Type:  "MEDIUMTEXT",
		})
	}
	columnNames = append(columnNames,
		sqldb.Field{Title: "Url", Type: "VARCHAR(255)"},
		sqldb.Field{Title: "Time", Type: "VARCHAR(255)"},
	)
	return columnNames
}
```

- å¦‚æœå½“å‰çš„æ•°æ®å°äºs.BatchCountï¼Œåˆ™å°†æ•°æ®æ”¾å…¥åˆ°ç¼“å­˜ä¸­ç›´æ¥è¿”å›ï¼ˆä½¿ç”¨ç¼“å†²åŒºæ‰¹é‡æ’å…¥æ•°æ®åº“å¯ä»¥æé«˜ç¨‹åºçš„æ€§èƒ½ï¼‰ã€‚
- å¦‚æœç¼“å†²åŒºå·²ç»æ»¡äº†ï¼Œåˆ™è°ƒç”¨SqlStore.Flush()æ–¹æ³•æ‰¹é‡æ’å…¥æ•°æ®ã€‚

```plain
func (s *SqlStore) Save(dataCells ...*collector.DataCell) error {
	for _, cell := range dataCells {
		name := cell.GetTableName()
		if _, ok := s.Table[name]; !ok {
			// åˆ›å»ºè¡¨
			columnNames := getFields(cell)

			err := s.db.CreateTable(sqldb.TableData{
				TableName:   name,
				ColumnNames: columnNames,
				AutoKey:     true,
			})
			if err != nil {
				s.logger.Error("create table falied", zap.Error(err))
			}
			s.Table[name] = struct{}{}
		}
		if len(s.dataDocker) >= s.BatchCount {
			s.Flush()
		}
		s.dataDocker = append(s.dataDocker, cell)
	}
	return nil
}
```

SqlStore.Flush()æ–¹æ³•çš„å®ç°å¦‚ä¸‹ï¼š

```plain
func (s *SqlStore) Flush() error {
	if len(s.dataDocker) == 0 {
		return nil
	}
	args := make([]interface{}, 0)
	for _, datacell := range s.dataDocker {
		ruleName := datacell.Data["Rule"].(string)
		taskName := datacell.Data["Task"].(string)
		fields := engine.GetFields(taskName, ruleName)
		data := datacell.Data["Data"].(map[string]interface{})
		value := []string{}
		for _, field := range fields {
			v := data[field]
			switch v.(type) {
			case nil:
				value = append(value, "")
			case string:
				value = append(value, v.(string))
			default:
				j, err := json.Marshal(v)
				if err != nil {
					value = append(value, "")
				} else {
					value = append(value, string(j))
				}
			}
		}
		value = append(value, datacell.Data["Url"].(string), datacell.Data["Time"].(string))
		for _, v := range value {
			args = append(args, v)
		}
	}

	return s.db.Insert(sqldb.TableData{
		TableName:   s.dataDocker[0].GetTableName(),
		ColumnNames: getFields(s.dataDocker[0]),
		Args:        args,
		DataCount:   len(s.dataDocker),
	})
}
```

è¿™æ®µä»£ç çš„æ ¸å¿ƒæ˜¯éå†ç¼“å†²åŒºï¼Œè§£ææ¯ä¸€ä¸ªDataCellä¸­çš„æ•°æ®ï¼Œå°†æ‰©å±•åçš„å­—æ®µå€¼æ‰¹é‡æ”¾å…¥argså‚æ•°ä¸­ï¼Œå¹¶è°ƒç”¨åº•å±‚DBer.Insertæ–¹æ³•æ‰¹é‡æ’å…¥æ•°æ®ï¼ˆä¸Šè¿°ä»£ç ä½äº[v0.2.7åˆ†æ”¯](https://github.com/dreamerjackson/crawler)ã€‚ï¼‰

## å­˜å‚¨å¼•æ“éªŒè¯

æ¥ä¸‹æ¥æˆ‘ä»¬ç®€å•åœ°éªŒè¯ä¸‹æˆ‘ä»¬ä¹¦å†™çš„å­˜å‚¨å¼•æ“çš„æ­£ç¡®æ€§ã€‚é¦–å…ˆä¸ºäº†æ–¹ä¾¿èµ·è§ï¼Œæˆ‘ä»¬ç”¨Dockeråœ¨åå°å¯åŠ¨ä¸€ä¸ªMySQLæ•°æ®åº“ï¼Œå°†å½“å‰çš„æ•°æ®åº“æ˜ å°„åˆ°æœ¬æœºçš„3326ç«¯å£ï¼Œè®¾ç½®rootå¯†ç ä¸º123456ã€‚åˆ›å»ºåä¸ºcrawlerçš„æ•°æ®åº“ã€‚

```plain
docker run -d --name mysql-test -p 3326:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql
docker exec -it mysql-test sh
CREATE DATABASE crawler;
use crawler;
```

åœ¨main.goçš„å¯åŠ¨å‚æ•°ä¸­ï¼Œåˆ›å»ºsqlstorageå¹¶æ³¨å…¥åˆ°Taskå½“ä¸­ã€‚æ³¨æ„ï¼Œè¿™é‡ŒWithSqlUrlçš„ä½œç”¨æ˜¯ä¼ é€’MySQLçš„è¿æ¥åœ°å€ã€‚

```plain
func main(){
 ...
  var storage collector.Storage
	storage, err = sqlstorage.New(
		sqlstorage.WithSqlUrl("root:123456@tcp(127.0.0.1:3326)/crawler?charset=utf8"),
		sqlstorage.WithLogger(logger.Named("sqlDB")),
		sqlstorage.WithBatchCount(2),
	)
	if err != nil {
		logger.Error("create sqlstorage failed")
		return
	}

	seeds := make([]*collect.Task, 0, 1000)
	seeds = append(seeds, &collect.Task{
		Property: collect.Property{
			Name: "douban_book_list",
		},
		Fetcher: f,
		Storage: storage,
	})

	s := engine.NewEngine(
		engine.WithFetcher(f),
		engine.WithLogger(logger),
		engine.WithWorkCount(5),
		engine.WithSeeds(seeds),
		engine.WithScheduler(engine.NewSchedule()),
	)

	s.Run()
}
```

è¿è¡Œä»£ç åï¼Œæ•°æ®å°†å­˜å‚¨åˆ°MySQLè¡¨çš„douban\_book\_listä¸­ã€‚æˆ‘ä»¬å¯ä»¥ç”¨å¤šç§ä¸æ•°æ®åº“äº¤äº’çš„å·¥å…·æŸ¥çœ‹è¡¨ä¸­çš„æ•°æ®ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬è¿™é‡Œä½¿ç”¨çš„æ˜¯DataGripï¼Œä½¿ç”¨åœ°å€ã€å¯†ç ã€å’Œå¯¹åº”çš„Crawler Databaseï¼Œå°±å¯ä»¥è¿æ¥åˆ°å¯¹åº”çš„æ•°æ®åº“ã€‚

![å›¾ç‰‡](https://static001.geekbang.org/resource/image/04/cf/04ee9f0b0998928d3de4aac18daf49cf.png?wh=1920x1620)

è¿è¡ŒSHOW FULL COLUMNS FROM douban\_book\_list; å¯ä»¥æŸ¥çœ‹ç”Ÿæˆçš„è¡¨çš„å­—æ®µå’Œç±»å‹ã€‚

![å›¾ç‰‡](https://static001.geekbang.org/resource/image/6f/79/6f2b4d50db3119e984e24bcc77d9a779.png?wh=1920x433)

è¿è¡Œselect * from douban\_book\_list; å¯ä»¥æŸ¥çœ‹è¡¨ä¸­å·²ç»æ’å…¥çš„æ•°æ®ã€‚

![å›¾ç‰‡](https://static001.geekbang.org/resource/image/d7/75/d75yy6c3955235c7040c8cb7df0e8975.png?wh=1920x197)

## æ€»ç»“

å¥½äº†ï¼Œè¿™èŠ‚è¯¾ï¼Œæˆ‘ä»¬ä»¥å­˜å‚¨æ•°æ®ä¸ºç›®æ ‡ï¼Œå®ç°äº†å­˜å‚¨å¼•æ“ã€‚æˆ‘ä»¬è¿˜ä»¥è±†ç“£å›¾ä¹¦çš„ç»“æ„åŒ–æ•°æ®ä¸ºä¾‹ï¼Œå­¦ä¹ äº†å¦‚ä½•å¯¹ä¸åŒçš„æ•°æ®è¿›è¡ŒæŠ½è±¡ã€‚æˆ‘ä»¥MySQLä¸ºä¾‹ï¼Œå¹¶ä½¿ç”¨äº†åŸç”Ÿçš„SQLè¯­å¥æ¥ä»æ“ä½œæ•°æ®åº“ï¼Œåœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­æˆ‘ä»¬å†æ¬¡çœ‹åˆ°äº†æ¥å£çš„å¼ºå¤§èƒ½åŠ›ã€‚å½“å‰çš„æ¶æ„èƒ½å¤Ÿå¸®åŠ©æˆ‘ä»¬æ¯”è¾ƒå®¹æ˜“åœ°å†™ä¸€ä¸ªæ–°çš„å­˜å‚¨å¼•æ“ï¼Œä¾‹å¦‚æŠŠæ•°æ®å­˜å‚¨åˆ°Kafkaï¼ŒMongoDBã€Excelä¸­çš„å­˜å‚¨å¼•æ“ã€‚å¦‚æœæˆ‘ä»¬å¸Œæœ›åœ¨åº•å±‚ä½¿ç”¨ORMåº“æ¥æ“ä½œæ•°æ®åº“ä¹Ÿä¼šæ¯”è¾ƒå®¹æ˜“ã€‚

## è¯¾åé¢˜

è¿™èŠ‚è¯¾çš„è¯¾åé¢˜æ˜¯è¿™æ ·çš„ï¼š

åœ¨å¯¹ä¸åŒçš„ç»“æ„åŒ–ä¿¡æ¯è¿›è¡ŒæŠ½è±¡æ—¶ï¼Œæˆ‘ä»¬ä½¿ç”¨äº†map\[string]interface{}æ¥å­˜å‚¨ä¹¦ç±çš„å±æ€§ã€‚é‚£ä¹ˆæˆ‘ä»¬æœ‰æ²¡æœ‰å¯èƒ½åœ¨æ•°æ®è¾“å‡ºæ—¶ç›´æ¥ä½¿ç”¨åƒBookè¿™æ ·çš„ç»“æ„ä½“ï¼ŒæŠŠæ•°æ®ç›´æ¥ä¼ é€’ç»™å­˜å‚¨å¼•æ“æ¥å¤„ç†å‘¢ï¼Ÿ

æ¬¢è¿ä½ åœ¨ç•™è¨€åŒºä¸æˆ‘äº¤æµè®¨è®ºï¼Œæˆ‘ä»¬ä¸‹èŠ‚è¯¾è§ã€‚
<div><strong>ç²¾é€‰ç•™è¨€ï¼ˆ1ï¼‰</strong></div><ul>
<li><span>å‡ºäº‘</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>æŒ‰æ–‡ä¸­çš„å†™æ³•ï¼ŒSqlStore.Flush() æ–¹æ³•ä¸èƒ½å¤„ç†åŒä¸€ä¸ªBatchä¸­å­˜åœ¨ä¸åŒTaskçš„DataCellçš„æƒ…å†µã€‚</p>2023-03-12</li><br/>
</ul>