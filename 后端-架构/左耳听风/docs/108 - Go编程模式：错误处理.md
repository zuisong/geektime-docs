ä½ å¥½ï¼Œæˆ‘æ˜¯é™ˆçš“ï¼Œç½‘åå·¦è€³æœµè€—å­ã€‚

é”™è¯¯å¤„ç†ä¸€ç›´æ˜¯ç¼–ç¨‹å¿…é¡»è¦é¢å¯¹çš„é—®é¢˜ã€‚é”™è¯¯å¤„ç†å¦‚æœåšå¾—å¥½çš„è¯ï¼Œä»£ç çš„ç¨³å®šæ€§ä¼šå¾ˆå¥½ã€‚ä¸åŒçš„è¯­è¨€æœ‰ä¸åŒçš„é”™è¯¯å¤„ç†çš„æ–¹å¼ã€‚Goè¯­è¨€ä¹Ÿä¸€æ ·ï¼Œè¿™èŠ‚è¯¾ï¼Œæˆ‘ä»¬æ¥è®¨è®ºä¸€ä¸‹Goè¯­è¨€çš„é”™è¯¯å‡ºå¤„ï¼Œå°¤å…¶æ˜¯é‚£ä»¤äººæŠ“ç‹‚çš„ `if err != nil` ã€‚

åœ¨æ­£å¼è®¨è®ºâ€œGoä»£ç é‡Œæ»¡å±çš„ `if err != nil` æ€ä¹ˆåŠâ€è¿™ä»¶äº‹å„¿ä¹‹å‰ï¼Œæˆ‘æƒ³å…ˆè¯´ä¸€è¯´ç¼–ç¨‹ä¸­çš„é”™è¯¯å¤„ç†ã€‚

## Cè¯­è¨€çš„é”™è¯¯æ£€æŸ¥

é¦–å…ˆï¼Œæˆ‘ä»¬çŸ¥é“ï¼Œå¤„ç†é”™è¯¯æœ€ç›´æ¥çš„æ–¹å¼æ˜¯é€šè¿‡é”™è¯¯ç ï¼Œè¿™ä¹Ÿæ˜¯ä¼ ç»Ÿçš„æ–¹å¼ï¼Œåœ¨è¿‡ç¨‹å¼è¯­è¨€ä¸­é€šå¸¸éƒ½æ˜¯ç”¨è¿™æ ·çš„æ–¹å¼å¤„ç†é”™è¯¯çš„ã€‚æ¯”å¦‚ C è¯­è¨€ï¼ŒåŸºæœ¬ä¸Šæ¥è¯´ï¼Œå…¶é€šè¿‡å‡½æ•°çš„è¿”å›å€¼æ ‡è¯†æ˜¯å¦æœ‰é”™ï¼Œç„¶åé€šè¿‡å…¨å±€çš„ `errno` å˜é‡åŠ ä¸€ä¸ª `errstr` çš„æ•°ç»„æ¥å‘Šè¯‰ä½ ä¸ºä»€ä¹ˆå‡ºé”™ã€‚

ä¸ºä»€ä¹ˆæ˜¯è¿™æ ·çš„è®¾è®¡å‘¢ï¼Ÿé“ç†å¾ˆç®€å•ï¼Œé™¤äº†å¯ä»¥å…±ç”¨ä¸€äº›é”™è¯¯ï¼Œæ›´é‡è¦çš„æ˜¯è¿™å…¶å®æ˜¯ä¸€ç§å¦¥åï¼Œæ¯”å¦‚ï¼š`read()`ã€ `write()`ã€ `open()` è¿™äº›å‡½æ•°çš„è¿”å›å€¼å…¶å®æ˜¯è¿”å›æœ‰ä¸šåŠ¡é€»è¾‘çš„å€¼ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œè¿™äº›å‡½æ•°çš„è¿”å›å€¼æœ‰ä¸¤ç§è¯­ä¹‰ï¼š

1. ä¸€ç§æ˜¯æˆåŠŸçš„å€¼ï¼Œæ¯”å¦‚ `open()` è¿”å›çš„æ–‡ä»¶å¥æŸ„æŒ‡é’ˆ `FILE*` ï¼›
2. å¦ä¸€ç§æ˜¯é”™è¯¯ `NULL`ã€‚è¿™ä¼šå¯¼è‡´è°ƒç”¨è€…å¹¶ä¸çŸ¥é“æ˜¯ä»€ä¹ˆåŸå› å‡ºé”™äº†ï¼Œéœ€è¦å»æ£€æŸ¥ `errno` ä»¥è·å¾—å‡ºé”™çš„åŸå› ï¼Œä»è€Œæ­£ç¡®åœ°å¤„ç†é”™è¯¯ã€‚

ä¸€èˆ¬è€Œè¨€ï¼Œè¿™æ ·çš„é”™è¯¯å¤„ç†æ–¹å¼åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹æ˜¯æ²¡ä»€ä¹ˆé—®é¢˜çš„ï¼Œä¸è¿‡ä¹Ÿæœ‰ä¾‹å¤–çš„æƒ…å†µï¼Œæˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹ä¸‹é¢è¿™ä¸ª C è¯­è¨€çš„å‡½æ•°ï¼š

```
int atoi(const char *str)
```

è¿™ä¸ªå‡½æ•°æ˜¯æŠŠä¸€ä¸ªå­—ç¬¦ä¸²è½¬æˆæ•´å‹ã€‚ä½†æ˜¯é—®é¢˜æ¥äº†ï¼Œå¦‚æœä¸€ä¸ªè¦è½¬çš„å­—ç¬¦ä¸²æ˜¯éæ³•çš„ï¼ˆä¸æ˜¯æ•°å­—çš„æ ¼å¼ï¼‰ï¼Œå¦‚ â€œABCâ€ æˆ–è€…æ•´å‹æº¢å‡ºäº†ï¼Œé‚£ä¹ˆè¿™ä¸ªå‡½æ•°åº”è¯¥è¿”å›ä»€ä¹ˆå‘¢ï¼Ÿå‡ºé”™è¿”å›ï¼Œè¿”å›ä»€ä¹ˆæ•°éƒ½ä¸åˆç†ï¼Œå› ä¸ºè¿™ä¼šå’Œæ­£å¸¸çš„ç»“æœæ··æ·†åœ¨ä¸€èµ·ã€‚æ¯”å¦‚ï¼Œå¦‚æœè¿”å› `0`ï¼Œå°±ä¼šå’Œæ­£å¸¸çš„å¯¹ â€œ0â€ å­—ç¬¦çš„è¿”å›å€¼å®Œå…¨æ··æ·†åœ¨ä¸€èµ·ï¼Œè¿™æ ·å°±æ— æ³•åˆ¤æ–­å‡ºé”™çš„æƒ…å†µäº†ã€‚ä½ å¯èƒ½ä¼šè¯´ï¼Œæ˜¯ä¸æ˜¯è¦æ£€æŸ¥ä¸€ä¸‹ `errno`å‘¢ï¼ŸæŒ‰é“ç†è¯´åº”è¯¥æ˜¯è¦å»æ£€æŸ¥çš„ï¼Œä½†æ˜¯ï¼Œæˆ‘ä»¬åœ¨ C99 çš„è§„æ ¼è¯´æ˜ä¹¦ä¸­å¯ä»¥çœ‹åˆ°è¿™æ ·çš„æè¿°ï¼š

> *7.20.1The functions atof, atoi, atol, and atoll need not affect the value of the integer expression errno on an error. If the value of the result cannot be represented, the behavior is undeï¬ned.*

åƒ`atoi()`ã€ `atof()`ã€ `atol()` æˆ– `atoll()` è¿™æ ·çš„å‡½æ•°ï¼Œæ˜¯ä¸ä¼šè®¾ç½® `errno`çš„ï¼Œè€Œä¸”ï¼Œå¦‚æœç»“æœæ— æ³•è®¡ç®—çš„è¯ï¼Œè¡Œä¸ºæ˜¯undefinedã€‚æ‰€ä»¥ï¼Œåæ¥ï¼Œlibc åˆç»™å‡ºäº†ä¸€ä¸ªæ–°çš„å‡½æ•°`strtol()`ï¼Œè¿™ä¸ªå‡½æ•°åœ¨å‡ºé”™çš„æ—¶å€™ä¼šè®¾ç½®å…¨å±€å˜é‡ `errno` ï¼š

```
long val = strtol(in_str, &endptr, 10);  //10çš„æ„æ€æ˜¯10è¿›åˆ¶

//å¦‚æœæ— æ³•è½¬æ¢
if (endptr == str) {
    fprintf(stderr, "No digits were found\n");
    exit(EXIT_FAILURE);
}

//å¦‚æœæ•´å‹æº¢å‡ºäº†
if ((errno == ERANGE && (val == LONG_MAX || val == LONG_MIN)) {
    fprintf(stderr, "ERROR: number out of range for LONG\n");
    exit(EXIT_FAILURE);
 }

//å¦‚æœæ˜¯å…¶å®ƒé”™è¯¯
if (errno != 0 && val == 0) {
    perror("strtol");
    exit(EXIT_FAILURE);
}
```

è™½ç„¶ï¼Œ`strtol()` å‡½æ•°è§£å†³äº† `atoi()` å‡½æ•°çš„é—®é¢˜ï¼Œä½†æ˜¯æˆ‘ä»¬è¿˜æ˜¯èƒ½æ„Ÿè§‰åˆ°ä¸æ˜¯å¾ˆèˆ’æœï¼Œä¹Ÿä¸æ˜¯å¾ˆè‡ªç„¶ã€‚

å› ä¸ºè¿™ç§ç”¨è¿”å›å€¼ + errno çš„é”™è¯¯æ£€æŸ¥æ–¹å¼ä¼šæœ‰ä¸€äº›é—®é¢˜ï¼š

- ç¨‹åºå‘˜ä¸€ä¸å°å¿ƒå°±ä¼šå¿˜è®°æ£€æŸ¥è¿”å›å€¼ï¼Œä»è€Œé€ æˆä»£ç çš„ Bugï¼›
- å‡½æ•°æ¥å£éå¸¸ä¸çº¯æ´ï¼Œæ­£å¸¸å€¼å’Œé”™è¯¯å€¼æ··æ·†åœ¨ä¸€èµ·ï¼Œå¯¼è‡´è¯­ä¹‰æœ‰é—®é¢˜ã€‚

æ‰€ä»¥ï¼Œåæ¥æœ‰ä¸€äº›ç±»åº“å°±å¼€å§‹åŒºåˆ†è¿™æ ·çš„äº‹æƒ…ã€‚æ¯”å¦‚ï¼ŒWindows çš„ç³»ç»Ÿè°ƒç”¨å¼€å§‹ä½¿ç”¨ `HRESULT` çš„è¿”å›æ¥ç»Ÿä¸€é”™è¯¯çš„è¿”å›å€¼ï¼Œè¿™æ ·å¯ä»¥æ˜ç¡®å‡½æ•°è°ƒç”¨æ—¶çš„è¿”å›å€¼æ˜¯æˆåŠŸè¿˜æ˜¯é”™è¯¯ã€‚ä½†è¿™æ ·ä¸€æ¥ï¼Œå‡½æ•°çš„ input å’Œ output åªèƒ½é€šè¿‡å‡½æ•°çš„å‚æ•°æ¥å®Œæˆï¼Œäºæ˜¯å°±å‡ºç°äº†æ‰€è°“çš„â€œå…¥å‚â€å’Œâ€œå‡ºå‚â€è¿™æ ·çš„åŒºåˆ«ã€‚

ç„¶è€Œï¼Œè¿™åˆä½¿å¾—å‡½æ•°æ¥å…¥ä¸­å‚æ•°çš„è¯­ä¹‰å˜å¾—å¾ˆå¤æ‚ï¼Œä¸€äº›å‚æ•°æ˜¯å…¥å‚ï¼Œä¸€äº›å‚æ•°æ˜¯å‡ºå‚ï¼Œå‡½æ•°æ¥å£å˜å¾—å¤æ‚äº†ä¸€äº›ã€‚è€Œä¸”ï¼Œä¾ç„¶æ²¡æœ‰è§£å†³å‡½æ•°çš„æˆåŠŸæˆ–å¤±è´¥å¯ä»¥è¢«äººä¸ºå¿½ç•¥çš„é—®é¢˜ã€‚

## Javaçš„é”™è¯¯å¤„ç†

Javaè¯­è¨€ä½¿ç”¨ `try-catch-finally` é€šè¿‡ä½¿ç”¨å¼‚å¸¸çš„æ–¹å¼æ¥å¤„ç†é”™è¯¯ï¼Œå…¶å®ï¼Œè¿™æ¯”èµ·Cè¯­è¨€çš„é”™è¯¯å¤„ç†è¿›äº†ä¸€å¤§æ­¥ï¼Œä½¿ç”¨æŠ›å¼‚å¸¸å’ŒæŠ“å¼‚å¸¸çš„æ–¹å¼å¯ä»¥è®©æˆ‘ä»¬çš„ä»£ç æœ‰è¿™æ ·ä¸€äº›å¥½å¤„ã€‚

- å‡½æ•°æ¥å£åœ¨ inputï¼ˆå‚æ•°ï¼‰å’Œ outputï¼ˆè¿”å›å€¼ï¼‰ä»¥åŠé”™è¯¯å¤„ç†çš„è¯­ä¹‰æ˜¯æ¯”è¾ƒæ¸…æ¥šçš„ã€‚
- æ­£å¸¸é€»è¾‘çš„ä»£ç å¯ä»¥è·Ÿé”™è¯¯å¤„ç†å’Œèµ„æºæ¸…ç†çš„ä»£ç åˆ†å¼€ï¼Œæé«˜äº†ä»£ç çš„å¯è¯»æ€§ã€‚
- å¼‚å¸¸ä¸èƒ½è¢«å¿½ç•¥ï¼ˆå¦‚æœè¦å¿½ç•¥ä¹Ÿéœ€è¦ catch ä½ï¼Œè¿™æ˜¯æ˜¾å¼å¿½ç•¥ï¼‰ã€‚
- åœ¨é¢å‘å¯¹è±¡çš„è¯­è¨€ä¸­ï¼ˆå¦‚ Javaï¼‰ï¼Œå¼‚å¸¸æ˜¯ä¸ªå¯¹è±¡ï¼Œæ‰€ä»¥ï¼Œå¯ä»¥å®ç°å¤šæ€å¼çš„ catchã€‚
- ä¸çŠ¶æ€è¿”å›ç ç›¸æ¯”ï¼Œå¼‚å¸¸æ•æ‰æœ‰ä¸€ä¸ªæ˜¾è‘—çš„å¥½å¤„ï¼Œé‚£å°±æ˜¯å‡½æ•°å¯ä»¥åµŒå¥—è°ƒç”¨ï¼Œæˆ–æ˜¯é“¾å¼è°ƒç”¨ï¼Œæ¯”å¦‚ï¼š

```
int x = add(a, div(b,c));
Pizza p = PizzaBuilder().SetSize(sz).SetPrice(p)...;
```

## Goè¯­è¨€çš„é”™è¯¯å¤„ç†

Go è¯­è¨€çš„å‡½æ•°æ”¯æŒå¤šè¿”å›å€¼ï¼Œæ‰€ä»¥ï¼Œå¯ä»¥åœ¨è¿”å›æ¥å£æŠŠä¸šåŠ¡è¯­ä¹‰ï¼ˆä¸šåŠ¡è¿”å›å€¼ï¼‰å’Œæ§åˆ¶è¯­ä¹‰ï¼ˆå‡ºé”™è¿”å›å€¼ï¼‰åŒºåˆ†å¼€ã€‚Go è¯­è¨€çš„å¾ˆå¤šå‡½æ•°éƒ½ä¼šè¿”å› resultã€err ä¸¤ä¸ªå€¼ï¼Œäºæ˜¯å°±æœ‰è¿™æ ·å‡ ç‚¹ï¼š

- å‚æ•°ä¸ŠåŸºæœ¬ä¸Šå°±æ˜¯å…¥å‚ï¼Œè€Œè¿”å›æ¥å£æŠŠç»“æœå’Œé”™è¯¯åˆ†ç¦»ï¼Œè¿™æ ·ä½¿å¾—å‡½æ•°çš„æ¥å£è¯­ä¹‰æ¸…æ™°ï¼›
- è€Œä¸”ï¼ŒGo è¯­è¨€ä¸­çš„é”™è¯¯å‚æ•°å¦‚æœè¦å¿½ç•¥ï¼Œéœ€è¦æ˜¾å¼åœ°å¿½ç•¥ï¼Œç”¨ _ è¿™æ ·çš„å˜é‡æ¥å¿½ç•¥ï¼›
- å¦å¤–ï¼Œå› ä¸ºè¿”å›çš„ `error` æ˜¯ä¸ªæ¥å£ï¼ˆå…¶ä¸­åªæœ‰ä¸€ä¸ªæ–¹æ³• `Error()`ï¼Œè¿”å›ä¸€ä¸ª `string` ï¼‰ï¼Œæ‰€ä»¥ä½ å¯ä»¥æ‰©å±•è‡ªå®šä¹‰çš„é”™è¯¯å¤„ç†ã€‚

å¦å¤–ï¼Œå¦‚æœä¸€ä¸ªå‡½æ•°è¿”å›äº†å¤šä¸ªä¸åŒç±»å‹çš„ `error`ï¼Œä½ ä¹Ÿå¯ä»¥ä½¿ç”¨ä¸‹é¢è¿™æ ·çš„æ–¹å¼ï¼š

```
if err != nil {
  switch err.(type) {
    case *json.SyntaxError:
      ...
    case *ZeroDivisionError:
      ...
    case *NullPointerError:
      ...
    default:
      ...
  }
}
```

æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œ**Goè¯­è¨€çš„é”™è¯¯å¤„ç†çš„æ–¹å¼ï¼Œæœ¬è´¨ä¸Šæ˜¯è¿”å›å€¼æ£€æŸ¥ï¼Œä½†æ˜¯å®ƒä¹Ÿå…¼é¡¾äº†å¼‚å¸¸çš„ä¸€äº›å¥½å¤„â€”â€”å¯¹é”™è¯¯çš„æ‰©å±•**ã€‚

## èµ„æºæ¸…ç†

å‡ºé”™åæ˜¯éœ€è¦åšèµ„æºæ¸…ç†çš„ï¼Œä¸åŒçš„ç¼–ç¨‹è¯­è¨€æœ‰ä¸åŒçš„èµ„æºæ¸…ç†çš„ç¼–ç¨‹æ¨¡å¼ã€‚

- Cè¯­è¨€ï¼šä½¿ç”¨çš„æ˜¯ `goto fail;` çš„æ–¹å¼åˆ°ä¸€ä¸ªé›†ä¸­çš„åœ°æ–¹è¿›è¡Œæ¸…ç†ï¼ˆç»™ä½ æ¨èä¸€ç¯‡æœ‰æ„æ€çš„æ–‡ç« ã€Š[ç”±è‹¹æœçš„ä½çº§BUGæƒ³åˆ°çš„](https://coolshell.cn/articles/11112.html)ã€‹ï¼Œä½ å¯ä»¥ç‚¹å‡»é“¾æ¥çœ‹ä¸€ä¸‹ï¼‰ã€‚
- C++è¯­è¨€ï¼šä¸€èˆ¬æ¥è¯´ä½¿ç”¨ [RAIIæ¨¡å¼](https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization)ï¼Œé€šè¿‡é¢å‘å¯¹è±¡çš„ä»£ç†æ¨¡å¼ï¼ŒæŠŠéœ€è¦æ¸…ç†çš„èµ„æºäº¤ç»™ä¸€ä¸ªä»£ç†ç±»ï¼Œç„¶åå†ææ„å‡½æ•°æ¥è§£å†³ã€‚
- Javaè¯­è¨€ï¼šå¯ä»¥åœ¨finally è¯­å¥å—é‡Œè¿›è¡Œæ¸…ç†ã€‚
- Goè¯­è¨€ï¼šä½¿ç”¨ `defer` å…³é”®è¯è¿›è¡Œæ¸…ç†ã€‚

ä¸‹é¢æ˜¯ä¸€ä¸ªGoè¯­è¨€çš„èµ„æºæ¸…ç†çš„ç¤ºä¾‹ï¼š

```
func Close(c io.Closer) {
  err := c.Close()
  if err != nil {
    log.Fatal(err)
  }
}

func main() {
  r, err := Open("a")
  if err != nil {
    log.Fatalf("error opening 'a'\n")
  }
  defer Close(r) // ä½¿ç”¨deferå…³é”®å­—åœ¨å‡½æ•°é€€å‡ºæ—¶å…³é—­æ–‡ä»¶ã€‚

  r, err = Open("b")
  if err != nil {
    log.Fatalf("error opening 'b'\n")
  }
  defer Close(r) // ä½¿ç”¨deferå…³é”®å­—åœ¨å‡½æ•°é€€å‡ºæ—¶å…³é—­æ–‡ä»¶ã€‚
}
```

## Error Check Hell

å¥½äº†ï¼Œè¯´åˆ° Go è¯­è¨€çš„ `if err !=nil` çš„ä»£ç äº†ï¼Œè¿™æ ·çš„ä»£ç çš„ç¡®æ˜¯èƒ½è®©äººå†™åˆ°åã€‚é‚£ä¹ˆæœ‰æ²¡æœ‰ä»€ä¹ˆå¥½çš„æ–¹å¼å‘¢ï¼Ÿæœ‰çš„ã€‚æˆ‘ä»¬å…ˆçœ‹ä¸€ä¸ªä»¤äººå´©æºƒçš„ä»£ç ã€‚

```
func parse(r io.Reader) (*Point, error) {

    var p Point

    if err := binary.Read(r, binary.BigEndian, &p.Longitude); err != nil {
        return nil, err
    }
    if err := binary.Read(r, binary.BigEndian, &p.Latitude); err != nil {
        return nil, err
    }
    if err := binary.Read(r, binary.BigEndian, &p.Distance); err != nil {
        return nil, err
    }
    if err := binary.Read(r, binary.BigEndian, &p.ElevationGain); err != nil {
        return nil, err
    }
    if err := binary.Read(r, binary.BigEndian, &p.ElevationLoss); err != nil {
        return nil, err
    }
}
```

è¦è§£å†³è¿™ä¸ªäº‹ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨å‡½æ•°å¼ç¼–ç¨‹çš„æ–¹å¼ï¼Œå¦‚ä¸‹ä»£ç ç¤ºä¾‹ï¼š

```
func parse(r io.Reader) (*Point, error) {
    var p Point
    var err error
    read := func(data interface{}) {
        if err != nil {
            return
        }
        err = binary.Read(r, binary.BigEndian, data)
    }

    read(&p.Longitude)
    read(&p.Latitude)
    read(&p.Distance)
    read(&p.ElevationGain)
    read(&p.ElevationLoss)

    if err != nil {
        return &p, err
    }
    return &p, nil
}
```

ä»è¿™æ®µä»£ç ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œæˆ‘ä»¬é€šè¿‡ä½¿ç”¨Closure çš„æ–¹å¼æŠŠç›¸åŒçš„ä»£ç ç»™æŠ½å‡ºæ¥é‡æ–°å®šä¹‰ä¸€ä¸ªå‡½æ•°ï¼Œè¿™æ ·å¤§é‡çš„ `if err!=nil` å¤„ç†å¾—å¾ˆå¹²å‡€äº†ï¼Œä½†æ˜¯ä¼šå¸¦æ¥ä¸€ä¸ªé—®é¢˜ï¼Œé‚£å°±æ˜¯æœ‰ä¸€ä¸ª `err` å˜é‡å’Œä¸€ä¸ªå†…éƒ¨çš„å‡½æ•°ï¼Œæ„Ÿè§‰ä¸æ˜¯å¾ˆå¹²å‡€ã€‚

é‚£ä¹ˆï¼Œæˆ‘ä»¬è¿˜èƒ½ä¸èƒ½æå¾—æ›´å¹²å‡€ä¸€ç‚¹å‘¢ï¼Ÿæˆ‘ä»¬ä»Go è¯­è¨€çš„ `bufio.Scanner()`ä¸­ä¼¼ä¹å¯ä»¥å­¦ä¹ åˆ°ä¸€äº›ä¸œè¥¿ï¼š

```
scanner := bufio.NewScanner(input)

for scanner.Scan() {
    token := scanner.Text()
    // process token
}

if err := scanner.Err(); err != nil {
    // process the error
}
```

å¯ä»¥çœ‹åˆ°ï¼Œ`scanner`åœ¨æ“ä½œåº•å±‚çš„I/Oçš„æ—¶å€™ï¼Œé‚£ä¸ªfor-loopä¸­æ²¡æœ‰ä»»ä½•çš„ `if err !=nil` çš„æƒ…å†µï¼Œé€€å‡ºå¾ªç¯åæœ‰ä¸€ä¸ª `scanner.Err()` çš„æ£€æŸ¥ï¼Œçœ‹æ¥ä½¿ç”¨äº†ç»“æ„ä½“çš„æ–¹å¼ã€‚æ¨¡ä»¿å®ƒï¼Œå°±å¯ä»¥å¯¹æˆ‘ä»¬çš„ä»£ç è¿›è¡Œé‡æ„äº†ã€‚

é¦–å…ˆï¼Œå®šä¹‰ä¸€ä¸ªç»“æ„ä½“å’Œä¸€ä¸ªæˆå‘˜å‡½æ•°ï¼š

```
type Reader struct {
    r   io.Reader
    err error
}

func (r *Reader) read(data interface{}) {
    if r.err == nil {
        r.err = binary.Read(r.r, binary.BigEndian, data)
    }
}
```

ç„¶åï¼Œæˆ‘ä»¬çš„ä»£ç å°±å¯ä»¥å˜æˆä¸‹é¢è¿™æ ·ï¼š

```
func parse(input io.Reader) (*Point, error) {
    var p Point
    r := Reader{r: input}

    r.read(&p.Longitude)
    r.read(&p.Latitude)
    r.read(&p.Distance)
    r.read(&p.ElevationGain)
    r.read(&p.ElevationLoss)

    if r.err != nil {
        return nil, r.err
    }

    return &p, nil
}
```

æœ‰äº†åˆšåˆšçš„è¿™ä¸ªæŠ€æœ¯ï¼Œæˆ‘ä»¬çš„â€œ[æµå¼æ¥å£ Fluent Interface](https://martinfowler.com/bliki/FluentInterface.html)â€ä¹Ÿå°±å¾ˆå®¹æ˜“å¤„ç†äº†ã€‚å¦‚ä¸‹æ‰€ç¤ºï¼š

```
package main

import (
  "bytes"
  "encoding/binary"
  "fmt"
)

// é•¿åº¦ä¸å¤Ÿï¼Œå°‘ä¸€ä¸ªWeight
var b = []byte {0x48, 0x61, 0x6f, 0x20, 0x43, 0x68, 0x65, 0x6e, 0x00, 0x00, 0x2c} 
var r = bytes.NewReader(b)

type Person struct {
  Name [10]byte
  Age uint8
  Weight uint8
  err error
}
func (p *Person) read(data interface{}) {
  if p.err == nil {
    p.err = binary.Read(r, binary.BigEndian, data)
  }
}

func (p *Person) ReadName() *Person {
  p.read(&p.Name) 
  return p
}
func (p *Person) ReadAge() *Person {
  p.read(&p.Age) 
  return p
}
func (p *Person) ReadWeight() *Person {
  p.read(&p.Weight) 
  return p
}
func (p *Person) Print() *Person {
  if p.err == nil {
    fmt.Printf("Name=%s, Age=%d, Weight=%d\n",p.Name, p.Age, p.Weight)
  }
  return p
}

func main() {   
  p := Person{}
  p.ReadName().ReadAge().ReadWeight().Print()
  fmt.Println(p.err)  // EOF é”™è¯¯
}
```

ç›¸ä¿¡ä½ åº”è¯¥çœ‹æ‡‚è¿™ä¸ªæŠ€å·§äº†ï¼Œä¸è¿‡ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå®ƒçš„ä½¿ç”¨åœºæ™¯æ˜¯æœ‰å±€é™çš„ï¼Œä¹Ÿå°±åªèƒ½åœ¨å¯¹äºåŒä¸€ä¸ªä¸šåŠ¡å¯¹è±¡çš„ä¸æ–­æ“ä½œä¸‹å¯ä»¥ç®€åŒ–é”™è¯¯å¤„ç†ï¼Œå¦‚æœæ˜¯å¤šä¸ªä¸šåŠ¡å¯¹è±¡ï¼Œè¿˜æ˜¯å¾—éœ€è¦å„ç§ `if err != nil`çš„æ–¹å¼ã€‚

## åŒ…è£…é”™è¯¯

æœ€åï¼Œå¤šè¯´ä¸€å¥ï¼Œæˆ‘ä»¬éœ€è¦åŒ…è£…ä¸€ä¸‹é”™è¯¯ï¼Œè€Œä¸æ˜¯å¹²å·´å·´åœ°æŠŠ`err`è¿”å›åˆ°ä¸Šå±‚ï¼Œæˆ‘ä»¬éœ€è¦æŠŠä¸€äº›æ‰§è¡Œçš„ä¸Šä¸‹æ–‡åŠ å…¥ã€‚

é€šå¸¸æ¥è¯´ï¼Œæˆ‘ä»¬ä¼šä½¿ç”¨ `fmt.Errorf()`æ¥å®Œæˆè¿™ä¸ªäº‹ï¼Œæ¯”å¦‚ï¼š

```
if err != nil {
   return fmt.Errorf("something failed: %v", err)
}
```

å¦å¤–ï¼Œåœ¨Goè¯­è¨€çš„å¼€å‘è€…ä¸­ï¼Œæ›´ä¸ºæ™®éçš„åšæ³•æ˜¯å°†é”™è¯¯åŒ…è£…åœ¨å¦ä¸€ä¸ªé”™è¯¯ä¸­ï¼ŒåŒæ—¶ä¿ç•™åŸå§‹å†…å®¹ï¼š

```
type authorizationError struct {
    operation string
    err error   // original error
}

func (e *authorizationError) Error() string {
    return fmt.Sprintf("authorization failed during %s: %v", e.operation, e.err)
}
```

å½“ç„¶ï¼Œæ›´å¥½çš„æ–¹å¼æ˜¯é€šè¿‡ä¸€ç§æ ‡å‡†çš„è®¿é—®æ–¹æ³•ï¼Œè¿™æ ·ï¼Œæˆ‘ä»¬æœ€å¥½ä½¿ç”¨ä¸€ä¸ªæ¥å£ï¼Œæ¯”å¦‚ `causer`æ¥å£ä¸­å®ç° `Cause()` æ–¹æ³•æ¥æš´éœ²åŸå§‹é”™è¯¯ï¼Œä»¥ä¾›è¿›ä¸€æ­¥æ£€æŸ¥ï¼š

```
type causer interface {
    Cause() error
}

func (e *authorizationError) Cause() error {
    return e.err
}
```

è¿™é‡Œæœ‰ä¸ªå¥½æ¶ˆæ¯æ˜¯ï¼Œè¿™æ ·çš„ä»£ç ä¸å¿…å†å†™äº†ï¼Œæœ‰ä¸€ä¸ªç¬¬ä¸‰æ–¹çš„[é”™è¯¯åº“](http://github.com/pkg/errors)ï¼Œå¯¹äºè¿™ä¸ªåº“ï¼Œæˆ‘æ— è®ºåˆ°å“ªå„¿éƒ½èƒ½çœ‹åˆ°å®ƒçš„å­˜åœ¨ï¼Œæ‰€ä»¥ï¼Œè¿™ä¸ªåŸºæœ¬ä¸Šæ¥è¯´å°±æ˜¯äº‹å®ä¸Šçš„æ ‡å‡†äº†ã€‚ä»£ç ç¤ºä¾‹å¦‚ä¸‹ï¼š

```
import "github.com/pkg/errors"

//é”™è¯¯åŒ…è£…
if err != nil {
    return errors.Wrap(err, "read failed")
}

// Causeæ¥å£
switch err := errors.Cause(err).(type) {
case *MyError:
    // handle specifically
default:
    // unknown error
}
```

## å‚è€ƒæ–‡ç« 

- [Golang Error Handling lesson by Rob Pike](http://jxck.hatenablog.com/entry/golang-error-handling-lesson-by-rob-pike)
- [Errors are values](https://blog.golang.org/errors-are-values)

å¥½äº†ï¼Œè¿™èŠ‚è¯¾å°±åˆ°è¿™é‡Œã€‚å¦‚æœä½ è§‰å¾—ä»Šå¤©çš„å†…å®¹å¯¹ä½ æœ‰æ‰€å¸®åŠ©ï¼Œæ¬¢è¿ä½ å¸®æˆ‘åˆ†äº«ç»™æ›´å¤šäººã€‚
<div><strong>ç²¾é€‰ç•™è¨€ï¼ˆ7ï¼‰</strong></div><ul>
<li><span>æ±ªè¾‰</span> ğŸ‘ï¼ˆ16ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>wrapå’Œcauseçš„é”™è¯¯åŒ…è£…åœ¨å®é™…é¡¹ç›®å¼€å‘ä¸­éå¸¸æœ‰ç”¨ï¼Œå¯ä»¥å¿«é€Ÿæ‰“å°å‡ºé”™è¯¯æ ˆï¼Œå¹¶æ ¹æ®errçš„ç±»å‹åšç‰¹æ®Šå¤„ç†ï¼Œæ¯”å¦‚æ ¹æ®errçº§åˆ«è¿›è¡Œä¸åŒçš„å‘Šè­¦ã€‚æˆ‘ä»¬è¿™è¾¹å¸¸å®šä¹‰ä¸€ä¸ªåŒ…å«codeå’Œmsgçš„structï¼Œå¹¶å®ç°Causeæ¥å£ã€‚å‡ºé”™çš„æ—¶å€™åŒ…ä¸Šç‰¹å®šçš„é”™è¯¯ç ï¼Œæœ€åæ ¹æ®Causeæ‰¾å‡ºé‡Œé¢çš„é”™è¯¯ç ï¼Œè®¾ç½®ä¸åŒçš„å‘Šè­¦çº§åˆ«ã€‚</p>2021-01-19</li><br/><li><span>@@fighting</span> ğŸ‘ï¼ˆ6ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>Go è¯­è¨€æœ€æ–°çš„ errors åŒ…ç»™å‡ºäº† %w çš„æ–¹å¼ï¼Œè€Œä¸æ˜¯ github.com&#47;pkg&#47;errors è¿™ä¸ªåŒ…</p>2021-04-01</li><br/><li><span>AlphaGao</span> ğŸ‘ï¼ˆ2ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p> ã€Go è¯­è¨€çš„èµ„æºæ¸…ç†çš„ç¤ºä¾‹ï¼šã€è¿™é‡Œçš„ä»£ç æ˜¯ä¸æ˜¯é‡å¤äº†</p>2021-03-29</li><br/><li><span>é™ŒéŸ³</span> ğŸ‘ï¼ˆ1ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>è¿™ä¸ªerrorsåº“å·²ç»åœ¨2021å¹´12æœˆ1å·å°å­˜ï¼Œä¸å†ç»´æŠ¤äº†ã€‚ç°åœ¨æœ‰æ›´å¥½çš„æ›¿ä»£å—ï¼Ÿ</p>2023-03-31</li><br/><li><span>Marvichov</span> ğŸ‘ï¼ˆ1ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>`Golang Error Handling lesson by Rob Pike` (http:&#47;&#47;jxck.hatenablog.com&#47;entry&#47;golang-error-handling-lesson-by-rob-pike) çš„é“¾æ¥é‡Œé¢æ˜¯æ—¥æ–‡çš„. æ­£ç¡®çš„é“¾æ¥åº”è¯¥æ˜¯ç¬¬äºŒä¸ªreferenceçš„é“¾æ¥?</p>2021-04-18</li><br/><li><span>Marvichov</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>&gt; There is one significant drawback to this approach, at least for some applications: there is no way to know how much of the processing completed before the error occurred. If that information is important, a more fine-grained approach is necessary. Often, though, an all-or-nothing check at the end is sufficient.

æ„Ÿè§‰åº”è¯¥åŠ è¿›`Error Check Hell` section. ä¸åƒexception, ä½ å¯ä»¥çŸ¥é“é”™åœ¨å“ªä¸€æ­¥, this approach honors **all-or-nothing**</p>2021-04-18</li><br/><li><span>Marvichov</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>nvm, the end of rob pike&#39;s article:

&gt; Finally, for the full story of my interaction with @jxck_, including a little video he recorded, visit his blog.</p>2021-04-18</li><br/>
</ul>