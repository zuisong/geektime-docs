ä½ å¥½ï¼Œæˆ‘æ˜¯é™ˆçš“ï¼Œç½‘åå·¦è€³æœµè€—å­ã€‚

æˆ‘ä»¬å†æ¥çœ‹Goè¯­è¨€è¿™ä¸ªæ¨¡å¼ï¼ŒGoè¯­è¨€çš„è¿™ä¸ªæ¨¡å¼æŒºå¥½ç©å„¿çš„ã€‚å£°æ˜ä¸€ä¸ªstructï¼Œè·ŸCå¾ˆä¸€æ ·ï¼Œç„¶åç›´æ¥æŠŠè¿™ä¸ªstructç±»å‹æ”¾åˆ°å¦ä¸€ä¸ªstructé‡Œã€‚

# å§”æ‰˜çš„ç®€å•ç¤ºä¾‹

æˆ‘ä»¬æ¥çœ‹å‡ ä¸ªç¤ºä¾‹ï¼š

```
type Widget struct {
    X, Y int
}

type Label struct {
    Widget        // Embedding (delegation)
    Text   string // Aggregation
    X int         // Override 
}

func (label Label) Paint() {
	// [0xc4200141e0] - Label.Paint("State")
    fmt.Printf("[%p] - Label.Paint(%q)\n", 
    	&label, label.Text)
}
```

ç”±ä¸Šé¢å¯çŸ¥ï¼š

- æˆ‘ä»¬å£°æ˜äº†ä¸€ä¸ª `Widget`ï¼Œå…¶æœ‰ `X`å’Œ`Y`ï¼›
- ç„¶åç”¨å®ƒæ¥å£°æ˜ä¸€ä¸ª `Label`ï¼Œç›´æ¥æŠŠ `Widget` å§”æ‰˜è¿›å»ï¼›
- ç„¶åå†ç»™ `Label` å£°æ˜å¹¶å®ç°äº†ä¸€ä¸ª `Paint()` æ–¹æ³•ã€‚

äºæ˜¯ï¼Œæˆ‘ä»¬å°±å¯ä»¥è¿™æ ·ç¼–ç¨‹äº†ï¼š

```
label := Label{Widget{10, 10}, "State", 100}

// X=100, Y=10, Text=State, Widget.X=10
fmt.Printf("X=%d, Y=%d, Text=%s Widget.X=%d\n", 
	label.X, label.Y, label.Text, 
	label.Widget.X)
fmt.Println()
// {Widget:{X:10 Y:10} Text:State X:100} 
// {{10 10} State 100}
fmt.Printf("%+v\n%v\n", label, label)

label.Paint()
```

æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œå¦‚æœæœ‰æˆå‘˜å˜é‡é‡åï¼Œåˆ™éœ€è¦æ‰‹åŠ¨åœ°è§£å†³å†²çªã€‚

æˆ‘ä»¬ç»§ç»­æ‰©å±•ä»£ç ã€‚

å…ˆæ¥ä¸€ä¸ª `Button`ï¼š

```
type Button struct {
    Label // Embedding (delegation)
}
 
func NewButton(x, y int, text string) Button {
    return Button{Label{Widget{x, y}, text, x}}
}
func (button Button) Paint() { // Override
    fmt.Printf("[%p] - Button.Paint(%q)\n", 
    	&button, button.Text)
}
func (button Button) Click() {
    fmt.Printf("[%p] - Button.Click()\n", &button)
}
```

å†æ¥ä¸€ä¸ª `ListBox`ï¼š

```
type ListBox struct {
    Widget          // Embedding (delegation)
    Texts  []string // Aggregation
    Index  int      // Aggregation
}
func (listBox ListBox) Paint() {
    fmt.Printf("[%p] - ListBox.Paint(%q)\n", 
    	&listBox, listBox.Texts)
}
func (listBox ListBox) Click() {
    fmt.Printf("[%p] - ListBox.Click()\n", &listBox)
}
```

ç„¶åï¼Œå£°æ˜ä¸¤ä¸ªæ¥å£ç”¨äºå¤šæ€ï¼š

```
type Painter interface {
    Paint()
}

type Clicker interface {
    Click()
}
```

äºæ˜¯æˆ‘ä»¬å°±å¯ä»¥è¿™æ ·æ³›å‹åœ°ä½¿ç”¨ï¼ˆæ³¨æ„å…¶ä¸­çš„ä¸¤ä¸ªforå¾ªç¯ï¼‰ï¼š

```
button1 := Button{Label{Widget{10, 70}, "OK", 10}}
button2 := NewButton(50, 70, "Cancel")
listBox := ListBox{Widget{10, 40}, 
    []string{"AL", "AK", "AZ", "AR"}, 0}

fmt.Println()
//[0xc4200142d0] - Label.Paint("State")
//[0xc420014300] - ListBox.Paint(["AL" "AK" "AZ" "AR"])
//[0xc420014330] - Button.Paint("OK")
//[0xc420014360] - Button.Paint("Cancel")
for _, painter := range []Painter{label, listBox, button1, button2} {
	painter.Paint()
}

fmt.Println()
//[0xc420014450] - ListBox.Click()
//[0xc420014480] - Button.Click()
//[0xc4200144b0] - Button.Click()
for _, widget := range []interface{}{label, listBox, button1, button2} {
    if clicker, ok := widget.(Clicker); ok {
    	clicker.Click()
    }
}
```

# ä¸€ä¸ª Undo çš„å§”æ‰˜é‡æ„

ä¸Šé¢è¿™ä¸ªæ˜¯ Go è¯­è¨€ä¸­çš„å§”æ‰˜å’Œæ¥å£å¤šæ€çš„ç¼–ç¨‹æ–¹å¼ï¼Œå…¶å®æ˜¯é¢å‘å¯¹è±¡å’ŒåŸå‹ç¼–ç¨‹ç»¼åˆçš„ç©æ³•ã€‚è¿™ä¸ªç©æ³•å¯ä¸å¯ä»¥ç©å¾—æ›´æœ‰æ„æ€å‘¢ï¼Ÿè¿™æ˜¯å¯ä»¥çš„ã€‚

é¦–å…ˆï¼Œæˆ‘ä»¬å…ˆå£°æ˜ä¸€ä¸ªæ•°æ®å®¹å™¨ï¼Œå…¶ä¸­æœ‰ `Add()`ã€ `Delete()` å’Œ `Contains()` æ–¹æ³•ã€‚è¿˜æœ‰ä¸€ä¸ªè½¬å­—ç¬¦ä¸²çš„æ–¹æ³•ã€‚

```
type IntSet struct {
    data map[int]bool
}

func NewIntSet() IntSet {
    return IntSet{make(map[int]bool)}
}

func (set *IntSet) Add(x int) {
    set.data[x] = true
}

func (set *IntSet) Delete(x int) {
    delete(set.data, x)
}

func (set *IntSet) Contains(x int) bool {
    return set.data[x]
}

func (set *IntSet) String() string { // Satisfies fmt.Stringer interface
    if len(set.data) == 0 {
        return "{}"
    }
    ints := make([]int, 0, len(set.data))
    for i := range set.data {
        ints = append(ints, i)
    }
    sort.Ints(ints)
    parts := make([]string, 0, len(ints))
    for _, i := range ints {
        parts = append(parts, fmt.Sprint(i))
    }
    return "{" + strings.Join(parts, ",") + "}"
}
```

æˆ‘ä»¬å¦‚ä¸‹ä½¿ç”¨è¿™ä¸ªæ•°æ®å®¹å™¨ï¼š

```
ints := NewIntSet()
for _, i := range []int{1, 3, 5, 7} {
    ints.Add(i)
    fmt.Println(ints)
}
for _, i := range []int{1, 2, 3, 4, 5, 6, 7} {
    fmt.Print(i, ints.Contains(i), " ")
    ints.Delete(i)
    fmt.Println(ints)
}
```

è¿™ä¸ªæ•°æ®å®¹å™¨å¹³æ·¡æ— å¥‡ï¼Œæˆ‘ä»¬æƒ³ç»™å®ƒåŠ ä¸€ä¸ªUndoçš„åŠŸèƒ½ã€‚æˆ‘ä»¬å¯ä»¥è¿™æ ·æ¥åšï¼š

```
type UndoableIntSet struct { // Poor style
    IntSet    // Embedding (delegation)
    functions []func()
}

func NewUndoableIntSet() UndoableIntSet {
    return UndoableIntSet{NewIntSet(), nil}
}

func (set *UndoableIntSet) Add(x int) { // Override
    if !set.Contains(x) {
        set.data[x] = true
        set.functions = append(set.functions, func() { set.Delete(x) })
    } else {
        set.functions = append(set.functions, nil)
    }
}

func (set *UndoableIntSet) Delete(x int) { // Override
    if set.Contains(x) {
        delete(set.data, x)
        set.functions = append(set.functions, func() { set.Add(x) })
    } else {
        set.functions = append(set.functions, nil)
    }
}

func (set *UndoableIntSet) Undo() error {
    if len(set.functions) == 0 {
        return errors.New("No functions to undo")
    }
    index := len(set.functions) - 1
    if function := set.functions[index]; function != nil {
        function()
        set.functions[index] = nil // Free closure for garbage collection
    }
    set.functions = set.functions[:index]
    return nil
}
```

äºæ˜¯å°±å¯ä»¥è¿™æ ·ä½¿ç”¨äº†ï¼š

```
ints := NewUndoableIntSet()
for _, i := range []int{1, 3, 5, 7} {
    ints.Add(i)
    fmt.Println(ints)
}
for _, i := range []int{1, 2, 3, 4, 5, 6, 7} {
    fmt.Println(i, ints.Contains(i), " ")
    ints.Delete(i)
    fmt.Println(ints)
}
fmt.Println()
for {
    if err := ints.Undo(); err != nil {
        break
    }
    fmt.Println(ints)
}
```

ä½†æ˜¯ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œæˆ‘ä»¬ç”¨äº†ä¸€ä¸ªæ–°çš„ `UndoableIntSet` å‡ ä¹é‡å†™äº†æ‰€æœ‰çš„ `IntSet` å’Œ â€œå†™â€ ç›¸å…³çš„æ–¹æ³•ï¼Œè¿™æ ·å°±å¯ä»¥æŠŠæ“ä½œè®°å½•ä¸‹æ¥ï¼Œç„¶å **Undo** äº†ã€‚

ä½†æ˜¯ï¼Œå¯èƒ½åˆ«çš„ç±»ä¹Ÿéœ€è¦Undoçš„åŠŸèƒ½ï¼Œæˆ‘æ˜¯ä¸æ˜¯è¦é‡å†™æ‰€æœ‰çš„éœ€è¦è¿™ä¸ªåŠŸèƒ½çš„ç±»å•Šï¼Ÿè¿™æ ·çš„ä»£ç ç±»ä¼¼ï¼Œå°±æ˜¯å› ä¸ºæ•°æ®å®¹å™¨ä¸ä¸€æ ·ï¼Œæˆ‘å°±è¦å»é‡å†™å®ƒä»¬ï¼Œè¿™å¤ªäºŒäº†ã€‚

æˆ‘ä»¬èƒ½ä¸èƒ½åˆ©ç”¨å‰é¢å­¦åˆ°çš„æ³›å‹ç¼–ç¨‹ã€å‡½æ•°å¼ç¼–ç¨‹ã€IoCç­‰èŒƒå¼æ¥æŠŠè¿™ä¸ªäº‹å¹²å¾—å¥½ä¸€äº›å‘¢ï¼Ÿå½“ç„¶æ˜¯å¯ä»¥çš„ã€‚

å¦‚ä¸‹æ‰€ç¤ºï¼š

- æˆ‘ä»¬å…ˆå£°æ˜ä¸€ä¸ª `Undo[]` çš„å‡½æ•°æ•°ç»„ï¼ˆå…¶å®æ˜¯ä¸€ä¸ªæ ˆï¼‰ï¼›
- å¹¶å®ç°ä¸€ä¸ªé€šç”¨ `Add()`ã€‚å…¶éœ€è¦ä¸€ä¸ªå‡½æ•°æŒ‡é’ˆï¼Œå¹¶æŠŠè¿™ä¸ªå‡½æ•°æŒ‡é’ˆå­˜æ”¾åˆ° `Undo[]` å‡½æ•°æ•°ç»„ä¸­ã€‚
- åœ¨ `Undo()` çš„å‡½æ•°ä¸­ï¼Œæˆ‘ä»¬ä¼šéå†`Undo[]`å‡½æ•°æ•°ç»„ï¼Œå¹¶æ‰§è¡Œä¹‹ï¼Œæ‰§è¡Œå®Œåå°±å¼¹æ ˆã€‚

```
type Undo []func()

func (undo *Undo) Add(function func()) {
    *undo = append(*undo, function)
}

func (undo *Undo) Undo() error {
    functions := *undo
    if len(functions) == 0 {
        return errors.New("No functions to undo")
    }
    index := len(functions) - 1
    if function := functions[index]; function != nil {
        function()
        functions[index] = nil // Free closure for garbage collection
    }
    *undo = functions[:index]
    return nil
}

```

é‚£ä¹ˆæˆ‘ä»¬çš„ `IntSet` å°±å¯ä»¥æ”¹å†™æˆå¦‚ä¸‹çš„å½¢å¼ï¼š

```
type IntSet struct {
    data map[int]bool
    undo Undo
}

func NewIntSet() IntSet {
    return IntSet{data: make(map[int]bool)}
}

```

ç„¶ååœ¨å…¶ä¸­çš„ `Add` å’Œ `Delete`ä¸­å®ç° Undo æ“ä½œã€‚

- `Add` æ“ä½œæ—¶åŠ å…¥ `Delete` æ“ä½œçš„ Undoã€‚
- `Delete` æ“ä½œæ—¶åŠ å…¥ `Add` æ“ä½œçš„ Undoã€‚

```

func (set *IntSet) Add(x int) {
    if !set.Contains(x) {
        set.data[x] = true
        set.undo.Add(func() { set.Delete(x) })
    } else {
        set.undo.Add(nil)
    }
}

func (set *IntSet) Delete(x int) {
    if set.Contains(x) {
        delete(set.data, x)
        set.undo.Add(func() { set.Add(x) })
    } else {
        set.undo.Add(nil)
    }
}

func (set *IntSet) Undo() error {
    return set.undo.Undo()
}

func (set *IntSet) Contains(x int) bool {
    return set.data[x]
}

```

æˆ‘ä»¬å†æ¬¡çœ‹åˆ°ï¼ŒGoè¯­è¨€çš„Undoæ¥å£æŠŠUndoçš„æµç¨‹ç»™æŠ½è±¡å‡ºæ¥ï¼Œè€Œè¦æ€ä¹ˆUndoçš„äº‹äº¤ç»™äº†ä¸šåŠ¡ä»£ç æ¥ç»´æŠ¤ï¼ˆé€šè¿‡æ³¨å†Œä¸€ä¸ªUndoçš„æ–¹æ³•ï¼‰ã€‚è¿™æ ·åœ¨Undoçš„æ—¶å€™ï¼Œå°±å¯ä»¥å›è°ƒè¿™ä¸ªæ–¹æ³•æ¥åšä¸ä¸šåŠ¡ç›¸å…³çš„Undoæ“ä½œäº†ã€‚

# å°ç»“

è¿™æ˜¯ä¸æ˜¯å’Œæœ€ä¸€å¼€å§‹çš„C++çš„æ³›å‹ç¼–ç¨‹å¾ˆåƒï¼Ÿä¹Ÿå’Œmapã€reduceã€filterè¿™æ ·çš„åªå…³å¿ƒæ§åˆ¶æµç¨‹ï¼Œä¸å…³å¿ƒä¸šåŠ¡é€»è¾‘çš„åšæ³•å¾ˆåƒï¼Ÿè€Œä¸”ï¼Œä¸€å¼€å§‹ç”¨ä¸€ä¸ªUndoableIntSetæ¥åŒ…è£…`IntSet`ç±»ï¼Œåˆ°åè¿‡æ¥åœ¨`IntSet`é‡Œä¾èµ–`Undo`ç±»ï¼Œè¿™å°±æ˜¯æ§åˆ¶åè½¬IoCã€‚

ä»¥ä¸‹æ˜¯ã€Šç¼–ç¨‹èŒƒå¼æ¸¸è®°ã€‹ç³»åˆ—æ–‡ç« çš„ç›®å½•ï¼Œæ–¹ä¾¿ä½ äº†è§£è¿™ä¸€ç³»åˆ—å†…å®¹çš„å…¨è²Œã€‚

- [01 | ç¼–ç¨‹èŒƒå¼æ¸¸è®°ï¼šèµ·æº](https://time.geekbang.org/column/article/301)
- [02 | ç¼–ç¨‹èŒƒå¼æ¸¸è®°ï¼šæ³›å‹ç¼–ç¨‹](https://time.geekbang.org/column/article/303)
- [03 | ç¼–ç¨‹èŒƒå¼æ¸¸è®°ï¼šç±»å‹ç³»ç»Ÿå’Œæ³›å‹çš„æœ¬è´¨](https://time.geekbang.org/column/article/2017)
- [04 | ç¼–ç¨‹èŒƒå¼æ¸¸è®°ï¼šå‡½æ•°å¼ç¼–ç¨‹](https://time.geekbang.org/column/article/2711)
- [05 | ç¼–ç¨‹èŒƒå¼æ¸¸è®°ï¼šä¿®é¥°å™¨æ¨¡å¼](https://time.geekbang.org/column/article/2723)
- [06 | ç¼–ç¨‹èŒƒå¼æ¸¸è®°ï¼šé¢å‘å¯¹è±¡ç¼–ç¨‹](https://time.geekbang.org/column/article/2729)
- [07 | ç¼–ç¨‹èŒƒå¼æ¸¸è®°ï¼šåŸºäºåŸå‹çš„ç¼–ç¨‹èŒƒå¼](https://time.geekbang.org/column/article/2741)
- [08 | ç¼–ç¨‹èŒƒå¼æ¸¸è®°ï¼šGo è¯­è¨€çš„å§”æ‰˜æ¨¡å¼](https://time.geekbang.org/column/article/2748)
- [09 | ç¼–ç¨‹èŒƒå¼æ¸¸è®°ï¼šç¼–ç¨‹çš„æœ¬è´¨](https://time.geekbang.org/column/article/2751)
- [10 | ç¼–ç¨‹èŒƒå¼æ¸¸è®°ï¼šé€»è¾‘ç¼–ç¨‹èŒƒå¼](https://time.geekbang.org/column/article/2752)
- [11 | ç¼–ç¨‹èŒƒå¼æ¸¸è®°ï¼šç¨‹åºä¸–ç•Œé‡Œçš„ç¼–ç¨‹èŒƒå¼](https://time.geekbang.org/column/article/2754)
<div><strong>ç²¾é€‰ç•™è¨€ï¼ˆ15ï¼‰</strong></div><ul>
<li><span>milley</span> ğŸ‘ï¼ˆ39ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>è¿™æ ·çš„ä»£ç å’Œæ€ç»´åªèƒ½è¯´èµå¿ƒæ‚¦ç›®ï¼</p>2018-02-06</li><br/><li><span>å°æ–‡åŒå­¦</span> ğŸ‘ï¼ˆ11ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>1ã€æ–‡ç« è¯´äº†ä»€ä¹ˆï¼Ÿ
æ–‡ç« åˆ†äº†ä¸¤éƒ¨åˆ†ï¼Œä¸€éƒ¨åˆ†å…ˆç®€å•è¯´äº† Golang çš„å§”æ‰˜ç”¨æ³•ã€‚ç®€å•æ¥è¯´ï¼Œå°±æ˜¯è®²ä¸€ä¸ª structA åµŒå¥—åˆ°å¦å¤–ä¸€ä¸ª structB ä¸­ï¼ŒstructB ä¼šè‡ªåŠ¨ç»§æ‰¿ structA çš„å­—æ®µã€‚å…¶åï¼Œé€šè¿‡ä¸€ä¸ªæ›´åŠ å¤æ‚çš„ä¾‹å­è¯´æ˜å§”æ‰˜çš„ç”¨æ³•ã€‚ï¼ˆä½œä¸ºä¸€ä¸ª Java ç¨‹åºå‘˜ï¼ŒGolang ä¸º struct å¢åŠ æ–¹æ³•ï¼Œå’Œå®šä¹‰æ¥å£çš„æ–¹æ³•è®©äººå°è±¡æ·±åˆ»ï¼‰

å¦ä¸€éƒ¨åˆ†ï¼Œä½œè€…ä¸¾äº†ä¸€ä¸ªæ›´åŠ å¤æ‚çš„ä¾‹å­è¯´æ˜ Go ä¸­å§”æ‰˜å’Œæ¥å£å¤šæ€æ˜¯å¦‚ä½•å®ç°ä¸€ä¸ªæ•°æ®å®¹å™¨çš„ Undo å®ç°çš„ã€‚ä¸ºäº†è¯´æ˜è¿™éƒ¨åˆ†ï¼Œä½œè€…é€šè¿‡ä»¥ä¸‹æ­¥éª¤ä¸€è¯´è¯´è¿›é˜¶è¯´æ˜ï¼š
1ã€æœ€ç®€å•çš„ä¸€ä¸ª IntSetï¼Œå¹¶å®šä¹‰äº† Add ï¼ŒDelete æ–¹æ³•ï¼›
2ã€é€šè¿‡ä¸€ä¸ªå§”æ‰˜çš„æ–¹æ³•ï¼Œå°† IntSet å§”æ‰˜ç»™ä¸€ä¸ªæ–°çš„ structï¼Œæ–° struct å†é‡å†™ä¸€æ¬¡ Addï¼ŒDelete æ–¹æ³•ä»¥è®°å½•æ­¥éª¤ï¼ˆä¿å­˜Undoå‡½æ•°å¯¹è±¡ï¼‰ï¼Œå®Œæˆ Undo åŠŸèƒ½ï¼›
3ã€æœ€åä½œè€…å¸Œæœ›å¯ä»¥è¿›ä¸€æ­¥æ”¹å†™ï¼Œç¼–å†™ä¸€ä¸ª Undo æ ˆï¼Œå§”æ‰˜ç»™ IntSet ï¼Œå¹¶åœ¨ IntSet ç¼–å†™ Addï¼ŒDelete çš„æ–¹æ³•ä¸­å°±å®Œæˆ Undo å‡½æ•°å¯¹è±¡çš„ä¿å­˜ã€‚è¿™ä¹Ÿæ˜¯ä¸€ä¸ªå®ç°æ–¹æ³•ã€‚</p>2020-11-04</li><br/><li><span>Jie</span> ğŸ‘ï¼ˆ4ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>æ±‚æ•™ï¼Œæœ€åé‚£æ®µä»£ç æ‰§è¡Œundoçš„æ—¶å€™ä¼šç»§ç»­æ·»åŠ undoå‡½æ•°ï¼Œé‚£æ ·ä¸å°±å›ä¸åˆ°æœ€åˆçš„çŠ¶æ€äº†ï¼Ÿåç»­ä¸€ç›´åœ¨æ’¤é”€undoâ€”æ’¤é”€æ’¤é”€undoâ€¦â€¦</p>2020-11-11</li><br/><li><span>äº¢ï¼ˆçŸ¥è¡Œåˆä¸€çš„è·¯ä¸Šï¼‰</span> ğŸ‘ï¼ˆ4ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>ä¾èµ–çš„ä¸œè¥¿è¦å¯é ã€ç¨³å®šï¼Œä¹Ÿå°±æ˜¯æ¥å£ã€‚
ä¸šåŠ¡ä¸æ§åˆ¶åˆ†ç¦»ï¼Œæ§åˆ¶å°±å¯ä»¥å¤ç”¨ã€‚
æŠŠå˜åŒ–é¢‘ç‡ä¸åŒçš„äº‹ç‰©åˆ†å¼€ã€‚</p>2019-02-26</li><br/><li><span>æ‹‰æ¬§</span> ğŸ‘ï¼ˆ3ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>goé‡Œé¢è¿™ä¸ªundoåŠŸèƒ½çš„å®ç°ç±»ä¼¼scalaé‡Œé¢çš„trait,ä¹Ÿæ˜¯æŠŠä¸€äº›åŠŸèƒ½æ¨¡å—ï¼ˆä»¥åŠå®ç°ï¼‰å•ç‹¬å°è£…èµ·æ¥ï¼Œç„¶åä»¥å§”æ‰˜æˆ–è€…ç»§æ‰¿çš„å½¢å¼ç»„è£…åˆ°ç±»é‡Œé¢ï¼Œè¿™ç§çµæ´»ç»„è£…çš„æ–¹å¼ç¡®å®æ¯”javaçš„interfaceè¦æ›´æ–¹ä¾¿ä½¿ç”¨ï¼Œä¸åŒè¯­è¨€ä¹‹é—´æ˜¯æœ‰å…±åŒç‚¹çš„</p>2019-05-29</li><br/><li><span>å¯»æ‰¾çš„äººcs</span> ğŸ‘ï¼ˆ3ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>webç«¯åŠŸèƒ½å¤šä¸€ç‚¹å°±å¥½äº†ï¼Œæ¯”å¦‚æ˜¾ç¤ºæ–‡ç« åˆ—è¡¨çš„æ—¶å€™æ„Ÿè§‰ä¸å¦‚appç«¯é‚£ä¹ˆæ¸…çˆ½</p>2019-02-06</li><br/><li><span>Jacob.C</span> ğŸ‘ï¼ˆ2ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>å†åœ¨undoé‡ŒåŠ ä¸ªåæ’¤é”€çš„åŠŸèƒ½ï¼Œå°±æ›´ç§€äº†</p>2021-03-05</li><br/><li><span>ä½ ä¸ºå•¥é‚£ä¹ˆç‰›</span> ğŸ‘ï¼ˆ2ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>å†™äº†åŠå¹´çš„goè¯­è¨€äº†ï¼Œç»ˆäºä½“ä¼šåˆ°goè¯­è¨€çš„ç¾æ„Ÿäº†ã€‚é‚£ç§åªè¦ä¼šå˜å˜å«çš„ï¼Œæˆ‘å°±è®¤ä¸ºæ˜¯ä¸€åªğŸ¦†çš„å¢ƒç•Œã€‚ğŸ˜ƒ</p>2020-09-15</li><br/><li><span>Z3</span> ğŸ‘ï¼ˆ2ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>sort.Ints(ints) parts := make([]string, 0, len(ints)) for _, i := range ints {


è¿™å—è¦sortå—ï¼Ÿ  èƒ½å¦ç›´æ¥for ï¼ˆi=0ï¼›i&lt;lenï¼‰print ints[i]</p>2018-02-06</li><br/><li><span>å°è™¾ç±³</span> ğŸ‘ï¼ˆ1ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>è¿™æ ·å†™çš„undoåœ¨ç¬¬ä¸€æ¬¡æ’å…¥è¿‡åï¼Œå¯ä»¥æ— é™æ’¤é”€äº†å§</p>2018-02-06</li><br/><li><span>å°ç ´</span> ğŸ‘ï¼ˆ1ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>å‡ ä¸ªæœˆå‰å¬åˆ°ä»£ç æ—¶é—´åšèŠ‚ç›®ï¼Œé™ˆè€å¸ˆè®²çš„å†…å®¹è®©æˆ‘æ„Ÿè§‰å¾ˆå®åœ¨ï¼Œä»Šå¤©ç»ˆäºè·Ÿè¿‡æ¥äº†ğŸ˜ƒ</p>2018-02-06</li><br/><li><span>qiushye</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>æ²¡æœ‰ç†è§£çš„å¯ä»¥ç›´æ¥æ‹·è´ä»£ç å»æ‰§è¡Œï¼Œä¸æ‡‚çš„åœ°æ–¹æ‰“æ—¥å¿—è¾“å‡ºæŒ‡é’ˆä¹‹ç±»çš„æ¥å¸®åŠ©ç†è§£ï¼Œå¯ä»¥æ€è€ƒä¸‹after undoçš„ç›¸åŒè¾“å‡ºå¦‚ä½•æ¥çš„ã€‚
package main

import (
	&quot;errors&quot;
	&quot;fmt&quot;
	&quot;sort&quot;
	&quot;strings&quot;
)

func main() {
	ints := NewIntSet()
	for _, i := range []int{1, 3, 5} {
		ints.Add(i)
		fmt.Println(&quot;after add:&quot;, ints.String())
	}
	for _, i := range []int{1, 2, 3, 4, 5} {
		fmt.Println(&quot;want delete:&quot;, i, ints.Contains(i), &quot; &quot;)
		ints.Delete(i)
		fmt.Println(&quot;after delete:&quot;, ints.String())
	}
	fmt.Println(&quot;------- undo result ---------&quot;)
	for {
		if err := ints.Undo(); err != nil {
			fmt.Println(err)
			break
		}
		fmt.Println(&quot;after undo:&quot;, ints.String())
	}
}
type IntSet struct {
	data map[int]bool
	undo Undo
}
func NewIntSet() IntSet {
	return IntSet{data: make(map[int]bool)}
}

func (set *IntSet) Add(x int) {
	if !set.Contains(x) {
		set.data[x] = true
		set.undo.Add(func() { set.Delete(x) })
	} else {
		set.undo.Add(nil)
	}
}

func (set *IntSet) Delete(x int) {
	if set.Contains(x) {
		delete(set.data, x)
		set.undo.Add(func() { set.Add(x) })
	} else {
		set.undo.Add(nil)
	}
}

func (set *IntSet) Undo() error {
	return set.undo.Undo()
}

func (set *IntSet) Contains(x int) bool {
	return set.data[x]
}

func (set *IntSet) String() string { 
	if len(set.data) == 0 {
		return &quot;{}&quot;
	}
	ints := make([]int, 0, len(set.data))
	for i := range set.data {
		ints = append(ints, i)
	}
	sort.Ints(ints)
	parts := make([]string, 0, len(ints))
	for _, i := range ints {
		parts = append(parts, fmt.Sprint(i))
	}
	return &quot;{&quot; + strings.Join(parts, &quot;,&quot;) + &quot;}&quot;
}

type Undo []func()

func (undo *Undo) Add(function func()) {
	*undo = append(*undo, function)
}

func (undo *Undo) Undo() error {
	functions := *undo
	if len(functions) == 0 {
		return errors.New(&quot;No functions to undo&quot;)
	}
	index := len(functions) - 1
	if function := functions[index]; function != nil {
		function()
		functions[index] = nil &#47;&#47; Free closure for garbage collection
	}
	*undo = functions[:index]
	return nil
}
</p>2023-09-15</li><br/><li><span>seedjyh</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>å§”æ‰˜æ¨¡å¼å…¶å®å°±æ˜¯åˆ©ç”¨äº†goçš„ç»„åˆåŠŸèƒ½å®ç°äº†ç±»ä¼¼C++çš„ç»§æ‰¿åŠŸèƒ½ã€‚å°±undoæ•°ç»„è€Œè¨€ï¼Œç»§æ‰¿äº†åŸºç±»çš„æ ˆã€æ³¨å†Œundoçš„æ–¹æ³•å’Œæ‰§è¡Œundoçš„æ–¹æ³•ã€‚</p>2021-10-20</li><br/><li><span>seedjyh</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>æœ€åçš„undoæ•°ç»„å¾ˆæœ‰æ„æ€ã€‚
åœ¨C++é‡Œï¼Œä¸€èˆ¬æ˜¯åŸºç±»Undoableæœ‰ä¸€ä¸ªpublicçš„å®ä½“å‡½æ•°Undoå’Œä¸€ä¸ªprivateçš„çº¯è™šå‡½æ•°undoï¼Œå‰è€…è°ƒç”¨åæœ€åï¼›å„ä¸ªéœ€è¦undoçš„å­ç±»å®ç°è¿™ä¸ªçº¯è™šå‡½æ•°ã€‚ä½†è¿™æ ·å°±å¼•å…¥äº†å¼ºè€¦åˆï¼ˆç»§æ‰¿ï¼‰ã€‚
åœ¨goé‡Œæ˜¯æ³¨å†Œä¸€ä¸ªé—­åŒ…ï¼Œè®©Undoæ•°ç»„å›è°ƒã€‚</p>2021-10-20</li><br/><li><span>Geek_bc461b</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>å•ä»undoåŠŸèƒ½æ¥è¯´ç”¨è£…é¥°å™¨æ¨¡å¼æ˜¯ä¸æ˜¯æ›´å¥½</p>2020-12-16</li><br/>
</ul>