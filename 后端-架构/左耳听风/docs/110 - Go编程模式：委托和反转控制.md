ä½ å¥½ï¼Œæˆ‘æ˜¯é™ˆçš“ï¼Œç½‘åå·¦è€³æœµè€—å­ã€‚

æ§åˆ¶åè½¬ï¼ˆ[Inversion of Control](https://en.wikipedia.org/wiki/Inversion_of_control)[ï¼ŒloC](https://en.wikipedia.org/wiki/Inversion_of_control) ï¼‰æ˜¯ä¸€ç§è½¯ä»¶è®¾è®¡çš„æ–¹æ³•ï¼Œå®ƒçš„ä¸»è¦æ€æƒ³æ˜¯æŠŠæ§åˆ¶é€»è¾‘ä¸ä¸šåŠ¡é€»è¾‘åˆ†å¼€ï¼Œä¸è¦åœ¨ä¸šåŠ¡é€»è¾‘é‡Œå†™æ§åˆ¶é€»è¾‘ï¼Œå› ä¸ºè¿™æ ·ä¼šè®©æ§åˆ¶é€»è¾‘ä¾èµ–äºä¸šåŠ¡é€»è¾‘ï¼Œè€Œæ˜¯åè¿‡æ¥ï¼Œè®©ä¸šåŠ¡é€»è¾‘ä¾èµ–æ§åˆ¶é€»è¾‘ã€‚

æˆ‘ä¹‹å‰åœ¨ã€Š[IoC/DIPå…¶å®æ˜¯ä¸€ç§ç®¡ç†æ€æƒ³](https://coolshell.cn/articles/9949.html)ã€‹è¿™ç¯‡æ–‡ç« ä¸­ï¼Œä¸¾è¿‡ä¸€ä¸ªå¼€å…³å’Œç”µç¯çš„ä¾‹å­ã€‚å…¶å®ï¼Œè¿™é‡Œçš„å¼€å…³å°±æ˜¯æ§åˆ¶é€»è¾‘ï¼Œç”µå™¨æ˜¯ä¸šåŠ¡é€»è¾‘ã€‚æˆ‘ä»¬ä¸è¦åœ¨ç”µå™¨ä¸­å®ç°å¼€å…³ï¼Œè€Œæ˜¯è¦æŠŠå¼€å…³æŠ½è±¡æˆä¸€ç§åè®®ï¼Œè®©ç”µå™¨éƒ½ä¾èµ–å®ƒã€‚è¿™æ ·çš„ç¼–ç¨‹æ–¹å¼å¯ä»¥æœ‰æ•ˆé™ä½ç¨‹åºå¤æ‚åº¦ï¼Œå¹¶æå‡ä»£ç é‡ç”¨åº¦ã€‚

é¢å‘å¯¹è±¡çš„è®¾è®¡æ¨¡å¼æˆ‘å°±ä¸æäº†ï¼Œæˆ‘ä»¬æ¥çœ‹çœ‹Goè¯­è¨€ä½¿ç”¨Embedç»“æ„çš„ä¸€ä¸ªç¤ºä¾‹ã€‚

## åµŒå…¥å’Œå§”æ‰˜

### ç»“æ„ä½“åµŒå…¥

åœ¨Goè¯­è¨€ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥å¾ˆè½»æ¾åœ°æŠŠä¸€ä¸ªç»“æ„ä½“åµŒåˆ°å¦ä¸€ä¸ªç»“æ„ä½“ä¸­ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```
type Widget struct {
    X, Y int
}
type Label struct {
    Widget        // Embedding (delegation)
    Text   string // Aggregation
}
```

åœ¨è¿™ä¸ªç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬æŠŠ `Widget`åµŒå…¥åˆ°äº† `Label` ä¸­ï¼Œäºæ˜¯ï¼Œæˆ‘ä»¬å¯ä»¥è¿™æ ·ä½¿ç”¨ï¼š

```
label := Label{Widget{10, 10}, "State:"}

label.X = 11
label.Y = 12
```

å¦‚æœåœ¨`Label` ç»“æ„ä½“é‡Œå‡ºç°äº†é‡åï¼Œå°±éœ€è¦è§£å†³é‡åé—®é¢˜ï¼Œä¾‹å¦‚ï¼Œå¦‚æœæˆå‘˜ `X` é‡åï¼Œæˆ‘ä»¬å°±è¦ç”¨ `label.X`è¡¨æ˜æ˜¯è‡ªå·±çš„`X` ï¼Œç”¨ `label.Wedget.X` è¡¨æ˜æ˜¯åµŒå…¥è¿‡æ¥çš„ã€‚

æœ‰äº†è¿™æ ·çš„åµŒå…¥ï¼Œæˆ‘ä»¬å°±å¯ä»¥åƒUIç»„ä»¶ä¸€æ ·ï¼Œåœ¨ç»“æ„çš„è®¾è®¡ä¸Šè¿›è¡Œå±‚å±‚åˆ†è§£äº†ã€‚æ¯”å¦‚ï¼Œæˆ‘å¯ä»¥æ–°å†™å‡ºä¸¤ä¸ªç»“æ„ä½“ `Button` å’Œ `ListBox`ï¼š

```
type Button struct {
    Label // Embedding (delegation)
}

type ListBox struct {
    Widget          // Embedding (delegation)
    Texts  []string // Aggregation
    Index  int      // Aggregation
}
```

### æ–¹æ³•é‡å†™

ç„¶åï¼Œæˆ‘ä»¬éœ€è¦ä¸¤ä¸ªæ¥å£ï¼šç”¨PainteræŠŠç»„ä»¶ç”»å‡ºæ¥ï¼›Clicker ç”¨äºè¡¨æ˜ç‚¹å‡»äº‹ä»¶ã€‚

```
type Painter interface {
    Paint()
}
 
type Clicker interface {
    Click()
}
```

å½“ç„¶ï¼Œå¯¹äº `Lable` æ¥è¯´ï¼Œåªæœ‰ `Painter` ï¼Œæ²¡æœ‰`Clicker`ï¼›å¯¹äº `Button` å’Œ `ListBox`æ¥è¯´ï¼Œ`Painter` å’Œ`Clicker`éƒ½æœ‰ã€‚

æˆ‘ä»¬æ¥çœ‹ä¸€äº›å®ç°ï¼š

```
func (label Label) Paint() {
  fmt.Printf("%p:Label.Paint(%q)\n", &label, label.Text)
}

//å› ä¸ºè¿™ä¸ªæ¥å£å¯ä»¥é€šè¿‡ Label çš„åµŒå…¥å¸¦åˆ°æ–°çš„ç»“æ„ä½“ï¼Œ
//æ‰€ä»¥ï¼Œå¯ä»¥åœ¨ Button ä¸­é‡è½½è¿™ä¸ªæ¥å£æ–¹æ³•
func (button Button) Paint() { // Override
    fmt.Printf("Button.Paint(%s)\n", button.Text)
}
func (button Button) Click() {
    fmt.Printf("Button.Click(%s)\n", button.Text)
}


func (listBox ListBox) Paint() {
    fmt.Printf("ListBox.Paint(%q)\n", listBox.Texts)
}
func (listBox ListBox) Click() {
    fmt.Printf("ListBox.Click(%q)\n", listBox.Texts)
}
```

è¯´åˆ°è¿™å„¿ï¼Œæˆ‘è¦é‡ç‚¹æé†’ä½ ä¸€ä¸‹ï¼Œ`Button.Paint()` æ¥å£å¯ä»¥é€šè¿‡ Label çš„åµŒå…¥å¸¦åˆ°æ–°çš„ç»“æ„ä½“ï¼Œå¦‚æœ `Button.Paint()` ä¸å®ç°çš„è¯ï¼Œä¼šè°ƒç”¨ `Label.Paint()` ï¼Œæ‰€ä»¥ï¼Œåœ¨ `Button` ä¸­å£°æ˜ `Paint()` æ–¹æ³•ï¼Œç›¸å½“äºOverrideã€‚

### åµŒå…¥ç»“æ„å¤šæ€

ä»ä¸‹é¢çš„ç¨‹åºä¸­ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°æ•´ä¸ªå¤šæ€æ˜¯æ€ä¹ˆæ‰§è¡Œçš„ã€‚

```
button1 := Button{Label{Widget{10, 70}, "OK"}}
button2 := NewButton(50, 70, "Cancel")
listBox := ListBox{Widget{10, 40}, 
    []string{"AL", "AK", "AZ", "AR"}, 0}

for _, painter := range []Painter{label, listBox, button1, button2} {
    painter.Paint()
}
 
for _, widget := range []interface{}{label, listBox, button1, button2} {
  widget.(Painter).Paint()
  if clicker, ok := widget.(Clicker); ok {
    clicker.Click()
  }
  fmt.Println() // print a empty line 
}
```

æˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ¥å£æ¥å¤šæ€ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨æ³›å‹çš„ `interface{}` æ¥å¤šæ€ï¼Œä½†æ˜¯éœ€è¦æœ‰ä¸€ä¸ªç±»å‹è½¬æ¢ã€‚

## åè½¬æ§åˆ¶

æˆ‘ä»¬å†æ¥çœ‹ä¸€ä¸ªç¤ºä¾‹ã€‚

æˆ‘ä»¬æœ‰ä¸€ä¸ªå­˜æ”¾æ•´æ•°çš„æ•°æ®ç»“æ„ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```
type IntSet struct {
    data map[int]bool
}
func NewIntSet() IntSet {
    return IntSet{make(map[int]bool)}
}
func (set *IntSet) Add(x int) {
    set.data[x] = true
}
func (set *IntSet) Delete(x int) {
    delete(set.data, x)
}
func (set *IntSet) Contains(x int) bool {
    return set.data[x]
}
```

å…¶ä¸­å®ç°äº† `Add()` ã€`Delete()` å’Œ `Contains()` ä¸‰ä¸ªæ“ä½œï¼Œå‰ä¸¤ä¸ªæ˜¯å†™æ“ä½œï¼Œåä¸€ä¸ªæ˜¯è¯»æ“ä½œã€‚

### å®ç°UndoåŠŸèƒ½

ç°åœ¨ï¼Œæˆ‘ä»¬æƒ³å®ç°ä¸€ä¸ª Undo çš„åŠŸèƒ½ã€‚æˆ‘ä»¬å¯ä»¥å†åŒ…è£…ä¸€ä¸‹ `IntSet` ï¼Œå˜æˆ `UndoableIntSet` ï¼Œä»£ç å¦‚ä¸‹æ‰€ç¤ºï¼š

```
type UndoableIntSet struct { // Poor style
    IntSet    // Embedding (delegation)
    functions []func()
}
 
func NewUndoableIntSet() UndoableIntSet {
    return UndoableIntSet{NewIntSet(), nil}
}
 

func (set *UndoableIntSet) Add(x int) { // Override
    if !set.Contains(x) {
        set.data[x] = true
        set.functions = append(set.functions, func() { set.Delete(x) })
    } else {
        set.functions = append(set.functions, nil)
    }
}


func (set *UndoableIntSet) Delete(x int) { // Override
    if set.Contains(x) {
        delete(set.data, x)
        set.functions = append(set.functions, func() { set.Add(x) })
    } else {
        set.functions = append(set.functions, nil)
    }
}

func (set *UndoableIntSet) Undo() error {
    if len(set.functions) == 0 {
        return errors.New("No functions to undo")
    }
    index := len(set.functions) - 1
    if function := set.functions[index]; function != nil {
        function()
        set.functions[index] = nil // For garbage collection
    }
    set.functions = set.functions[:index]
    return nil
}
```

æˆ‘æ¥è§£é‡Šä¸‹è¿™æ®µä»£ç ã€‚

- æˆ‘ä»¬åœ¨ `UndoableIntSet` ä¸­åµŒå…¥äº†`IntSet` ï¼Œç„¶åOverrideäº† å®ƒçš„ `Add()`å’Œ `Delete()` æ–¹æ³•ï¼›
- `Contains()` æ–¹æ³•æ²¡æœ‰Overrideï¼Œæ‰€ä»¥ï¼Œå°±è¢«å¸¦åˆ° `UndoableInSet` ä¸­æ¥äº†ã€‚
- åœ¨Overrideçš„ `Add()`ä¸­ï¼Œè®°å½• `Delete` æ“ä½œï¼›
- åœ¨Overrideçš„ `Delete()` ä¸­ï¼Œè®°å½• `Add` æ“ä½œï¼›
- åœ¨æ–°åŠ å…¥çš„ `Undo()` ä¸­è¿›è¡ŒUndoæ“ä½œã€‚

ç”¨è¿™æ ·çš„æ–¹å¼ä¸ºå·²æœ‰çš„ä»£ç æ‰©å±•æ–°çš„åŠŸèƒ½æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„é€‰æ‹©ã€‚è¿™æ ·ï¼Œå°±å¯ä»¥åœ¨é‡ç”¨åŸæœ‰ä»£ç åŠŸèƒ½å’Œæ–°çš„åŠŸèƒ½ä¸­è¾¾åˆ°ä¸€ä¸ªå¹³è¡¡ã€‚ä½†æ˜¯ï¼Œè¿™ç§æ–¹å¼æœ€å¤§çš„é—®é¢˜æ˜¯ï¼ŒUndoæ“ä½œå…¶å®æ˜¯ä¸€ç§æ§åˆ¶é€»è¾‘ï¼Œå¹¶ä¸æ˜¯ä¸šåŠ¡é€»è¾‘ï¼Œæ‰€ä»¥ï¼Œåœ¨å¤ç”¨ Undoè¿™ä¸ªåŠŸèƒ½æ—¶ï¼Œæ˜¯æœ‰é—®é¢˜çš„ï¼Œå› ä¸ºå…¶ä¸­åŠ å…¥äº†å¤§é‡è·Ÿ `IntSet` ç›¸å…³çš„ä¸šåŠ¡é€»è¾‘ã€‚

### åè½¬ä¾èµ–

ç°åœ¨æˆ‘ä»¬æ¥çœ‹å¦ä¸€ç§æ–¹æ³•ã€‚

æˆ‘ä»¬å…ˆå£°æ˜ä¸€ç§å‡½æ•°æ¥å£ï¼Œè¡¨ç¤ºæˆ‘ä»¬çš„Undoæ§åˆ¶å¯ä»¥æ¥å—çš„å‡½æ•°ç­¾åæ˜¯ä»€ä¹ˆæ ·çš„ï¼š

```
type Undo []func()
```

æœ‰äº†è¿™ä¸ªåè®®ä¹‹åï¼Œæˆ‘ä»¬çš„Undoæ§åˆ¶é€»è¾‘å°±å¯ä»¥å†™æˆä¸‹é¢è¿™æ ·ï¼š

```
func (undo *Undo) Add(function func()) {
  *undo = append(*undo, function)
}

func (undo *Undo) Undo() error {
  functions := *undo
  if len(functions) == 0 {
    return errors.New("No functions to undo")
  }
  index := len(functions) - 1
  if function := functions[index]; function != nil {
    function()
    functions[index] = nil // For garbage collection
  }
  *undo = functions[:index]
  return nil
}
```

çœ‹åˆ°è¿™é‡Œï¼Œä½ ä¸å¿…è§‰å¾—å¥‡æ€ªï¼Œ `Undo` æœ¬æ¥å°±æ˜¯ä¸€ä¸ªç±»å‹ï¼Œä¸å¿…æ˜¯ä¸€ä¸ªç»“æ„ä½“ï¼Œæ˜¯ä¸€ä¸ªå‡½æ•°æ•°ç»„ä¹Ÿæ²¡æœ‰ä»€ä¹ˆé—®é¢˜ã€‚

ç„¶åï¼Œæˆ‘ä»¬åœ¨IntSeté‡ŒåµŒå…¥ Undoï¼Œæ¥ç€åœ¨ `Add()` å’Œ `Delete()` é‡Œä½¿ç”¨åˆšåˆšçš„æ–¹æ³•ï¼Œå°±å¯ä»¥å®ŒæˆåŠŸèƒ½äº†ã€‚

```
type IntSet struct {
    data map[int]bool
    undo Undo
}
 
func NewIntSet() IntSet {
    return IntSet{data: make(map[int]bool)}
}

func (set *IntSet) Undo() error {
    return set.undo.Undo()
}
 
func (set *IntSet) Contains(x int) bool {
    return set.data[x]
}

func (set *IntSet) Add(x int) {
    if !set.Contains(x) {
        set.data[x] = true
        set.undo.Add(func() { set.Delete(x) })
    } else {
        set.undo.Add(nil)
    }
}
 
func (set *IntSet) Delete(x int) {
    if set.Contains(x) {
        delete(set.data, x)
        set.undo.Add(func() { set.Add(x) })
    } else {
        set.undo.Add(nil)
    }
}
```

è¿™ä¸ªå°±æ˜¯æ§åˆ¶åè½¬ï¼Œä¸æ˜¯ç”±æ§åˆ¶é€»è¾‘ `Undo` æ¥ä¾èµ–ä¸šåŠ¡é€»è¾‘ `IntSet`ï¼Œè€Œæ˜¯ç”±ä¸šåŠ¡é€»è¾‘ `IntSet` ä¾èµ– `Undo` ã€‚è¿™é‡Œä¾èµ–çš„æ˜¯å…¶å®æ˜¯ä¸€ä¸ªåè®®ï¼Œ**è¿™ä¸ªåè®®æ˜¯ä¸€ä¸ªæ²¡æœ‰å‚æ•°çš„å‡½æ•°æ•°ç»„ã€‚**å¯ä»¥çœ‹åˆ°ï¼Œè¿™æ ·ä¸€æ¥ï¼Œæˆ‘ä»¬ Undo çš„ä»£ç å°±å¯ä»¥å¤ç”¨äº†ã€‚

å¥½äº†ï¼Œè¿™èŠ‚è¯¾å°±åˆ°è¿™é‡Œã€‚å¦‚æœä½ è§‰å¾—ä»Šå¤©çš„å†…å®¹å¯¹ä½ æœ‰æ‰€å¸®åŠ©ï¼Œæ¬¢è¿ä½ å¸®æˆ‘åˆ†äº«ç»™æ›´å¤šäººã€‚
<div><strong>ç²¾é€‰ç•™è¨€ï¼ˆ8ï¼‰</strong></div><ul>
<li><span>limix</span> ğŸ‘ï¼ˆ5ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>æ§åˆ¶é€»è¾‘çš„ç‰¹å¾æ˜¯å¯å¤ç”¨æ€§æ¯”è¾ƒé«˜ï¼Œå¤šåœºæ™¯å¯ç”¨ï¼Œè€Œä¸šåŠ¡é€»è¾‘çš„ç‰¹å¾æ˜¯ä¸“ç”¨æ€§ï¼Œæ§åˆ¶é€»è¾‘ï¼Œåº”è¯¥å¤ç”¨æ§åˆ¶é€»è¾‘ï¼Œè€Œä¸æ˜¯å¤ç”¨ä¹Ÿè®¸é€»è¾‘</p>2022-09-07</li><br/><li><span>debugtalk</span> ğŸ‘ï¼ˆ4ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>æ‰‹åŠ¨ç‚¹èµ</p>2021-06-12</li><br/><li><span>cvvz</span> ğŸ‘ï¼ˆ1ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>åè½¬æ§åˆ¶ï¼š
ç¬¬ä¸€ç§æ”¹å†™æ–¹æ³•â€”â€”ç»§æ‰¿ï¼Œå¥½å¤„æ˜¯åŸæœ‰ä»£ç å¯ä»¥å¤ç”¨ï¼Œæ§åˆ¶é€»è¾‘å’Œä¸šåŠ¡é€»è¾‘è§£è€¦ï¼Œåå¤„æ˜¯é€šç”¨çš„æ§åˆ¶é€»è¾‘æ— æ³•å¤ç”¨
ç¬¬äºŒç§æ”¹å†™æ–¹æ³•â€”â€”åè½¬æ§åˆ¶ï¼Œå¥½å¤„æ˜¯å¤ç”¨é€šç”¨çš„æ§åˆ¶é€»è¾‘ï¼Œåå¤„æ˜¯è¦ä¿®æ”¹åŸæœ‰ä»£ç çš„é€»è¾‘ï¼ŒæŠŠæ§åˆ¶é€»è¾‘åµŒå…¥åˆ°äº†ä¸šåŠ¡é€»è¾‘ä¸­</p>2022-08-27</li><br/><li><span>Geek_ce6971</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>å®ç°undoåŠŸèƒ½ï¼Œæœ‰ä¸ªåœ°æ–¹æ˜¯å†™åäº†å—
åœ¨ Override çš„ Add()ä¸­ï¼Œè®°å½• Delete æ“ä½œï¼›åœ¨ Override çš„ Delete() ä¸­ï¼Œè®°å½• Add æ“ä½œï¼›</p>2022-01-19</li><br/><li><span>æ–¹å‹‡(gopher)</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>æ—¥å¸¸ä¸­æœ‰äº›è£…é¥°å™¨å…¶å®å¯ä»¥ç”¨è¿™ç§æ–¹å¼æ›¿æ¢</p>2021-12-20</li><br/><li><span>è¡¡å­</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>å‰å®³äº†ğŸ‘</p>2021-11-30</li><br/><li><span>ä¸€å…‰å¹´</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>æ§åˆ¶é€»è¾‘ä¾èµ–ä¸šåŠ¡é€»è¾‘ï¼Œä¸å¦‚è®©ä¸šåŠ¡å®¹å™¨ä¾èµ–æ§åˆ¶é€»è¾‘</p>2021-08-11</li><br/><li><span>Geek_46da16</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>ä¼šç©ï¼Œ</p>2021-07-26</li><br/>
</ul>