ä½ å¥½ï¼Œæˆ‘æ˜¯å¢èª‰å£°ï¼ŒAutodesk æ•°æ®å¹³å°å’Œè®¡ç®—å¹³å°èµ„æ·±è½¯ä»¶å·¥ç¨‹å¸ˆï¼Œä¹Ÿæ˜¯ã€Šç§»åŠ¨å¹³å°æ·±åº¦ç¥ç»ç½‘ç»œå®æˆ˜ã€‹å’Œã€Šåˆ†å¸ƒå¼å®æ—¶å¤„ç†ç³»ç»Ÿï¼šåŸç†æ¶æ„ä¸å®ç°ã€‹çš„ä½œè€…ï¼Œä¸»è¦ä»äº‹C/C++ã€JavaScriptå¼€å‘å·¥ä½œå’Œå¹³å°æ¶æ„æ–¹é¢çš„ç ”å‘å·¥ä½œï¼Œå¯¹SWIGä¹Ÿæœ‰æ¯”è¾ƒæ·±çš„ç ”ç©¶ã€‚å¾ˆé«˜å…´å—æå®¢æ—¶é—´é‚€è¯·æ¥åšæœ¬æ¬¡åˆ†äº«ï¼Œä»Šå¤©ï¼Œæˆ‘ä»¬å°±æ¥èŠä¸€èŠSWIGè¿™ä¸ªè¯é¢˜ã€‚

æˆ‘ä»¬éƒ½çŸ¥é“ï¼ŒPython æ˜¯ä¸€é—¨æ˜“äºä¸Šæ‰‹å¹¶å®éªŒå‹å¥½çš„èƒ¶æ°´è¯­è¨€ã€‚ç°åœ¨æœ‰å¾ˆå¤šæœºå™¨å­¦ä¹ å¼€å‘æˆ–ç ”ç©¶äººå‘˜ï¼Œéƒ½é€‰æ‹©Pythonä½œä¸ºä¸»åŠ›ç¼–ç¨‹è¯­è¨€ï¼›æµè¡Œçš„æœºå™¨å­¦ä¹ æ¡†æ¶ä¹Ÿéƒ½ä¼šæä¾›Pythonè¯­è¨€çš„æ”¯æŒä½œä¸ºè°ƒç”¨æ¥å£å’Œå·¥å…·ã€‚å› æ­¤ï¼Œç›¸è¾ƒäºå­¦ä¹ æˆæœ¬æ›´é«˜çš„C++æ¥è¯´ï¼ŒæŠŠPythonä½œä¸ºè¿›å…¥æœºå™¨å­¦ä¹ ä¸–ç•Œçš„é¦–é€‰ç¼–ç¨‹è¯­è¨€ï¼Œå°±å†åˆé€‚ä¸è¿‡äº†ã€‚

ä¸è¿‡ï¼ŒåƒTensorFlowæˆ–PyTorchè¿™æ ·çš„æœºå™¨å­¦ä¹ æ¡†æ¶çš„æ ¸å¿ƒï¼Œæ˜¯ä½¿ç”¨Pythonç¼–å†™çš„å—ï¼Ÿ

æ˜¾ç„¶ä¸æ˜¯ã€‚è¿™é‡Œé¢çš„åŸå› æ¯”è¾ƒå¤šï¼Œä½†æœ€ä¸ºæ˜¾è‘—çš„ä¸€ä¸ªåŸå› å°±æ˜¯â€œæ€§èƒ½â€ã€‚é€šè¿‡C++ç¼–å†™çš„æœºå™¨å­¦ä¹ æ¡†æ¶å†…æ ¸ï¼ŒåŠ ä¸Šç¼–è¯‘å™¨çš„ä¼˜åŒ–èƒ½åŠ›ï¼Œä¸ºç³»ç»Ÿæä¾›äº†æ¥è¿‘äºæœºå™¨ç æ‰§è¡Œçš„æ•ˆç‡ã€‚è¿™ç§å¾—å¤©ç‹¬åšçš„ä¼˜åŠ¿ï¼Œè®©C++åœ¨æœºå™¨å­¦ä¹ çš„æ ¸å¿ƒé¢†åŸŸç«™ç¨³äº†è„šè·Ÿã€‚æˆ‘ä»¬å‰é¢æ‰€è¯´çš„TensorFlowå’ŒPyTorchçš„æ ¸å¿ƒï¼Œä¾¿éƒ½æ˜¯ä½¿ç”¨C/C++å¼€å‘çš„ã€‚å…¶ä¸­ï¼ŒTensorFlowçš„å†…æ ¸ï¼Œå°±æ˜¯ç”±é«˜åº¦ä¼˜åŒ–çš„C++ä»£ç å’ŒCUDAç¼–å†™è€Œæˆã€‚

å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥ç†è§£ä¸ºï¼ŒTensorFlowé€šè¿‡Pythonæ¥æè¿°æ¨¡å‹ï¼Œè€Œå®é™…çš„è¿ç®—åˆ™æ˜¯ç”±é«˜æ€§èƒ½C++ä»£ç æ‰§è¡Œçš„ã€‚è€Œä¸”ï¼Œåœ¨ç»å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œä¸åŒæ“ä½œä¹‹é—´ä¼ é€’çš„æ•°æ®ï¼Œå¹¶ä¸ä¼šæ‹·è´å›Pythonä»£ç çš„æ‰§è¡Œç©ºé—´ã€‚æœºå™¨å­¦ä¹ æ¡†æ¶ï¼Œæ­£æ˜¯é€šè¿‡è¿™æ ·çš„æ–¹å¼ç¡®ä¿äº†è®¡ç®—æ€§èƒ½ï¼ŒåŒæ—¶å…¼é¡¾äº†å¯¹æ¡†æ¶æ˜“ç”¨æ€§æ–¹é¢çš„è€ƒè™‘ã€‚

å› æ­¤ï¼Œå½“Pythonå’ŒC++ç»“åˆä½¿ç”¨çš„æ—¶å€™ï¼ŒPythonæœ¬èº«çš„æ€§èƒ½ç“¶é¢ˆå°±ä¸é‚£ä¹ˆé‡è¦äº†ã€‚å®ƒè¶³å¤Ÿèƒœä»»æˆ‘ä»¬ç»™å®ƒçš„ä»»åŠ¡å°±å¯ä»¥äº†ï¼Œè‡³äºå¯¹è®¡ç®—æœ‰æ›´é«˜è¦æ±‚çš„ä»»åŠ¡ï¼Œå°±äº¤ç»™C++æ¥åšå§ï¼

ä»Šå¤©ï¼Œæˆ‘ä»¬å°±æ¥è®¨è®ºä¸‹ï¼Œå¦‚ä½•é€šè¿‡SWIGå¯¹C++ç¨‹åºè¿›è¡ŒPythonå°è£…ã€‚æˆ‘ä¼šå…ˆå¸¦ä½ ç¼–å†™ä¸€æ®µPythonè„šæœ¬ï¼Œæ¥æ‰§è¡Œä¸€ä¸ªç®€å•çš„æœºå™¨å­¦ä¹ ä»»åŠ¡ï¼›æ¥ç€ï¼Œå°è¯•å°†è®¡ç®—å¯†é›†çš„éƒ¨åˆ†æ”¹å†™æˆC++ç¨‹åºï¼Œå†é€šè¿‡SWIGå¯¹å…¶è¿›è¡Œå°è£…ã€‚æœ€åçš„ç»“æœå°±æ˜¯ï¼ŒPythonæŠŠè®¡ç®—å¯†é›†çš„ä»»åŠ¡å§”æ‰˜ç»™C++æ‰§è¡Œã€‚

æˆ‘ä»¬ä¼šå¯¹æ€§èƒ½åšä¸€ä¸ªç®€å•æ¯”è¾ƒï¼Œå¹¶åœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­ï¼Œè®²è§£ä½¿ç”¨SWIGçš„æ–¹æ³•ã€‚åŒæ—¶ï¼Œåœ¨ä»Šå¤©è¿™èŠ‚è¯¾çš„æœ€åï¼Œæˆ‘ä¼šä¸ºä½ æä¾›ä¸€ä¸ªå­¦ä¹ è·¯å¾„ï¼Œä½œä¸ºæ—¥åæé«˜çš„å‚è€ƒã€‚

æ˜ç¡®äº†ä»Šå¤©çš„å­¦ä¹ ç›®çš„ï¼Œä¹Ÿå°±æ˜¯ä½¿ç”¨SWIGæ¥å®ç°Pythonå¯¹C++ä»£ç çš„è°ƒç”¨ï¼Œé‚£ä¹ˆï¼Œæˆ‘ä»¬ä»Šå¤©çš„å†…å®¹ï¼Œå…¶å®å¯ä»¥çœ‹æˆä¸€ä»½**å…³äºSWIGçš„ç¼–ç¨‹å®è·µæŒ‡å—**ã€‚å­¦ä¹ è¿™ä»½æŒ‡å—ä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆæ¥ç®€å•äº†è§£ä¸€ä¸‹SWIGã€‚

## SWIG æ˜¯ä»€ä¹ˆï¼Ÿ

SWIGï¼Œæ˜¯ä¸€æ¬¾èƒ½å¤Ÿè¿æ¥C/C++ä¸å¤šç§é«˜çº§ç¼–ç¨‹è¯­è¨€ï¼ˆæˆ‘ä»¬åœ¨è¿™é‡Œç‰¹åˆ«å¼ºè°ƒPythonï¼‰çš„è½¯ä»¶å¼€å‘å·¥å…·ã€‚SWIGæ”¯æŒå¤šç§ä¸åŒç±»å‹çš„ç›®æ ‡è¯­è¨€ï¼Œè¿™å…¶ä¸­ï¼Œæ”¯æŒçš„å¸¸è§è„šæœ¬è¯­è¨€åŒ…æ‹¬JavaScriptã€Perlã€PHPã€Tclã€Rubyå’ŒPythonç­‰ï¼Œæ”¯æŒçš„é«˜çº§ç¼–ç¨‹è¯­è¨€åˆ™åŒ…æ‹¬C#ã€Dã€Goè¯­è¨€ã€Javaï¼ˆåŒ…æ‹¬å¯¹Androidçš„æ”¯æŒï¼‰ã€Luaã€OCamlã€Octaveã€Scilabå’ŒRã€‚

æˆ‘ä»¬é€šå¸¸ä½¿ç”¨SWIGæ¥åˆ›å»ºé«˜çº§è§£é‡Šæˆ–ç¼–è¯‘å‹çš„ç¼–ç¨‹ç¯å¢ƒå’Œæ¥å£ï¼Œå®ƒä¹Ÿå¸¸è¢«ç”¨æ¥å½“ä½œC/C++ç¼–å†™åŸå‹çš„æµ‹è¯•å·¥å…·ã€‚ä¸€ä¸ªå…¸å‹çš„åº”ç”¨åœºæ™¯ï¼Œä¾¿æ˜¯è§£æå’Œåˆ›å»ºC/C++æ¥å£ï¼Œç”Ÿæˆèƒ¶æ°´ä»£ç ä¾›åƒPythonè¿™æ ·çš„é«˜çº§ç¼–ç¨‹è¯­è¨€è°ƒç”¨ã€‚è¿‘æœŸå‘å¸ƒçš„4.0.0ç‰ˆæœ¬ï¼Œæ›´æ˜¯å¸¦æ¥äº†å¯¹C++çš„æ˜¾è‘—æ”¹è¿›å’Œæ”¯æŒï¼Œè¿™å…¶ä¸­åŒ…æ‹¬ï¼ˆä¸å±€é™äºï¼‰ä¸‹é¢å‡ ç‚¹ã€‚

- é’ˆå¯¹C#ã€Javaå’ŒRubyè€Œæ”¹è¿›çš„STLåŒ…è£…å™¨ã€‚
- é’ˆå¯¹Javaã€Pythonå’ŒRubyï¼Œå¢åŠ C++11æ ‡å‡†ä¸‹çš„STLå®¹å™¨çš„æ”¯æŒã€‚
- æ”¹è¿›äº†å¯¹C++11å’ŒC++14ä»£ç çš„æ”¯æŒã€‚
- ä¿®æ­£äº†C++ä¸­å¯¹æ™ºèƒ½æŒ‡é’ˆshared\_ptrçš„ä¸€ç³»åˆ—bugä¿®å¤ã€‚
- ä¸€ç³»åˆ—é’ˆå¯¹Cé¢„å¤„ç†å™¨çš„æç«¯caseä¿®å¤ã€‚
- ä¸€ç³»åˆ—é’ˆå¯¹æˆå‘˜å‡½æ•°æŒ‡é’ˆé—®é¢˜çš„ä¿®å¤ã€‚
- ä½æ”¯æŒçš„Pythonç‰ˆæœ¬ä¸º2.7ã€3.2-3.7ã€‚

## ä½¿ç”¨Pythonå®ç°PCAç®—æ³•

å€ŸåŠ©äºSWIGï¼Œæˆ‘ä»¬å¯ä»¥ç®€å•åœ°å®ç°ç”¨Pythonè°ƒç”¨C/C++åº“ï¼Œç”šè‡³å¯ä»¥ç”¨Pythonç»§æ‰¿å’Œä½¿ç”¨C++ç±»ã€‚æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å…ˆæ¥çœ‹ä¸€ä¸ªä½ ååˆ†ç†Ÿæ‚‰çš„ä½¿ç”¨Pythonç¼–å†™çš„PCAï¼ˆPrincipal Component Analysisï¼Œä¸»æˆåˆ†åˆ†æï¼‰ç®—æ³•ã€‚

å› ä¸ºæˆ‘ä»¬ä»Šå¤©çš„ç›®æ ‡ä¸æ˜¯è®²è§£PCAç®—æ³•ï¼Œæ‰€ä»¥å¦‚æœä½ å¯¹è¿™ä¸ªç®—æ³•è¿˜ä¸æ˜¯å¾ˆç†Ÿæ‚‰ï¼Œä¹Ÿæ²¡æœ‰å…³ç³»ï¼Œæˆ‘ä¼šç›´æ¥ç»™å‡ºå…·ä½“çš„ä»£ç ï¼Œæˆ‘ä»¬æŠŠç„¦ç‚¹æ”¾åœ¨å¦‚ä½•ä½¿ç”¨SWIGä¸Šå°±å¯ä»¥äº†ã€‚ä¸‹é¢ï¼Œæˆ‘å…ˆç»™å‡ºä»£ç æ¸…å•1ã€‚

ä»£ç æ¸…å•1ï¼ŒåŸºäºPythonç¼–å†™çš„PCAç®—æ³• `testPCAPurePython.py` ï¼š

```
import numpy as np

def compute_pca(data):
    m = np.mean(data, axis=0)
    datac = np.array([obs - m for obs in data])
    T = np.dot(datac, datac.T)
    [u,s,v] = np.linalg.svd(T)

    pcs = [np.dot(datac.T, item) for item in u.T ]

     pcs = np.array([d / np.linalg.norm(d) for d in pcs])

     return pcs, m, s, T, u

 def compute_projections(I,pcs,m):
     projections = []
     for i in I:
         w = []
         for p in pcs:
             w.append(np.dot(i - m, p))
         projections.append(w)
     return projections

 def reconstruct(w, X, m,dim = 5):
     return np.dot(w[:dim],X[:dim,:]) + m

 def normalize(samples, maxs = None):
     if not maxs:
         maxs = np.max(samples)
     return np.array([np.ravel(s) / maxs for s in samples])
```

ç°åœ¨ï¼Œæˆ‘ä»¬ä¿å­˜è¿™æ®µç¼–å†™å¥½çš„ä»£ç ï¼Œå¹¶é€šè¿‡ä¸‹é¢çš„å‘½ä»¤æ¥æ‰§è¡Œï¼š

```
python3 testPCAPurePython.py 
```

## å‡†å¤‡SWIG

è¿™æ ·ï¼Œæˆ‘ä»¬å·²ç»è·å¾—äº†ä¸€äº›è¿›å±•â€”â€”ä½¿ç”¨Pythonç¼–å†™äº†ä¸€ä¸ªPCAç®—æ³•ï¼Œå¹¶å¾—åˆ°äº†ä¸€äº›ç»“æœã€‚æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬çœ‹ä¸€ä¸‹å¦‚ä½•å¼€å§‹SWIGçš„å¼€å‘å·¥ä½œã€‚æˆ‘ä¼šå…ˆä»ç¼–è¯‘ç›¸å…³ç»„ä»¶å¼€å§‹ï¼Œå†ä»‹ç»ä¸€ä¸ªç®€å•ä½¿ç”¨çš„ä¾‹å­ï¼Œä¸ºåç»­å†…å®¹åšå‡†å¤‡ã€‚

é¦–å…ˆï¼Œæˆ‘ä»¬ä»SWIGçš„ç½‘ç«™ï¼ˆ[http://swig.org/download.html](http://swig.org/download.html)ï¼‰ä¸‹è½½æºä»£ç åŒ…ï¼Œå¹¶å¼€å§‹æ„å»ºï¼š

```
$ wget https://newcontinuum.dl.sourceforge.net/project/swig/swig/swig-4.0.0/swig-4.0.0.tar.gz # ä¸‹è½½è·¯å¾„å¯èƒ½ä¼šæœ‰æ‰€å˜åŒ–
$ tar -xvf swig-4.0.0.tar.gz
$ cd swig-4.0.0
$ wget https://ftp.pcre.org/pub/pcre/pcre-8.43.tar.gz # SWIGéœ€è¦ä¾èµ–pcreå·¥ä½œ
$ sh ./Tools/pcre-build.sh # è¯¥è„šæœ¬ä¼šå°†pcreè‡ªåŠ¨æ„å»ºæˆSWIGä½¿ç”¨çš„é™æ€åº“
$ ./configure # æ³¨æ„éœ€è¦å®‰è£…bisonï¼Œå¦‚æœæ²¡æœ‰å®‰è£…éœ€è¦è¯»è€…æ‰‹åŠ¨å®‰è£…
$ make
$ sudo make install
```

ä¸€åˆ‡å°±ç»ªåï¼Œæˆ‘ä»¬å°±æ¥ç¼–å†™ä¸€ä¸ªç®€å•çš„ä¾‹å­å§ã€‚è¿™ä¸ªä¾‹å­åŒæ ·æ¥æºäºSWIGç½‘ç«™ï¼ˆ[http://swig.org/tutorial.html](http://swig.org/tutorial.html)ï¼‰ã€‚æˆ‘ä»¬å…ˆæ¥åˆ›å»ºä¸€ä¸ªç®€å•çš„cæ–‡ä»¶ï¼Œä½ å¯ä»¥é€šè¿‡ä½ ä¹ æƒ¯ä½¿ç”¨çš„æ–‡æœ¬ç¼–è¾‘å™¨ï¼ˆæ¯”å¦‚viï¼‰ï¼Œåˆ›å»ºä¸€ä¸ªåä¸º`example.c`çš„æ–‡ä»¶ï¼Œå¹¶ç¼–å†™ä»£ç ã€‚ä»£ç å†…å®¹æˆ‘æ”¾åœ¨äº†ä»£ç æ¸…å•2ä¸­ã€‚

ä»£ç æ¸…å•2ï¼Œ`example.c`ï¼š

```
#include <time.h>
double My_variable = 3.0;

int fact(int n) {
    if (n <= 1) return 1;
    else return n*fact(n-1);
}

int my_mod(int x, int y) {
    return (x%y);
}
       
char *get_time()
{
    time_t ltime;
    time(&ltime);
    return ctime(&ltime);
}
```

æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬ç¼–å†™ä¸€ä¸ªåä¸º`example.i`çš„æ¥å£å®šä¹‰æ–‡ä»¶ï¼Œå’Œç¨åç”¨ä½œæµ‹è¯•çš„Pythonè„šæœ¬ï¼Œå†…å®¹å¦‚ä»£ç æ¸…å•3å’Œä»£ç æ¸…å•4æ‰€ç¤ºã€‚

ä»£ç æ¸…å•3ï¼Œ`example.i`ï¼š

```
%module example
%{
/* Put header files here or function declarations like below */
extern double My_variable;
extern int fact(int n);
extern int my_mod(int x, int y);
extern char *get_time();
%}

extern double My_variable;
extern int fact(int n);
extern int my_mod(int x, int y);
extern char *get_time();
```

æˆ‘æ¥è§£é‡Šä¸‹æ¸…å•3è¿™æ®µä»£ç ã€‚ç¬¬1è¡Œï¼Œæˆ‘ä»¬å®šä¹‰äº†æ¨¡å—çš„åç§°ä¸ºexampleã€‚ç¬¬2-8è¡Œï¼Œæˆ‘ä»¬ç›´æ¥æŒ‡å®šäº†`example.c`ä¸­çš„å‡½æ•°å®šä¹‰ï¼Œä¹Ÿå¯ä»¥å®šä¹‰ä¸€ä¸ª`example.h`å¤´æ–‡ä»¶ï¼Œå¹¶å°†è¿™äº›å®šä¹‰åŠ å…¥å…¶ä¸­ï¼›ç„¶åï¼Œåœ¨ `%{ â€¦ %}`ç»“æ„ä½“ä¸­åŒ…å«`example.h`ï¼Œæ¥å®ç°ç›¸åŒçš„åŠŸèƒ½ã€‚ç¬¬`10-13`è¡Œï¼Œåˆ™æ˜¯å®šä¹‰äº†å¯¼å‡ºçš„æ¥å£ï¼Œä»¥ä¾¿ä½ åœ¨Pythonä¸­ç›´æ¥è°ƒç”¨è¿™äº›æ¥å£ã€‚

ä»£ç æ¸…å•4ï¼Œ`testExample.py`ï¼š

```
import example
print(example.fact(5))
print(example.my_mod(7,3))
print(example.get_time())
```

å¥½äº†ï¼Œ åˆ°ç°åœ¨ä¸ºæ­¢ï¼Œæˆ‘ä»¬å·²ç»å‡†å¤‡å°±ç»ªäº†ã€‚ç°åœ¨ï¼Œæˆ‘ä»¬æ¥æ‰§è¡Œä¸‹é¢çš„ä»£ç ï¼Œåˆ›å»ºç›®æ ‡æ–‡ä»¶å’Œæœ€åé“¾æ¥çš„æ–‡ä»¶å§ï¼š

```
swig -python example.i
gcc -c -fPIC example.c example_wrap.c -I/usr/include/python3.6
gcc -shared example.o example_wrap.o -o _example.so
python3 testExample.py # æµ‹è¯•è°ƒç”¨
```

å…¶å®ï¼Œä»ä»£ç æ¸…å•4ä¸­ä½ ä¹Ÿèƒ½å¤Ÿçœ‹åˆ°ï¼Œé€šè¿‡å¯¼å…¥exampleï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥åœ¨Pythonè„šæœ¬ä¸­ï¼Œè°ƒç”¨ä½¿ç”¨Cå®ç°çš„å‡½æ•°æ¥å£ï¼Œå¹¶è·å¾—è¿”å›å€¼ã€‚

## é€šè¿‡SWIGå°è£…åŸºäºC++ç¼–å†™çš„Pythonæ¨¡å—

åˆ°è¿™ä¸€æ­¥ï¼Œæˆ‘ä»¬å·²ç»å‡†å¤‡å¥½äº†ä¸€ä»½ä½¿ç”¨C++ç¼–å†™çš„PCAç®—æ³•ï¼Œæ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°±è¦å¯¹å…¶è¿›è¡Œä¸€ä¸ªç®€å•çš„å°è£…ã€‚ç”±äºC++ç¼ºå°‘çº¿æ€§ä»£æ•°çš„å®˜æ–¹æ”¯æŒï¼Œå› æ­¤ï¼Œä¸ºäº†ç®€åŒ–çº¿æ€§ä»£æ•°è¿ç®—ï¼Œæˆ‘è¿™é‡Œç”¨äº†ä¸€ä¸ªç¬¬ä¸‰æ–¹åº“Armadilloã€‚åœ¨Ubuntuä¸‹ï¼Œå®ƒå¯ä»¥ä½¿ç”¨`apt-get install libarmadillo-dev`å®‰è£…æ”¯æŒã€‚

å¦å¤–ï¼Œè¿˜æ˜¯è¦å†ä¸‰è¯´æ˜ä¸€ä¸‹ï¼Œæˆ‘ä»¬ä»Šå¤©è¿™èŠ‚è¯¾çš„é‡ç‚¹å¹¶ä¸æ˜¯è®²è§£PCAç®—æ³•æœ¬èº«ï¼Œæ‰€ä»¥å¸Œæœ›ä½ ä¸è¦å›°äºæ­¤å¤„ï¼Œè€Œé”™è¿‡äº†çœŸæ­£çš„ä½¿ç”¨æ–¹æ³•ã€‚å½“ç„¶ï¼Œä¸ºäº†å®Œæ•´æ€§è€ƒè™‘ï¼Œæˆ‘è¿˜æ˜¯ä¼šå¯¹ä»£ç åšå‡ºæœ€åŸºæœ¬çš„è§£é‡Šã€‚

å°è£…æ­£å¼å¼€å§‹ã€‚æˆ‘ä»¬å…ˆæ¥ç¼–å†™ä¸€ä¸ªåä¸º`pca.h`çš„å¤´æ–‡ä»¶å®šä¹‰ï¼Œå†…å®¹æˆ‘æ”¾åœ¨äº†ä»£ç æ¸…å•5ä¸­ã€‚

ä»£ç æ¸…å•5ï¼Œ`pca.h`ï¼š

```
#pragma once

#include <vector>
#include <string>
#include <armadillo>

class pca {
public:
    pca();
    explicit pca(long num_vars);
    virtual ~pca();

    bool operator==(const pca& other);

    void set_num_variables(long num_vars);
    long get_num_variables() const;
    void add_record(const std::vector<double>& record);
    std::vector<double> get_record(long record_index) const;
    long get_num_records() const;
    void set_do_normalize(bool do_normalize);
    bool get_do_normalize() const;
    void set_solver(const std::string& solver);
    std::string get_solver() const;

    void solve();

    double check_eigenvectors_orthogonal() const;
    double check_projection_accurate() const;

    void save(const std::string& basename) const;
    void load(const std::string& basename);

    void set_num_retained(long num_retained);
    long get_num_retained() const;
    std::vector<double> to_principal_space(const std::vector<double>& record) const;
    std::vector<double> to_variable_space(const std::vector<double>& data) const;
    double get_energy() const;
    double get_eigenvalue(long eigen_index) const;
    std::vector<double> get_eigenvalues() const;
    std::vector<double> get_eigenvector(long eigen_index) const;
    std::vector<double> get_principal(long eigen_index) const;
    std::vector<double> get_mean_values() const;
    std::vector<double> get_sigma_values() const;

protected:
    long num_vars_;
    long num_records_;
    long record_buffer_;
    std::string solver_;
    bool do_normalize_;
    long num_retained_;
    arma::Mat<double> data_;
    arma::Col<double> energy_;
    arma::Col<double> eigval_;
    arma::Mat<double> eigvec_;
    arma::Mat<double> proj_eigvec_;
    arma::Mat<double> princomp_;
    arma::Col<double> mean_;
    arma::Col<double> sigma_;
    void initialize_();
    void assert_num_vars_();
    void resize_data_if_needed_();
};
```

æ¥ç€ï¼Œæˆ‘ä»¬å†æ¥ç¼–å†™å…·ä½“å®ç°`pca.cpp`ï¼Œä¹Ÿå°±æ˜¯ä»£ç æ¸…å•6çš„å†…å®¹ã€‚

ä»£ç æ¸…å•6ï¼Œ`pca.cpp`ï¼š

```
#include "pca.h"
#include "utils.h"
#include <stdexcept>
#include <random>

pca::pca()
    : num_vars_(0),
      num_records_(0),
      record_buffer_(1000),
      solver_("dc"),
      do_normalize_(false),
      num_retained_(1),
      energy_(1)
{}

pca::pca(long num_vars)
    : num_vars_(num_vars),
      num_records_(0),
      record_buffer_(1000),
      solver_("dc"),
      do_normalize_(false),
      num_retained_(num_vars_),
      data_(record_buffer_, num_vars_),
      energy_(1),
      eigval_(num_vars_),
      eigvec_(num_vars_, num_vars_),
      proj_eigvec_(num_vars_, num_vars_),
      princomp_(record_buffer_, num_vars_),
      mean_(num_vars_),
      sigma_(num_vars_)
{
    assert_num_vars_();
    initialize_();
}

pca::~pca()
{}

bool pca::operator==(const pca& other) {
    const double eps = 1e-5;
    if (num_vars_ == other.num_vars_ &&
        num_records_ == other.num_records_ &&
        record_buffer_ == other.record_buffer_ &&
        solver_ == other.solver_ &&
        do_normalize_ == other.do_normalize_ &&
        num_retained_ == other.num_retained_ &&
        utils::is_approx_equal_container(eigval_, other.eigval_, eps) &&
        utils::is_approx_equal_container(eigvec_, other.eigvec_, eps) &&
        utils::is_approx_equal_container(princomp_, other.princomp_, eps) &&
        utils::is_approx_equal_container(energy_, other.energy_, eps) &&
        utils::is_approx_equal_container(mean_, other.mean_, eps) &&
        utils::is_approx_equal_container(sigma_, other.sigma_, eps) &&
        utils::is_approx_equal_container(proj_eigvec_, other.proj_eigvec_, eps))
        return true;
    else
        return false;
}

void pca::resize_data_if_needed_() {
    if (num_records_ == record_buffer_) {
        record_buffer_ += record_buffer_;
        data_.resize(record_buffer_, num_vars_);
    }
}

void pca::assert_num_vars_() {
    if (num_vars_ < 2)
        throw std::invalid_argument("Number of variables smaller than two.");
}

void pca::initialize_() {
    data_.zeros();
    eigval_.zeros();
    eigvec_.zeros();
    princomp_.zeros();
    mean_.zeros();
    sigma_.zeros();
    energy_.zeros();
}

void pca::set_num_variables(long num_vars) {
    num_vars_ = num_vars;
    assert_num_vars_();
    num_retained_ = num_vars_;
    data_.resize(record_buffer_, num_vars_);
    eigval_.resize(num_vars_);
    eigvec_.resize(num_vars_, num_vars_);
    mean_.resize(num_vars_);
    sigma_.resize(num_vars_);
    initialize_();
}

void pca::add_record(const std::vector<double>& record) {
    assert_num_vars_();

    if (num_vars_ != long(record.size()))
        throw std::domain_error(utils::join("Record has the wrong size: ", record.size()));

    resize_data_if_needed_();
    arma::Row<double> row(&record.front(), record.size());
    data_.row(num_records_) = std::move(row);
    ++num_records_;
}

std::vector<double> pca::get_record(long record_index) const {
    return std::move(utils::extract_row_vector(data_, record_index));
}

void pca::set_do_normalize(bool do_normalize) {
    do_normalize_ = do_normalize;
}

void pca::set_solver(const std::string& solver) {
    if (solver!="standard" && solver!="dc")
        throw std::invalid_argument(utils::join("No such solver available: ", solver));
    solver_ = solver;
}

void pca::solve() {
    assert_num_vars_();

    if (num_records_ < 2)
        throw std::logic_error("Number of records smaller than two.");

    data_.resize(num_records_, num_vars_);

    mean_ = utils::compute_column_means(data_);
    utils::remove_column_means(data_, mean_);

    sigma_ = utils::compute_column_rms(data_);
    if (do_normalize_) utils::normalize_by_column(data_, sigma_);

    arma::Col<double> eigval(num_vars_);
    arma::Mat<double> eigvec(num_vars_, num_vars_);

    arma::Mat<double> cov_mat = utils::make_covariance_matrix(data_);
    arma::eig_sym(eigval, eigvec, cov_mat, solver_.c_str());
    arma::uvec indices = arma::sort_index(eigval, 1);

    for (long i=0; i<num_vars_; ++i) {
        eigval_(i) = eigval(indices(i));
        eigvec_.col(i) = eigvec.col(indices(i));
    }

    utils::enforce_positive_sign_by_column(eigvec_);
    proj_eigvec_ = eigvec_;

    princomp_ = data_ * eigvec_;

    energy_(0) = arma::sum(eigval_);
    eigval_ *= 1./energy_(0);
}

void pca::set_num_retained(long num_retained) {
    if (num_retained<=0 || num_retained>num_vars_)
        throw std::range_error(utils::join("Value out of range: ", num_retained));

    num_retained_ = num_retained;
    proj_eigvec_ = eigvec_.submat(0, 0, eigvec_.n_rows-1, num_retained_-1);
}

std::vector<double> pca::to_principal_space(const std::vector<double>& data) const {
    arma::Col<double> column(&data.front(), data.size());
    column -= mean_;
    if (do_normalize_) column /= sigma_;
    const arma::Row<double> row(column.t() * proj_eigvec_);
    return std::move(utils::extract_row_vector(row, 0));
}

std::vector<double> pca::to_variable_space(const std::vector<double>& data) const {
    const arma::Row<double> row(&data.front(), data.size());
    arma::Col<double> column(arma::trans(row * proj_eigvec_.t()));
    if (do_normalize_) column %= sigma_;
    column += mean_;
    return std::move(utils::extract_column_vector(column, 0));
}

double pca::get_energy() const {
    return energy_(0);
}

double pca::get_eigenvalue(long eigen_index) const {
    if (eigen_index >= num_vars_)
        throw std::range_error(utils::join("Index out of range: ", eigen_index));
    return eigval_(eigen_index);
}

std::vector<double> pca::get_eigenvalues() const {
    return std::move(utils::extract_column_vector(eigval_, 0));
}

std::vector<double> pca::get_eigenvector(long eigen_index) const {
    return std::move(utils::extract_column_vector(eigvec_, eigen_index));
}

std::vector<double> pca::get_principal(long eigen_index) const {
    return std::move(utils::extract_column_vector(princomp_, eigen_index));
}

double pca::check_eigenvectors_orthogonal() const {
    return std::abs(arma::det(eigvec_));
}

double pca::check_projection_accurate() const {
    if (data_.n_cols!=eigvec_.n_cols || data_.n_rows!=princomp_.n_rows)
        throw std::runtime_error("No proper data matrix present that the projection could be compared with.");
    const arma::Mat<double> diff = (princomp_ * arma::trans(eigvec_)) - data_;
    return 1 - arma::sum(arma::sum( arma::abs(diff) )) / diff.n_elem;
}

bool pca::get_do_normalize() const {
    return do_normalize_;
}

std::string pca::get_solver() const {
    return solver_;
}

std::vector<double> pca::get_mean_values() const {
    return std::move(utils::extract_column_vector(mean_, 0));
}

std::vector<double> pca::get_sigma_values() const {
    return std::move(utils::extract_column_vector(sigma_, 0));
}

long pca::get_num_variables() const {
    return num_vars_;
}

long pca::get_num_records() const {
    return num_records_;
}

long pca::get_num_retained() const {
    return num_retained_;
}

void pca::save(const std::string& basename) const {
    const std::string filename = basename + ".pca";
    std::ofstream file(filename.c_str());
    utils::assert_file_good(file.good(), filename);
    utils::write_property(file, "num_variables", num_vars_);
    utils::write_property(file, "num_records", num_records_);
    utils::write_property(file, "solver", solver_);
    utils::write_property(file, "num_retained", num_retained_);
    utils::write_property(file, "do_normalize", do_normalize_);
    file.close();

    utils::write_matrix_object(basename + ".eigval", eigval_);
    utils::write_matrix_object(basename + ".eigvec", eigvec_);
    utils::write_matrix_object(basename + ".princomp", princomp_);
    utils::write_matrix_object(basename + ".energy", energy_);
    utils::write_matrix_object(basename + ".mean", mean_);
    utils::write_matrix_object(basename + ".sigma", sigma_);
}

void pca::load(const std::string& basename) {
    const std::string filename = basename + ".pca";
    std::ifstream file(filename.c_str());
    utils::assert_file_good(file.good(), filename);
    utils::read_property(file, "num_variables", num_vars_);
    utils::read_property(file, "num_records", num_records_);
    utils::read_property(file, "solver", solver_);
    utils::read_property(file, "num_retained", num_retained_);
    utils::read_property(file, "do_normalize", do_normalize_);
    file.close();

    utils::read_matrix_object(basename + ".eigval", eigval_);
    utils::read_matrix_object(basename + ".eigvec", eigvec_);
    utils::read_matrix_object(basename + ".princomp", princomp_);
    utils::read_matrix_object(basename + ".energy", energy_);
    utils::read_matrix_object(basename + ".mean", mean_);
    utils::read_matrix_object(basename + ".sigma", sigma_);

    set_num_retained(num_retained_);
}
```

è¿™é‡Œè¦æ³¨æ„äº†ï¼Œä»£ç æ¸…å•6ä¸­ç”¨åˆ°äº†`utils.h`è¿™ä¸ªæ–‡ä»¶ï¼Œå®ƒæ˜¯å¯¹éƒ¨åˆ†çŸ©é˜µå’Œæ•°å­¦è®¡ç®—çš„å°è£…ï¼Œå†…å®¹æˆ‘æ”¾åœ¨äº†ä»£ç æ¸…å•7ä¸­ã€‚

ä»£ç æ¸…å•7ï¼Œ`utils.h`ï¼š

```
#pragma once
 
#include <armadillo>
#include <sstream>

namespace utils {
arma::Mat<double> make_covariance_matrix(const arma::Mat<double>& data);
arma::Mat<double> make_shuffled_matrix(const arma::Mat<double>& data);
arma::Col<double> compute_column_means(const arma::Mat<double>& data);
void remove_column_means(arma::Mat<double>& data, const arma::Col<double>& means);
arma::Col<double> compute_column_rms(const arma::Mat<double>& data);
void normalize_by_column(arma::Mat<double>& data, const arma::Col<double>& rms);
void enforce_positive_sign_by_column(arma::Mat<double>& data);
std::vector<double> extract_column_vector(const arma::Mat<double>& data, long index);
std::vector<double> extract_row_vector(const arma::Mat<double>& data, long index);
void assert_file_good(const bool& is_file_good, const std::string& filename);
template<typename T>
void write_matrix_object(const std::string& filename, const T& matrix) {
    assert_file_good(matrix.quiet_save(filename, arma::arma_ascii), filename);
}

template<typename T>
void read_matrix_object(const std::string& filename, T& matrix) {
    assert_file_good(matrix.quiet_load(filename), filename);
}
template<typename T, typename U, typename V>
bool is_approx_equal(const T& value1, const U& value2, const V& eps) {
    return std::abs(value1-value2)<eps ? true : false;
}
template<typename T, typename U, typename V>
bool is_approx_equal_container(const T& container1, const U& container2, const V& eps) {
    if (container1.size()==container2.size()) {
        bool equal = true;
        for (size_t i=0; i<container1.size(); ++i) {
            equal = is_approx_equal(container1[i], container2[i], eps);
            if (!equal) break;
        }
        return equal;
    } else {
        return false;
    }
}
double get_mean(const std::vector<double>& iter);
double get_sigma(const std::vector<double>& iter);

struct join_helper {
    static void add_to_stream(std::ostream& stream) {}

    template<typename T, typename... Args>
    static void add_to_stream(std::ostream& stream, const T& arg, const Args&... args) {
        stream << arg;
        add_to_stream(stream, args...);
    }
};

template<typename T, typename... Args>
std::string join(const T& arg, const Args&... args) {
    std::ostringstream stream;
    stream << arg;
    join_helper::add_to_stream(stream, args...);
    return stream.str();
}

template<typename T>
void write_property(std::ostream& file, const std::string& key, const T& value) {
    file << key << "\t" << value << std::endl;
}

template<typename T>
void read_property(std::istream& file, const std::string& key, T& value) {
    std::string tmp;
    bool found = false;
    while (file.good()) {
        file >> tmp;
        if (tmp==key) {
            file >> value;
            found = true;
            break;
        }
    }
    if (!found)
        throw std::domain_error(join("No such key available: ", key));
    file.seekg(0);
}

} //utils
```

è‡³äºå…·ä½“çš„å®ç°ä»£ç ï¼Œæˆ‘æ”¾åœ¨äº†åœ¨ä»£ç æ¸…å•8`utils.cpp`ä¸­ã€‚

ä»£ç æ¸…å•8ï¼Œ`utils.cpp`ï¼š

```
#include "utils.h"
#include <stdexcept>
#include <sstream>
#include <numeric>

namespace utils {

arma::Mat<double> make_covariance_matrix(const arma::Mat<double>& data) {
    return std::move( (data.t()*data) * (1./(data.n_rows-1)) );
}

arma::Mat<double> make_shuffled_matrix(const arma::Mat<double>& data) {
    const long n_rows = data.n_rows;
    const long n_cols = data.n_cols;
    arma::Mat<double> shuffle(n_rows, n_cols);
    for (long j=0; j<n_cols; ++j) {
        for (long i=0; i<n_rows; ++i) {
            shuffle(i, j) = data(std::rand()%n_rows, j);
        }
    }
    return std::move(shuffle);
}

arma::Col<double> compute_column_means(const arma::Mat<double>& data) {
    const long n_cols = data.n_cols;
    arma::Col<double> means(n_cols);
    for (long i=0; i<n_cols; ++i)
        means(i) = arma::mean(data.col(i));
    return std::move(means);
}

void remove_column_means(arma::Mat<double>& data, const arma::Col<double>& means) {
    if (data.n_cols != means.n_elem)
        throw std::range_error("Number of elements of means is not equal to the number of columns of data");
    for (long i=0; i<long(data.n_cols); ++i)
        data.col(i) -= means(i);
}

arma::Col<double> compute_column_rms(const arma::Mat<double>& data) {
    const long n_cols = data.n_cols;
    arma::Col<double> rms(n_cols);
    for (long i=0; i<n_cols; ++i) {
        const double dot = arma::dot(data.col(i), data.col(i));
        rms(i) = std::sqrt(dot / (data.col(i).n_rows-1));
    }
    return std::move(rms);
}

void normalize_by_column(arma::Mat<double>& data, const arma::Col<double>& rms) {
    if (data.n_cols != rms.n_elem)
        throw std::range_error("Number of elements of rms is not equal to the number of columns of data");
    for (long i=0; i<long(data.n_cols); ++i) {
        if (rms(i)==0)
            throw std::runtime_error("At least one of the entries of rms equals to zero");
        data.col(i) *= 1./rms(i);
    }
}

void enforce_positive_sign_by_column(arma::Mat<double>& data) {
    for (long i=0; i<long(data.n_cols); ++i) {
        const double max = arma::max(data.col(i));
        const double min = arma::min(data.col(i));
        bool change_sign = false;
        if (std::abs(max)>=std::abs(min)) {
            if (max<0) change_sign = true;
        } else {
            if (min<0) change_sign = true;
        }
        if (change_sign) data.col(i) *= -1;
    }
}

std::vector<double> extract_column_vector(const arma::Mat<double>& data, long index) {
    if (index<0 || index >= long(data.n_cols))
        throw std::range_error(join("Index out of range: ", index));
    const long n_rows = data.n_rows;
    const double* memptr = data.colptr(index);
    std::vector<double> result(memptr, memptr + n_rows);
    return std::move(result);
}

std::vector<double> extract_row_vector(const arma::Mat<double>& data, long index) {
    if (index<0 || index >= long(data.n_rows))
        throw std::range_error(join("Index out of range: ", index));
    const arma::Row<double> row(data.row(index));
    const double* memptr = row.memptr();
    std::vector<double> result(memptr, memptr + row.n_elem);
    return std::move(result);
}

void assert_file_good(const bool& is_file_good, const std::string& filename) {
    if (!is_file_good)
        throw std::ios_base::failure(join("Cannot open file: ", filename));
}

double get_mean(const std::vector<double>& iter) {
    const double init = 0;
    return std::accumulate(iter.begin(), iter.end(), init) / iter.size();
}

double get_sigma(const std::vector<double>& iter) {
    const double mean = get_mean(iter);
    double sum = 0;
    for (auto v=iter.begin(); v!=iter.end(); ++v)
        sum += std::pow(*v - mean, 2.);
    return std::sqrt(sum/(iter.size()-1));
}

} //utils
```

æœ€åï¼Œæˆ‘ä»¬æ¥ç¼–å†™`pca.i`æ¥å£æ–‡ä»¶ï¼Œä¹Ÿå°±æ˜¯ä»£ç æ¸…å•9çš„å†…å®¹ã€‚

ä»£ç æ¸…å•9ï¼Œ`pca.i`ï¼š

```
%module pca

%include "std_string.i"
%include "std_vector.i"

namespace std {
  %template(DoubleVector) vector<double>;
}

%{
#include "pca.h"
#include "utils.h"
%}

%include "pca.h"
%include "utils.h"
```

è¿™é‡Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œæˆ‘ä»¬åœ¨C++ä»£ç ä¸­ä½¿ç”¨äº†ç†Ÿæ‚‰çš„é¡ºåºå®¹å™¨`std::vector`ï¼Œä½†ç”±äºæ¨¡æ¿ç±»æ¯”è¾ƒç‰¹æ®Šï¼Œæˆ‘ä»¬éœ€è¦ç”¨`%template`å£°æ˜ä¸€ä¸‹ã€‚

ä¸€åˆ‡å°±ç»ªåï¼Œæˆ‘ä»¬æ‰§è¡Œä¸‹é¢çš„å‘½ä»¤è¡Œï¼Œç”Ÿæˆ`_pca.so`åº“ä¾›Pythonä½¿ç”¨ï¼š

```
$ swig -c++ -python pca.i # è§£é‡Šæ¥å£å®šä¹‰ç”ŸæˆåŒ…SWIGè£…å™¨ä»£ç 
$ g++ -fPIC -c pca.h pca.cpp utils.h utils.cpp pca_wrap.cxx -I/usr/include/python3.7 # ç¼–è¯‘æºä»£ç 
$ g++ -shared pca.o pca_wrap.o utils.o -o _pca.so -O2 -Wall -std=c++11 -pthread -shared -fPIC -larmadillo # é“¾æ¥
```

æ¥ç€ï¼Œæˆ‘ä»¬ä½¿ç”¨Pythonè„šæœ¬ï¼Œå¯¼å…¥æˆ‘ä»¬åˆ›å»ºå¥½çš„soåŠ¨æ€åº“ï¼›ç„¶åï¼Œè°ƒç”¨ç›¸åº”çš„ç±»çš„å‡½æ•°ã€‚è¿™éƒ¨åˆ†å†…å®¹ï¼Œæˆ‘å†™åœ¨äº†ä»£ç æ¸…å•10ä¸­ã€‚

ä»£ç æ¸…å•10ï¼Œ`testPCA.py`ï¼š

```
import pca

pca_inst = pca.pca(2)
pca_inst.add_record([1.0, 1.0])
pca_inst.add_record([2.0, 2.0])
pca_inst.add_record([4.0, 1.0])

pca_inst.solve()

energy = pca_inst.get_energy()
eigenvalues = pca_inst.get_eigenvalues()

print(energy)
print(eigenvalues)
```

æœ€åï¼Œæˆ‘ä»¬åˆ†åˆ«å¯¹çº¯Pythonå®ç°çš„ä»£ç ï¼Œå’Œä½¿ç”¨SWIGå°è£…çš„ç‰ˆæœ¬æ¥è¿›è¡Œæµ‹è¯•ï¼Œå„è‡ªéƒ½æ‰§è¡Œ1,000,000æ¬¡ï¼Œç„¶åå¯¹æ¯”æ‰§è¡Œæ—¶é—´ã€‚æˆ‘ç”¨ä¸€å¼ å›¾è¡¨ç¤ºäº†æˆ‘çš„æœºå™¨ä¸Šå¾—åˆ°çš„ç»“æœï¼Œä½ å¯ä»¥å¯¹æ¯”çœ‹çœ‹ã€‚

![](https://static001.geekbang.org/resource/image/d4/e2/d4729298aa565d7216720f9d5ededde2.png?wh=665%2A493)

è™½ç„¶è¿™æ ·ç²—ç•¥çš„æ¯”è¾ƒå¹¶ä¸å¤Ÿä¸¥è°¨ï¼Œæ¯”å¦‚æˆ‘ä»¬æ²¡æœ‰è®¤çœŸè€ƒè™‘SWIGæ¥å£ç±»å‹è½¬æ¢çš„è€—æ—¶ï¼Œä¹Ÿæ²¡æœ‰è€ƒè™‘åœ¨ä¸åŒç¼–ç¨‹è¯­è¨€ä¸‹å®ç°ç®—æ³•çš„é€»è¾‘ç­‰ç­‰ã€‚ä½†æ˜¯ï¼Œé€šè¿‡è¿™ä¸ªç²—ç•¥çš„ç»“æœï¼Œä½ ä»ç„¶å¯ä»¥çœ‹å‡ºæ‰§è¡Œç±»ä¼¼è¿ç®—æ—¶ï¼Œä¸¤è€…æ€§èƒ½çš„å·¨å¤§å·®å¼‚ã€‚

## SWIG C++å¸¸ç”¨å·¥å…·

åˆ°è¿™é‡Œï¼Œä½ åº”è¯¥å·²ç»å¯ä»¥å¼€å§‹åŠ¨æ‰‹æ“ä½œäº†ï¼ŒæŠŠä¸Šé¢çš„ä»£ç æ¸…å•å½“ä½œä½ çš„å·¥å…·è¿›è¡Œå®è·µã€‚ä¸è¿‡ï¼ŒSWIGæœ¬èº«éå¸¸ä¸°å¯Œï¼Œæ‰€ä»¥è¿™é‡Œæˆ‘ä¹Ÿå†ç»™ä½ æ€»ç»“ä»‹ç»å‡ ä¸ªå¸¸ç”¨çš„å·¥å…·ã€‚

### **1.å…¨å±€å˜é‡**

åœ¨Python ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡cvarï¼Œæ¥è®¿é—®C++ä»£ç ä¸­å®šä¹‰çš„å…¨å±€å˜é‡ã€‚

æ¯”å¦‚è¯´ï¼Œæˆ‘ä»¬åœ¨å¤´æ–‡ä»¶ `sample.h`ä¸­å®šä¹‰äº†ä¸€ä¸ªå…¨å±€å˜é‡ï¼Œå¹¶åœ¨`sample.i`ä¸­å¯¹å…¶è¿›è¡Œå¼•ç”¨ï¼Œä¹Ÿå°±æ˜¯ä»£ç æ¸…å• 11å’Œ12çš„å†…å®¹ã€‚

ä»£ç æ¸…å•11ï¼Œ`sample.h`ï¼š

```
#include <cstdint>
int32_t score = 100;
```

ä»£ç æ¸…å•12ï¼Œ`sample.i`ï¼š

```
%module sample
%{
#include "sample.h"
%}

%include "sample.h"
```

è¿™æ ·ï¼Œæˆ‘ä»¬å°±å¯ä»¥ç›´æ¥åœ¨Pythonè„šæœ¬ä¸­ï¼Œé€šè¿‡cvaræ¥è®¿é—®å¯¹åº”çš„å…¨å±€å˜é‡ï¼Œå¦‚ä»£ç æ¸…å•13æ‰€ç¤ºï¼Œè¾“å‡ºç»“æœä¸º100ã€‚

ä»£ç æ¸…å•13ï¼Œ`sample.py`ï¼š

```
import sample
print sample.cvar.score
```

### **2.å¸¸é‡**

æˆ‘ä»¬å¯ä»¥åœ¨æ¥å£å®šä¹‰æ–‡ä»¶ä¸­ï¼Œä½¿ç”¨ `%constant`æ¥è®¾å®šå¸¸é‡ï¼Œå¦‚ä»£ç æ¸…å•14æ‰€ç¤ºã€‚

ä»£ç æ¸…å•14ï¼Œ`sample.i`ï¼š

```
%constant int foo = 100;
%constant const char* bar = "foobar2000";
```

### **3.Enumeration**

æˆ‘ä»¬å¯ä»¥åœ¨æ¥å£æ–‡ä»¶ä¸­ï¼Œä½¿ç”¨enumå…³é”®å­—æ¥å®šä¹‰enumã€‚

### **4.æŒ‡é’ˆå’Œå¼•ç”¨**

åœ¨C++ä¸–ç•Œä¸­ï¼ŒæŒ‡é’ˆæ˜¯æ°¸è¿œä¹Ÿç»•ä¸å¼€çš„ä¸€ä¸ªæ¦‚å¿µã€‚å®ƒæ— å¤„ä¸åœ¨ï¼Œæˆ‘ä»¬ä¹Ÿæ— æ—¶æ— åˆ»ä¸éœ€è¦ä½¿ç”¨å®ƒã€‚å› æ­¤ï¼Œåœ¨è¿™é‡Œï¼Œæˆ‘è®¤ä¸ºå¾ˆæœ‰å¿…è¦ä»‹ç»ä¸€ä¸‹ï¼Œå¦‚ä½•å¯¹C++ä¸­çš„æŒ‡é’ˆå’Œå¼•ç”¨è¿›è¡Œæ“ä½œã€‚

SWIGå¯¹æŒ‡é’ˆæœ‰ç€è¾ƒä¸ºä¸é”™çš„æ”¯æŒï¼Œå¯¹æ™ºèƒ½æŒ‡é’ˆä¹Ÿæœ‰ä¸€å®šçš„æ”¯æŒï¼Œè€Œä¸”åœ¨è¿‘æœŸçš„æ›´æ–°æ—¥å¿—ä¸­ï¼Œæˆ‘å‘ç°å®ƒå¯¹æ™ºèƒ½æŒ‡é’ˆçš„æ”¯æŒä¸€ç›´åœ¨æ›´æ–°ã€‚ä¸‹é¢çš„ä»£ç æ¸…å•15å’Œ16ï¼Œå°±å±•ç¤ºäº†é’ˆå¯¹æŒ‡é’ˆå’Œå¼•ç”¨çš„ä½¿ç”¨æ–¹æ³•ã€‚

ä»£ç æ¸…å•15ï¼Œ`sample.h`ï¼š

```
#include <cstdint>

void passPointer(ClassA* ptr) {
   printf("result= %d", ptr->result);
}

void passReference(const ClassA& ref) {
   printf("result= %d", ref.result);
}

void passValue(ClassA obj) {
   printf("result= %d", obj.result);
}
```

ä»£ç æ¸…å•16ï¼Œ`sample.py`ï¼š

```
import sample

a = ClassA() # åˆ›å»º ClassAå®ä¾‹
passPointer(a)
passReference(a)
passValue(a)
```

### **5.å­—ç¬¦ä¸²**

æˆ‘ä»¬åœ¨å·¥ä¸šçº§ä»£ç ä¸­ï¼Œæ—¶å¸¸ä½¿ç”¨`std::string`ã€‚è€Œåœ¨SWIGçš„ç¯å¢ƒä¸‹ï¼Œä½¿ç”¨æ ‡å‡†åº“ä¸­çš„å­—ç¬¦ä¸²ï¼Œéœ€è¦ä½ åœ¨æ¥å£æ–‡ä»¶ä¸­å£°æ˜`%include â€œstd_stirng.iâ€`ï¼Œæ¥ç¡®ä¿å®ç°C++ `std::string`åˆ°Python `str`çš„è‡ªåŠ¨è½¬æ¢ã€‚å…·ä½“å†…å®¹æˆ‘æ”¾åœ¨äº†ä»£ç æ¸…å•17ä¸­ã€‚

ä»£ç æ¸…å•17ï¼Œ`sample.i`ï¼š

```
%module sample

%include "std_string.i"

```

### **6.å‘é‡**

`std::vector`æ˜¯STLä¸­æœ€å¸¸è§ä¹Ÿæ˜¯ä½¿ç”¨æœ€é¢‘ç¹çš„é¡ºåºå®¹å™¨ï¼Œæ¨¡æ¿ç±»æ¯”è¾ƒç‰¹æ®Šï¼Œå› æ­¤ï¼Œå®ƒçš„ä½¿ç”¨ä¹Ÿæ¯”å­—ç¬¦ä¸²ç¨å¾®å¤æ‚ä¸€äº›ï¼Œéœ€è¦ä½¿ç”¨`%template`è¿›è¡Œå£°æ˜ã€‚è¯¦ç»†å†…å®¹æˆ‘æ”¾åœ¨äº†ä»£ç æ¸…å•18ä¸­ã€‚

ä»£ç æ¸…å•18ï¼Œ`sample.i`ï¼š

```
%module sample

%include "std_string.i"
%include "std_vector.i"

namespace std {
 %template(DoubleVector) vector<double>;
}

```

### **7. æ˜ å°„**

`std::map` åŒæ ·æ˜¯STLä¸­æœ€å¸¸è§ä¹Ÿæ˜¯ä½¿ç”¨æœ€é¢‘ç¹çš„å®¹å™¨ã€‚åŒæ ·çš„ï¼Œå®ƒçš„æ¨¡æ¿ç±»ä¹Ÿæ¯”è¾ƒç‰¹æ®Šï¼Œéœ€è¦ä½¿ç”¨`%template`è¿›è¡Œå£°æ˜ï¼Œè¯¦ç»†å†…å®¹å¯è§ä»£ç æ¸…å•19ã€‚

ä»£ç æ¸…å•19ï¼Œ`sample.i`ï¼š

```
%module sample

%include "std_string.i"
%include "std_map.i"

namespace std {
 %template(Int2strMap) map<int, string>;
 %template(Str2intMap) map<string, int>;
}

```

## å­¦ä¹ è·¯å¾„

åˆ°æ­¤ï¼ŒSWIGå…¥é—¨è¿™ä¸ªå°ç›®æ ‡ï¼Œæˆ‘ä»¬å°±å·²ç»å®ç°äº†ã€‚ä»Šå¤©å†…å®¹å¯ä»¥å½“ä½œä¸€ä»½SWIGçš„ç¼–ç¨‹å®è·µæŒ‡å—ï¼Œæˆ‘ç»™ä½ æä¾›äº†19ä¸ªä»£ç æ¸…å•ï¼Œåˆ©ç”¨å®ƒä»¬ï¼Œä½ å°±å¯ä»¥ä¸Šæ‰‹æ“ä½œäº†ã€‚å½“ç„¶ï¼Œå¦‚æœåœ¨è¿™æ–¹é¢ä½ è¿˜æƒ³ç»§ç»­ç²¾è¿›ï¼Œè¯¥æ€ä¹ˆåŠå‘¢ï¼Ÿåˆ«ç€æ€¥ï¼Œä»Šå¤©è¿™èŠ‚è¯¾çš„æœ€åï¼Œæˆ‘å†å’Œä½ åˆ†äº«ä¸‹ï¼Œæˆ‘è§‰å¾—æ¯”è¾ƒé«˜æ•ˆçš„ä¸€æ¡SWIGå­¦ä¹ è·¯å¾„ã€‚

é¦–å…ˆï¼Œä»»ä½•æŠ€æœ¯çš„å­¦ä¹ ä¸è¦è„±ç¦»å®˜æ–¹æ–‡æ¡£ã€‚SWIGç½‘ç«™ä¸Šæä¾›äº†éš¾ä»¥ç½®ä¿¡çš„è¯¦å°½æ–‡æ¡£ï¼Œé€šè¿‡æ–‡æ¡£æŒæ¡SWIGçš„ç”¨æ³•ï¼Œæ˜¾ç„¶æ˜¯æœ€å¥½çš„ä¸€ä¸ªé€”å¾„ã€‚

å…¶æ¬¡ï¼Œè¦æ·±å…¥SWIGï¼Œå¯¹C++æœ‰ä¸€ä¸ªè¾ƒä¸ºå…¨é¢çš„æŒæ¡ï¼Œå°±æ˜¾å¾—è‡³å…³é‡è¦äº†ã€‚å¯¹äºé«˜æ€§èƒ½è®¡ç®—æ¥è¯´ï¼ŒC++æ€»æ˜¯ç»•ä¸å¼€çš„ä¸€ä¸ªä¸»é¢˜ï¼Œç‰¹åˆ«æ˜¯å¯¹å†…å­˜ç®¡ç†ã€æŒ‡é’ˆå’Œè™šå‡½æ•°çš„åº”ç”¨ï¼Œéœ€è¦ä½ å®é™…ä¸Šæ‰‹ç¼–å†™C++ä»£ç åï¼Œæ‰èƒ½é€æ¸æŒæ¡ã€‚é€€ä¸€æ­¥è®²ï¼Œå³ä¾¿ä½ åªæ˜¯ä¸ºäº†å°è£…å…¶ä»–C++åº“ä¾›Pythonè°ƒç”¨ï¼Œä¹Ÿéœ€è¦å¯¹C++æœ‰ä¸€ä¸ªåŸºæœ¬äº†è§£ï¼Œä»¥ä¾¿æœªæ¥é‡åˆ°ç¼–è¯‘æˆ–é“¾æ¥é”™è¯¯æ—¶ï¼Œå¯ä»¥æ‰¾åˆ°æ–¹å‘æ¥è§£å†³é—®é¢˜ã€‚

æœ€åï¼Œæˆ‘å†ç½—åˆ—ä¸€äº›å­¦ä¹ ç´ æï¼Œä¾›ä½ è¿›ä¸€æ­¥å­¦ä¹ å‚è€ƒã€‚

ç¬¬ä¸€ä¾¿æ˜¯SWIGæ–‡æ¡£ã€‚

- a. [http://www.swig.org/doc.html](http://www.swig.org/doc.html)
- b. [http://www.swig.org/Doc4.0/SWIGPlus.html](http://www.swig.org/Doc4.0/SWIGPlus.html)
- c. PDFç‰ˆæœ¬ï¼š[http://www.swig.org/Doc4.0/SWIGDocumentation.pdf](http://www.swig.org/Doc4.0/SWIGDocumentation.pdf)

ç¬¬äºŒæ˜¯ã€ŠC++ Primerã€‹è¿™æœ¬ä¹¦ã€‚ä½œä¸ºC++é¢†åŸŸçš„ç»å…¸ä¹¦ç±ï¼Œè¿™æœ¬ä¹¦å¯¹ä½ å…¨é¢äº†è§£C++æœ‰æå¤§å¸®åŠ©ã€‚

ç¬¬ä¸‰åˆ™æ˜¯ã€Šé«˜çº§C/C++ç¼–è¯‘æŠ€æœ¯ã€‹è¿™æœ¬ä¹¦ã€‚è¿™æœ¬ä¹¦çš„å†…å®¹æ›´ä¸ºè¿›é˜¶ï¼Œä½ å¯ä»¥æŠŠå®ƒä½œä¸ºå­¦ä¹ C++çš„æé«˜å’Œäº†è§£ã€‚

å¥½äº†ï¼Œä»Šå¤©çš„å†…å®¹å°±åˆ°æ­¤ç»“æŸäº†ã€‚å…³äºSWIGï¼Œä½ æœ‰å“ªäº›æ”¶è·ï¼Œæˆ–è€…è¿˜æœ‰å“ªäº›é—®é¢˜ï¼Œéƒ½æ¬¢è¿ä½ ç•™è¨€å’Œæˆ‘åˆ†äº«è®¨è®ºã€‚ä¹Ÿæ¬¢è¿ä½ æŠŠè¿™ç¯‡æ–‡ç« åˆ†äº«ç»™ä½ çš„åŒäº‹ã€æœ‹å‹ï¼Œæˆ‘ä»¬ä¸€èµ·å­¦ä¹ å’Œè¿›æ­¥ã€‚
<div><strong>ç²¾é€‰ç•™è¨€ï¼ˆ9ï¼‰</strong></div><ul>
<li><span>gutentag</span> ğŸ‘ï¼ˆ10ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>å¯¹äºå•æ–‡ä»¶è€Œè¨€ï¼Œç”¨SWIGè¿˜æ˜¯boost.python&#47;py++æ„Ÿè§‰éƒ½å¥½ç†è§£å’Œå®è·µï¼Œè¯·é—®å¯¹äºä¾èµ–å…³ç³»å¤æ‚çš„å¤§å‹C++é¡¹ç›®ï¼ˆæ¯”å¦‚OpenCV, OpenSceneGraphä¹‹ç±»çš„ï¼‰çš„python bindingæœ‰æ²¡æœ‰æ¯”è¾ƒå®Œæ•´çš„æœ€ä½³å®è·µå‘¢ï¼Ÿ
C++ç¼–è¯‘çš„åŠ¨æ€åº“pythonæ— æ³•ç›´æ¥è°ƒç”¨ï¼ŒC++é¡¹ç›®çš„python bindingæœ¬èº«ç­‰ä»·äºæŠŠæœ¬èº«ç¼–è¯‘æ—¶ç”¨åˆ°çš„æ‰€æœ‰çš„å¤´æ–‡ä»¶ä¸­éœ€è¦æš´éœ²çš„æ¥å£éƒ½externæˆCçš„å‘¢ï¼Ÿå¯¹äºå¤´æ–‡ä»¶çš„ç›¸äº’å„ç§includeä¸€èˆ¬æ˜¯äººå·¥å¤„ç†è¿˜æ˜¯SWIGæœ¬èº«å¯ä»¥è§£å†³å‘¢ï¼Ÿé™¤äº†å¤´æ–‡ä»¶æš´éœ²ä»¥å¤–ï¼Œè¿˜æœ‰åˆ«çš„å·¥ä½œå—ï¼Ÿ
ä»»ä½•Cé¡¹ç›®ç›´æ¥ç”Ÿæˆçš„åŠ¨æ€é“¾æ¥åº“pythonéƒ½èƒ½ç›´æ¥importå—ï¼Ÿè¯·é—®æœ‰ä¾‹å¤–å—ï¼Ÿ
è°¢è°¢</p>2019-08-16</li><br/><li><span>è®¸ç«¥ç«¥</span> ğŸ‘ï¼ˆ6ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>æå®¢æ—¶é—´çš„C++è¯¾ç¨‹å¿«æ¥äº†ï¼ŒæœŸå¾…ä¸€ä¸‹ï¼Œè¡¥ä¸€è¡¥æˆ‘çš„C++ã€‚</p>2019-08-16</li><br/><li><span>å®‰æ’</span> ğŸ‘ï¼ˆ5ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>ç±»ä¼¼äºjniå•Š</p>2019-08-16</li><br/><li><span>Ethan</span> ğŸ‘ï¼ˆ4ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>c++å¤§æ³•</p>2019-08-16</li><br/><li><span>Felix</span> ğŸ‘ï¼ˆ2ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>è€å¸ˆï¼Œå®é™…ä½¿ç”¨ä¸­é‡åˆ°ä¸ªé—®é¢˜ï¼Œæƒ³è¯·æ•™ä¸‹æ‚¨ï¼š
å‡å¦‚æœ‰è¿™ä¹ˆä¸€ä¸ªC++å‡½æ•°ï¼šErrCode GetTpError(std::string&amp; errMsg);
ç”¨äºè·å–é”™è¯¯ä¿¡æ¯ï¼Œæƒ³è¦åœ¨pythonä¸­è°ƒç”¨ï¼Œåˆ©ç”¨swigç¼–è¯‘OKï¼Œä½†è°ƒç”¨åæ²¡æœ‰å¾—åˆ° errMsgå­—ç¬¦ä¸²ï¼ŒåŸå› æ˜¯pythonçš„å­—ç¬¦ä¸²ç±»å‹æ˜¯immutableï¼Œä¸çŸ¥é“æˆ‘è¿™æ ·ç†è§£å¯¹å—ï¼Ÿè¿˜æœ‰è¿™ä¸ªå‡½æ•°è¦æ€ä¹ˆè½¬æ¢ï¼Œæ‰èƒ½åœ¨pythonä¸­è°ƒç”¨å‘¢ï¼Ÿ</p>2020-03-17</li><br/><li><span>-.----..</span> ğŸ‘ï¼ˆ2ï¼‰ ğŸ’¬ï¼ˆ1ï¼‰<p>
æ„Ÿè§‰SWIGæ›´çµæ´»ï¼Œæ¯”ctypeså’Œpy4jæ›´æ–¹ä¾¿ï¼Œä½†æ˜¯Pythonè°ƒç”¨.soæ–‡ä»¶å¥½åƒå¾ˆæŒ‘gccç‰ˆæœ¬ï¼Œä¸åŒç‰ˆæœ¬gccç¼–è¯‘çš„.soæ–‡ä»¶ï¼ŒPythonè°ƒç”¨æ—¶æœ‰æ—¶å€™ä¼šæŠ¥</p>2019-08-20</li><br/><li><span>å¥½å¥½å…ˆç”Ÿ</span> ğŸ‘ï¼ˆ1ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>åŠ æ²¹ï¼</p>2020-03-29</li><br/><li><span>æ ¾~é¾Ÿè™½å¯¿ï¼</span> ğŸ‘ï¼ˆ1ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>å¦‚ä½•çœ‹pythonæºä»£ç ï¼Œæ¯”å¦‚list.sortçš„å®ç°</p>2019-08-18</li><br/><li><span>å®‰è¿ªå¯†æ©</span> ğŸ‘ï¼ˆ0ï¼‰ ğŸ’¬ï¼ˆ0ï¼‰<p>è¿™ä»½åŠ é¤æœ‰ç‚¹çªå…€ï¼Œæ˜¯ä¸ºä»€ä¹ˆå‘¢ï¼Ÿ</p>2024-07-04</li><br/>
</ul>