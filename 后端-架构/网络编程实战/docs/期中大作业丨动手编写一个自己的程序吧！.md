你好，我们之前已经学习了网络编程的基础篇和提高篇。经过近两个月的学习，不知道你对这些内容的掌握程度如何呢？

我之前说过，网络编程是一个既重视理论，又重视实战的内容模块。一味地消化理论并不足以让你掌握网络编程，只有自己亲自动手写代码，编写程序，才能对TCP、UDP、套接字这些内容有更深切的体会，才能切实感受到它们是如何帮助我们的程序进行互联互通的。

网络编程就像一个魔法棒，我们之前已经学习了一些“咒语”，但上手操纵才能真实地施展魔法。所以我在专栏中安排了一个期中作业，借由这个作业让你上手编写代码，相信你在这个过程中也会更有成就感。

我在这里再提供一些“咒语”提示，方便你回顾之前的内容，以便在解题的时候更加胸有成竹。

客户端程序可以以[第11篇文章](https://time.geekbang.org/column/article/126126)的程序例子为原型，这里主要考察使用select多路复用，一方面从标准输入接收字节流，另一方面通过套接字读写，以及使用shutdown关闭半连接的能力。

服务器端程序则考察套接字读写的能力，以及对端连接关闭情况下的异常处理等能力。

题目不难，相信你可以做好。

## 题干

请你分别写一个客户端程序和服务器程序，客户端程序连接上服务器之后，通过敲命令和服务器进行交互，支持的交互命令包括：
<div><strong>精选留言（16）</strong></div><ul>
<li><img src="https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg" width="30px"><span>传说中的成大大</span> 👍（12） 💬（1）<div>https:&#47;&#47;github.com&#47;xiecheng1991&#47;network-practise-code-by-myself&#47;tree&#47;master&#47;mid_test
实现了如下功能
1. 自定义协议用于服务器端发送到客户端过后是否有需要打印的内容如ls和pwd的返回
2. 设置了心跳检测 如果客户端一定时间不发消息过后 服务器会断开它的连接并且退出,退出的原因在于因为只有一个客户端的连接 所以如果不退出会重复的select超时
3. 设置了重用so_reuseaddr 避免time_wait状态
4. 实现了ls命令
5. 实现了pwd命令
代码缺陷如下
1. 未完整的实现cd命令确实理解不到
2. 因为只能实现1对1的服务器客户端逻辑 所以很多地方写的不全面
今天晚上花了三个多小时把代码写好 并且通过gdb调试完成</div>2019-09-17</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/18/c1/39/11904266.jpg" width="30px"><span>Steiner</span> 👍（3） 💬（1）<div>第一次写这种比较大的交互程序,用c语言写了几次，感觉一堆东西都写在一起太难维护了,于是用c++做了点类设计.发现的程序bug太多了,目前打算简单的交互以下,服务端一次与一个客户端交互,服务端老是段错误，用gdb发现这个path一直都是0x0,不知道什么原因,求老师指正
https:&#47;&#47;github.com&#47;Ne-Steiner&#47;socket</div>2019-09-20</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/f6/e3/e4bcd69e.jpg" width="30px"><span>沉淀的梦想</span> 👍（3） 💬（1）<div>https:&#47;&#47;github.com&#47;DQinYuan&#47;homework-telnet-test

我主要是写Java的，没怎么写过C，边百度边写好不容易写出一版，代码可能比较简陋，老师不要嫌弃</div>2019-09-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/7e/53/c29c2fc9.jpg" width="30px"><span>sdjdd</span> 👍（2） 💬（1）<div>https:&#47;&#47;github.com&#47;sdjdd&#47;net-programming-midterm</div>2019-09-18</li><br/><li><img src="" width="30px"><span>ray</span> 👍（1） 💬（1）<div>感谢老师的指导，虽然写的有点晕，但还是收获良多。
现在还不敢说能徒手写出良好的socket程式，但若是要除错，使用linux工具找问题，已经顺畅许多了！
再次感谢老师的指导^^

平常用php开发，就用php写啦XD
https:&#47;&#47;github.com&#47;ChanJuiHuang&#47;php_socket_program</div>2020-04-09</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg" width="30px"><span>传说中的成大大</span> 👍（1） 💬（2）<div>这个期中大作业的难点不在网络方面 在于 如何在程序中如何cd ..&#47; pwd ls等等o(╥﹏╥)o</div>2019-09-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/07/71/9d4eead3.jpg" width="30px"><span>孙升</span> 👍（0） 💬（1）<div>https:&#47;&#47;github.com&#47;mandone&#47;net-code&#47;tree&#47;master&#47;mid-test 
补作业了，同Java开发，确实有点吃劲</div>2021-12-22</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/18/b3/17/19ea024f.jpg" width="30px"><span>chs</span> 👍（0） 💬（1）<div>https:&#47;&#47;github.com&#47;chenghengs&#47;network
请多指教</div>2019-11-10</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/18/b7/2c/e1682683.jpg" width="30px"><span>YidWang</span> 👍（0） 💬（1）<div>消息的去重 没有设计</div>2019-09-24</li><br/><li><img src="https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoFayz14Khwd5PUz23GfWCmXG8hRdwkwY32E0el2AwcicYC8qA5MgRouViaBIj3E9TibB9WjoYjsO80Q/132" width="30px"><span>coffee0218</span> 👍（0） 💬（1）<div>https:&#47;&#47;github.com&#47;coffee0218&#47;c_client_server
cd ~还是有问题</div>2019-09-19</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/16/63/2e/e49116d1.jpg" width="30px"><span>Geek_007</span> 👍（0） 💬（3）<div>我有一个问题，高级语言如go，它就没有epoll或者select(不是select那个关键字)。它的epoll只能是syscall，那是不是意味着协程和单进程的epoll多路复用是一样高效的呢？？？lua似乎也没有epoll的实现。但是他们也都很高效</div>2019-09-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/4b/36/ed40fb3a.jpg" width="30px"><span>(￣_￣ )</span> 👍（0） 💬（1）<div>https:&#47;&#47;github.com&#47;hongningexpro&#47;Linux_network_program&#47;tree&#47;master&#47;middle_exam</div>2019-09-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/11/dd/60/eae432c6.jpg" width="30px"><span>yusuf</span> 👍（0） 💬（1）<div>https:&#47;&#47;github.com&#47;linuxxiaoyu&#47;tcp</div>2019-09-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/12/50/35/079d04c8.jpg" width="30px"><span>向东</span> 👍（0） 💬（3）<div>服务器应用程序的当前路径怎么获取。
cd ..，怎么和当前路径进行关联起来？</div>2019-09-16</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/1e/b3/32/0ee78a1a.jpg" width="30px"><span>陈狄</span> 👍（0） 💬（0）<div>不好意思老师，作业交晚了
int main(int argc, char *argv[])
{
    int sockfd = 0, n = 0;
    char recvBuff[1024];
    char sendBuff[1024];
    struct sockaddr_in serv_addr;


    if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0) {
        return 1;
    }

    memset(&amp;serv_addr, 0, sizeof(serv_addr));
    
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(5000);

    if (inet_pton(AF_INET, argv[1], &amp;serv_addr.sin_addr) &lt;= 0) {
        printf(&quot;inet_pton error occured\n&quot;);
        return 1;
    }
    
    if (connect(sockfd, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr)) &lt; 0) {
        return 1;
    }

    while (scanf(&quot;%s&quot;, sendBuff) &gt; 0) {
        memset(recvBuff, 0, sizeof(recvBuff));
        write(sockfd, sendBuff, strlen(sendBuff));
        if ((n = read(sockfd, recvBuff, sizeof(recvBuff) - 1)) &gt; 0) {
            printf(&quot;%s \n&quot;, recvBuff);
        }
        memset(sendBuff, 0, sizeof(sendBuff));
    }

    return 0;
}

&#47;&#47; 服务器端
int main(int argc, char *argv[]) {
    int listenfd = 0, connfd = 0;
    struct sockaddr_in serv_addr;

    char recvBuff[1024];
    listenfd = socket(AF_INET, SOCK_STREAM, 0);
    memset(&amp;serv_addr, &#39;0&#39;, sizeof(serv_addr));

    serv_addr.sin_family = AF_INET;
    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    serv_addr.sin_port = htons(5000);

    bind(listenfd, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr));
    
    listen(listenfd, 10);

    while (1) {
        connfd = accept(listenfd, (struct sockaddr *)NULL, NULL);
        printf(&quot;accept client fd:%d \n&quot;, connfd);

        while (read(connfd, recvBuff, sizeof(recvBuff) - 1) &gt; 0) {
            FILE *fp;
            char buffer[80];
            fp = popen(recvBuff, &quot;r&quot;);
            fgets(buffer, sizeof(buffer), fp);
            write(connfd, buffer, strlen(buffer));
            pclose(fp);
            memset(recvBuff, 0, sizeof(recvBuff));
        }
        printf(&quot;client exit \n&quot;);
        sleep(1);
    }
</div>2023-09-18</li><br/><li><img src="https://static001.geekbang.org/account/avatar/00/14/2b/84/07f0c0d6.jpg" width="30px"><span>supermouse</span> 👍（0） 💬（0）<div>https:&#47;&#47;github.com&#47;YoungYo&#47;MidtermAssignment&#47;tree&#47;master
主要是参考了老师的第11讲的代码，老师说的要求基本都实现了，唯一有点缺陷的是执行cd命令的时候不能执行“cd -”、“cd ~”这类命令，只能指定确切的目录名，比如“&#47;home”</div>2020-02-20</li><br/>
</ul>